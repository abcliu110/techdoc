# 在 Rancher/RKE2 中部署本地镜像仓库完整指南

## 一、部署 Docker Registry

### 1.1 生成认证密码

```bash
# 安装 htpasswd 工具（如果没有）
# Ubuntu/Debian
apt-get install apache2-utils

# CentOS/RHEL
yum install httpd-tools

# 生成密码（用户名：admin，密码：st11338）
htpasswd -Bbn admin st11338

# 输出示例：
# admin:$2y$05$xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
```

### 1.2 修改配置文件

编辑 `docker-registry-deployment.yaml`：

1. **修改 Secret 中的密码**（第 30 行）
   ```yaml
   stringData:
     htpasswd: |
       admin:$2y$05$你生成的密码哈希
   ```

2. **修改 Ingress 域名**（第 134 行）
   ```yaml
   - host: registry.your-domain.com  # 改为你的域名
   ```

3. **调整存储大小**（第 19 行）
   ```yaml
   storage: 100Gi  # 根据需求调整
   ```

### 1.3 部署到 Rancher

**方法 1：通过 kubectl**
```bash
kubectl apply -f docker-registry-deployment.yaml
```

**方法 2：通过 Rancher UI**
1. 登录 Rancher 控制台
2. 选择你的集群
3. 进入 **工作负载** → **部署**
4. 点击 **从 YAML 导入**
5. 粘贴 `docker-registry-deployment.yaml` 内容
6. 点击 **导入**

### 1.4 验证部署

```bash
# 检查 Pod 状态
kubectl get pods -n docker-registry

# 应该看到：
# NAME                              READY   STATUS    RESTARTS   AGE
# docker-registry-xxxxxxxxxx-xxxxx   1/1     Running   0          1m

# 检查 Service
kubectl get svc -n docker-registry

# 检查 Ingress
kubectl get ingress -n docker-registry
```

### 1.5 测试访问

```bash
# 内部访问（在集群内）
curl http://docker-registry.docker-registry.svc.cluster.local:5000/v2/

# 外部访问（通过 Ingress）
curl http://registry.your-domain.com/v2/

# 应该返回：{}
```

## 二、配置 Docker 客户端访问

### 2.1 配置 Docker 登录

```bash
# 登录本地仓库
docker login registry.your-domain.com
# 输入用户名：admin
# 输入密码：password123

# 或使用命令行
echo "password123" | docker login registry.your-domain.com -u admin --password-stdin
```

### 2.2 推送测试镜像

```bash
# 拉取一个测试镜像
docker pull nginx:latest

# 打标签
docker tag nginx:latest registry.your-domain.com/nginx:latest

# 推送到本地仓库
docker push registry.your-domain.com/nginx:latest

# 查看仓库中的镜像
curl -u admin:password123 http://registry.your-domain.com/v2/_catalog
# 输出：{"repositories":["nginx"]}
```

## 三、配置 Jenkins 使用本地仓库

### 3.1 创建 Kubernetes Secret

```bash
# 创建 Docker 认证 Secret
kubectl create secret docker-registry local-registry-secret \
  --docker-server=registry.your-domain.com \
  --docker-username=admin \
  --docker-password=password123 \
  --namespace=jenkins

# 或者使用 YAML
cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: local-registry-secret
  namespace: jenkins
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: $(echo -n '{"auths":{"registry.your-domain.com":{"username":"admin","password":"password123","auth":"'$(echo -n admin:password123 | base64)'"}}}' | base64 -w 0)
EOF
```

### 3.2 修改 Jenkinsfile

修改 `Jenkinsfile-nms4cloud-optimized`：

**修改环境变量（第 33-34 行）：**
```groovy
environment {
    // 修改为本地仓库
    DOCKER_REGISTRY = 'registry.your-domain.com'  // 本地仓库地址
    DOCKER_NAMESPACE = 'nms4cloud'
    DOCKER_CREDENTIAL_ID = 'local-registry-secret'  // 本地仓库凭据
    IMAGE_TAG = "${env.BUILD_NUMBER}"
}
```

**修改 Kaniko Pod 配置（第 318-323 行）：**
```yaml
volumes:
- name: docker-config
  secret:
    secretName: local-registry-secret  # 改为本地仓库 Secret
    items:
    - key: .dockerconfigjson
      path: config.json
```

**修改 Kaniko 命令（第 513 行）：**
```bash
/kaniko/executor \
  --context=$(pwd) \
  --dockerfile=Dockerfile \
  --destination=registry.your-domain.com/nms4cloud/${appName}:${IMAGE_TAG} \
  --destination=registry.your-domain.com/nms4cloud/${appName}:latest \
  --cache=true \
  --cache-repo=registry.your-domain.com/nms4cloud/cache \
  --insecure  # 如果使用 HTTP（不推荐生产环境）
  # 或
  --skip-tls-verify  # 如果使用自签名证书
```

### 3.3 完整的修改示例

```groovy
// Jenkinsfile 环境变量部分
environment {
    // Maven 配置
    MAVEN_HOME = tool 'Maven'
    MAVEN_OPTS = '-Xmx2048m'
    PATH = "${MAVEN_HOME}/bin:${env.PATH}"
    MAVEN_LOCAL_REPO = '/var/jenkins_home/maven-repository'
    MAVEN_CACHE_OPTS = "-Dmaven.repo.local=${MAVEN_LOCAL_REPO}"

    // 项目配置
    PROJECT_NAME = 'nms4cloud'
    ARTIFACT_VERSION = '0.0.1-SNAPSHOT'

    // Git 配置
    GIT_CREDENTIAL_ID = 'aliyun-codeup-token'
    GIT_BRANCH = "${params.GIT_BRANCH ?: 'master'}"
    REPO_MAIN = 'https://codeup.aliyun.com/...'
    REPO_BI = 'https://codeup.aliyun.com/...'
    REPO_WMS = 'https://codeup.aliyun.com/...'

    // Docker 镜像配置 - 修改为本地仓库
    DOCKER_REGISTRY = 'registry.your-domain.com'  // ← 本地仓库
    DOCKER_NAMESPACE = 'nms4cloud'
    DOCKER_CREDENTIAL_ID = 'local-registry-secret'  // ← 本地凭据
    IMAGE_TAG = "${env.BUILD_NUMBER}"

    // 构建开关
    BUILD_BI = true
    BUILD_WMS = true
}
```

## 四、配置 Kubernetes 使用本地仓库

### 4.1 配置节点信任本地仓库

如果使用 HTTP 或自签名证书，需要配置 RKE2 节点：

```bash
# 在每个 RKE2 节点上执行

# 方法 1：配置 containerd（RKE2 使用 containerd）
cat <<EOF > /etc/rancher/rke2/registries.yaml
mirrors:
  registry.your-domain.com:
    endpoint:
      - "http://registry.your-domain.com"  # HTTP
      # 或
      - "https://registry.your-domain.com"  # HTTPS

configs:
  "registry.your-domain.com":
    auth:
      username: admin
      password: password123
    tls:
      insecure_skip_verify: true  # 跳过证书验证（仅测试环境）
EOF

# 重启 RKE2
systemctl restart rke2-server  # 或 rke2-agent
```

### 4.2 创建 ImagePullSecret

```bash
# 为应用命名空间创建 Secret
kubectl create secret docker-registry local-registry-secret \
  --docker-server=registry.your-domain.com \
  --docker-username=admin \
  --docker-password=password123 \
  --namespace=default  # 或你的应用命名空间
```

### 4.3 在 Deployment 中使用

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nms4cloud-biz-app
spec:
  template:
    spec:
      containers:
      - name: app
        image: registry.your-domain.com/nms4cloud/biz-app:123  # 本地仓库镜像
      imagePullSecrets:
      - name: local-registry-secret  # 拉取镜像的凭据
```

## 五、高级配置

### 5.1 启用 HTTPS（推荐生产环境）

**使用 cert-manager 自动签发证书：**

```bash
# 安装 cert-manager
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml

# 创建 ClusterIssuer
cat <<EOF | kubectl apply -f -
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: your-email@example.com
    privateKeySecretRef:
      name: letsencrypt-prod
    solvers:
    - http01:
        ingress:
          class: nginx
EOF
```

**修改 Ingress 启用 TLS：**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: docker-registry
  namespace: docker-registry
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/proxy-body-size: "0"
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - registry.your-domain.com
    secretName: registry-tls  # cert-manager 自动创建
  rules:
  - host: registry.your-domain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: docker-registry
            port:
              number: 5000
```

### 5.2 配置镜像清理策略

```yaml
# 添加 CronJob 定期清理旧镜像
apiVersion: batch/v1
kind: CronJob
metadata:
  name: registry-garbage-collect
  namespace: docker-registry
spec:
  schedule: "0 2 * * 0"  # 每周日凌晨 2 点
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: garbage-collect
            image: registry:2
            command:
            - /bin/registry
            - garbage-collect
            - /etc/docker/registry/config.yml
            volumeMounts:
            - name: registry-data
              mountPath: /var/lib/registry
            - name: registry-config
              mountPath: /etc/docker/registry
          volumes:
          - name: registry-data
            persistentVolumeClaim:
              claimName: registry-data
          - name: registry-config
            configMap:
              name: registry-config
          restartPolicy: OnFailure
```

### 5.3 配置 UI 界面（可选）

部署 Docker Registry UI：

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: registry-ui
  namespace: docker-registry
spec:
  replicas: 1
  selector:
    matchLabels:
      app: registry-ui
  template:
    metadata:
      labels:
        app: registry-ui
    spec:
      containers:
      - name: ui
        image: joxit/docker-registry-ui:latest
        ports:
        - containerPort: 80
        env:
        - name: REGISTRY_TITLE
          value: "NMS4Cloud Docker Registry"
        - name: REGISTRY_URL
          value: "http://docker-registry:5000"
        - name: DELETE_IMAGES
          value: "true"
        - name: SINGLE_REGISTRY
          value: "true"
---
apiVersion: v1
kind: Service
metadata:
  name: registry-ui
  namespace: docker-registry
spec:
  ports:
  - port: 80
    targetPort: 80
  selector:
    app: registry-ui
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: registry-ui
  namespace: docker-registry
spec:
  ingressClassName: nginx
  rules:
  - host: registry-ui.your-domain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: registry-ui
            port:
              number: 80
```

## 六、管理和维护

### 6.1 查看仓库中的镜像

```bash
# 列出所有仓库
curl -u admin:password123 http://registry.your-domain.com/v2/_catalog

# 列出某个仓库的标签
curl -u admin:password123 http://registry.your-domain.com/v2/nms4cloud/biz-app/tags/list

# 获取镜像详细信息
curl -u admin:password123 http://registry.your-domain.com/v2/nms4cloud/biz-app/manifests/latest
```

### 6.2 删除镜像

```bash
# 1. 获取镜像的 digest
DIGEST=$(curl -I -u admin:password123 \
  -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \
  http://registry.your-domain.com/v2/nms4cloud/biz-app/manifests/latest \
  | grep Docker-Content-Digest | awk '{print $2}' | tr -d '\r')

# 2. 删除镜像
curl -u admin:password123 -X DELETE \
  http://registry.your-domain.com/v2/nms4cloud/biz-app/manifests/$DIGEST

# 3. 运行垃圾回收（在 registry pod 中）
kubectl exec -n docker-registry <registry-pod-name> -- \
  /bin/registry garbage-collect /etc/docker/registry/config.yml
```

### 6.3 备份和恢复

```bash
# 备份（备份 PVC 数据）
kubectl exec -n docker-registry <registry-pod-name> -- \
  tar czf /tmp/registry-backup.tar.gz /var/lib/registry

kubectl cp docker-registry/<registry-pod-name>:/tmp/registry-backup.tar.gz \
  ./registry-backup-$(date +%Y%m%d).tar.gz

# 恢复
kubectl cp ./registry-backup-20240101.tar.gz \
  docker-registry/<registry-pod-name>:/tmp/

kubectl exec -n docker-registry <registry-pod-name> -- \
  tar xzf /tmp/registry-backup-20240101.tar.gz -C /
```

## 七、故障排查

### 7.1 无法推送镜像

```bash
# 检查认证
docker login registry.your-domain.com

# 检查网络连接
curl -v http://registry.your-domain.com/v2/

# 检查 Pod 日志
kubectl logs -n docker-registry <registry-pod-name>

# 检查存储空间
kubectl exec -n docker-registry <registry-pod-name> -- df -h
```

### 7.2 Kaniko 推送失败

```bash
# 检查 Secret 是否正确
kubectl get secret local-registry-secret -n jenkins -o yaml

# 检查 Kaniko Pod 日志
kubectl logs -n jenkins <kaniko-pod-name> -c kaniko

# 常见错误：
# - "unauthorized": Secret 配置错误
# - "connection refused": 网络不通
# - "certificate verify failed": TLS 证书问题
```

### 7.3 镜像拉取失败

```bash
# 检查 ImagePullSecret
kubectl get secret local-registry-secret -n <namespace>

# 检查 Pod 事件
kubectl describe pod <pod-name>

# 检查节点配置
cat /etc/rancher/rke2/registries.yaml
```

## 八、总结

### 8.1 部署流程

```
1. 部署 Docker Registry
   ↓
2. 配置认证和存储
   ↓
3. 创建 Kubernetes Secret
   ↓
4. 修改 Jenkinsfile 配置
   ↓
5. 配置 RKE2 节点信任仓库
   ↓
6. 测试推送和拉取
```

### 8.2 关键配置点

| 配置项 | 位置 | 说明 |
|--------|------|------|
| **仓库地址** | Jenkinsfile `DOCKER_REGISTRY` | 本地仓库域名 |
| **认证 Secret** | Kubernetes Secret | Docker 登录凭据 |
| **Kaniko 配置** | Jenkinsfile Kaniko stage | 推送目标仓库 |
| **节点配置** | `/etc/rancher/rke2/registries.yaml` | containerd 仓库配置 |

### 8.3 优势

✅ **完全控制**：镜像存储在本地，不依赖外部服务
✅ **网络性能**：内网传输，速度快
✅ **安全性**：敏感镜像不出内网
✅ **成本**：无需支付云服务费用
✅ **离线环境**：支持离线部署

### 8.4 下一步

1. 部署 Docker Registry
2. 测试推送和拉取
3. 修改 Jenkinsfile 配置
4. 运行 Jenkins 构建验证
5. （可选）部署 Harbor 替代 Docker Registry