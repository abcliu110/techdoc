# Jenkins 流水线设计模式说明

## 一、单流水线多阶段（推荐）

### 设计

```
┌─────────────────────────────────────────────────────────────┐
│                    单个 Jenkinsfile                          │
├─────────────────────────────────────────────────────────────┤
│ Stage 1: 代码检出                                            │
│ Stage 2: Maven 构建 → 生成 JAR                              │
│ Stage 3: 单元测试                                            │
│ Stage 4: 构建 Docker 镜像 → 使用 JAR                        │
│ Stage 5: 推送镜像到私有仓库                                  │
│ Stage 6: 部署到 K8s（可选）                                 │
└─────────────────────────────────────────────────────────────┘
```

### 优点
- ✅ 流程清晰，一气呵成
- ✅ JAR 和镜像版本强一致性
- ✅ 易于追踪和回滚
- ✅ 构建号统一管理
- ✅ 减少人工干预

### 缺点
- ⚠️ 构建时间较长（5-10分钟）
- ⚠️ 任何阶段失败需要重新开始
- ⚠️ 不适合需要人工审批的场景

### 适用场景
- ✅ 小型到中型项目
- ✅ 快速迭代开发
- ✅ 自动化 CI/CD
- ✅ 单团队维护

### 示例代码

```groovy
// Jenkinsfile-all-in-one
pipeline {
    agent { kubernetes { ... } }
    
    stages {
        stage('构建 JAR') {
            steps {
                container('maven') {
                    sh 'mvn clean package'
                }
            }
        }
        
        stage('构建镜像') {
            steps {
                container('kaniko') {
                    sh '/kaniko/executor ...'
                }
            }
        }
    }
}
```

## 二、多流水线分离

### 设计

```
┌─────────────────────────────────────┐
│   流水线 1: 构建 JAR                 │
├─────────────────────────────────────┤
│ Stage 1: 代码检出                    │
│ Stage 2: Maven 构建                  │
│ Stage 3: 单元测试                    │
│ Stage 4: 归档 JAR 到 Artifactory    │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│   流水线 2: 构建镜像                 │
├─────────────────────────────────────┤
│ Stage 1: 下载 JAR                    │
│ Stage 2: 构建 Docker 镜像            │
│ Stage 3: 推送到私有仓库              │
└─────────────────────────────────────┘
              ↓
┌─────────────────────────────────────┐
│   流水线 3: 部署                     │
├─────────────────────────────────────┤
│ Stage 1: 拉取镜像                    │
│ Stage 2: 部署到 K8s                  │
│ Stage 3: 健康检查                    │
└─────────────────────────────────────┘
```

### 优点
- ✅ 职责分离，每个流水线专注一件事
- ✅ 可以独立重试某个阶段
- ✅ 适合权限分离（开发/运维）
- ✅ 支持人工审批流程

### 缺点
- ❌ 流程复杂，需要传递构建产物
- ❌ 版本管理困难
- ❌ 需要额外的存储（Artifactory/Nexus）
- ❌ 配置和维护成本高

### 适用场景
- ✅ 大型企业项目
- ✅ 严格的权限控制
- ✅ 需要人工审批
- ✅ 多团队协作

### 示例代码

**流水线 1: 构建 JAR**
```groovy
// Jenkinsfile-build-jar
pipeline {
    agent { kubernetes { ... } }
    
    stages {
        stage('构建 JAR') {
            steps {
                container('maven') {
                    sh 'mvn clean package'
                }
            }
        }
        
        stage('上传到 Artifactory') {
            steps {
                sh '''
                    curl -u admin:password \\
                      -T target/*.jar \\
                      http://artifactory/repo/demo-springboot-${BUILD_NUMBER}.jar
                '''
            }
        }
    }
}
```

**流水线 2: 构建镜像**
```groovy
// Jenkinsfile-build-image
pipeline {
    agent { kubernetes { ... } }
    
    parameters {
        string(name: 'JAR_BUILD_NUMBER', description: 'JAR 构建号')
    }
    
    stages {
        stage('下载 JAR') {
            steps {
                sh '''
                    curl -u admin:password \\
                      -o app.jar \\
                      http://artifactory/repo/demo-springboot-${JAR_BUILD_NUMBER}.jar
                '''
            }
        }
        
        stage('构建镜像') {
            steps {
                container('kaniko') {
                    sh '/kaniko/executor ...'
                }
            }
        }
    }
}
```

## 三、混合模式（灵活推荐）

### 设计

```
┌─────────────────────────────────────────────────────────────┐
│   流水线 1: 构建和镜像（自动）                               │
├─────────────────────────────────────────────────────────────┤
│ Stage 1: 代码检出                                            │
│ Stage 2: Maven 构建                                          │
│ Stage 3: 构建 Docker 镜像                                    │
│ Stage 4: 推送到私有仓库                                      │
└─────────────────────────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────────────────────────┐
│   流水线 2: 部署到测试环境（自动）                           │
├─────────────────────────────────────────────────────────────┤
│ Stage 1: 拉取镜像                                            │
│ Stage 2: 部署到测试环境                                      │
│ Stage 3: 自动化测试                                          │
└─────────────────────────────────────────────────────────────┘
              ↓
┌─────────────────────────────────────────────────────────────┐
│   流水线 3: 部署到生产环境（需要审批）                       │
├─────────────────────────────────────────────────────────────┤
│ Stage 1: 人工审批                                            │
│ Stage 2: 拉取镜像                                            │
│ Stage 3: 部署到生产环境                                      │
│ Stage 4: 健康检查                                            │
└─────────────────────────────────────────────────────────────┘
```

### 优点
- ✅ 构建和镜像在一起（保证一致性）
- ✅ 部署独立（灵活控制）
- ✅ 支持多环境部署
- ✅ 支持审批流程

### 适用场景
- ✅ 多环境部署（开发、测试、生产）
- ✅ 需要部署审批流程
- ✅ 中大型项目

### 示例代码

**流水线 1: 构建和镜像**
```groovy
// Jenkinsfile-build
pipeline {
    stages {
        stage('构建 JAR') { ... }
        stage('构建镜像') { ... }
        stage('推送镜像') { ... }
        
        stage('触发部署') {
            steps {
                build job: 'deploy-to-test',
                      parameters: [
                          string(name: 'IMAGE_TAG', value: "${BUILD_NUMBER}")
                      ]
            }
        }
    }
}
```

**流水线 2: 部署到测试**
```groovy
// Jenkinsfile-deploy-test
pipeline {
    parameters {
        string(name: 'IMAGE_TAG')
    }
    
    stages {
        stage('部署') {
            steps {
                sh """
                    kubectl set image deployment/demo-springboot \\
                      demo-springboot=192.168.80.100:30500/demo-springboot:${IMAGE_TAG} \\
                      -n test
                """
            }
        }
    }
}
```

**流水线 3: 部署到生产**
```groovy
// Jenkinsfile-deploy-prod
pipeline {
    parameters {
        string(name: 'IMAGE_TAG')
    }
    
    stages {
        stage('人工审批') {
            steps {
                input message: '确认部署到生产环境？',
                      ok: '部署'
            }
        }
        
        stage('部署') {
            steps {
                sh """
                    kubectl set image deployment/demo-springboot \\
                      demo-springboot=192.168.80.100:30500/demo-springboot:${IMAGE_TAG} \\
                      -n production
                """
            }
        }
    }
}
```

## 四、选择建议

### 小型项目（1-5人团队）
**推荐：单流水线多阶段**
- 简单直接
- 易于维护
- 快速迭代

### 中型项目（5-20人团队）
**推荐：混合模式**
- 构建和镜像在一起
- 部署独立控制
- 支持多环境

### 大型项目（20+人团队）
**推荐：多流水线分离**
- 职责分离
- 权限控制
- 审批流程

## 五、实际案例

### 案例 1：创业公司（单流水线）

```
代码提交 → 自动构建 → 自动测试 → 自动构建镜像 → 自动部署到测试环境
```

**特点：**
- 全自动化
- 快速反馈
- 一个 Jenkinsfile 搞定

### 案例 2：互联网公司（混合模式）

```
代码提交 → 自动构建镜像 → 自动部署到开发环境
                        ↓
                   自动部署到测试环境
                        ↓
                   人工审批 → 部署到生产环境
```

**特点：**
- 开发和测试自动化
- 生产环境需要审批
- 3个流水线

### 案例 3：传统企业（多流水线）

```
开发团队：构建 JAR → 上传到 Artifactory
                        ↓
运维团队：下载 JAR → 构建镜像 → 推送到私有仓库
                        ↓
运维团队：人工审批 → 部署到生产环境
```

**特点：**
- 严格权限分离
- 多个审批节点
- 5+ 个流水线

## 六、总结

| 模式 | 复杂度 | 灵活性 | 维护成本 | 适用规模 |
|------|--------|--------|----------|----------|
| 单流水线 | 低 | 低 | 低 | 小型 |
| 混合模式 | 中 | 高 | 中 | 中型 |
| 多流水线 | 高 | 高 | 高 | 大型 |

**对于你的项目，强烈推荐使用当前的单流水线多阶段模式（Jenkinsfile-k8s）！**

这是最佳实践，符合现代 CI/CD 理念。
