# 镜像推送加速 - 快速实施指南

## 推荐组合方案

根据你的情况，我推荐以下组合：

```
方案 2 (分层构建) + 方案 3 (Alpine) + 方案 1 (本地仓库)
    ↓
推送时间：从 8 分钟降到 10 秒
提升：98%
```

---

## 🚀 立即可做（今天）

### 1. Alpine 基础镜像（5 分钟实施）

**效果：** 推送时间从 8 分钟降到 6 分钟

**步骤：**

```bash
# 1. 修改每个模块的 Dockerfile
# nms4cloud-pos3boot/nms4cloud-pos3boot-app/Dockerfile
# nms4cloud-pos4cloud/nms4cloud-pos4cloud-app/Dockerfile
# nms4cloud-pos5sync/nms4cloud-pos5sync-app/Dockerfile

# 原来
FROM eclipse-temurin:21-jre

# 改为
FROM eclipse-temurin:21-jre-alpine

# 添加时区支持
RUN apk add --no-cache tzdata && \
    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && \
    apk del tzdata
```

**完整 Dockerfile：**

```dockerfile
FROM eclipse-temurin:21-jre-alpine

WORKDIR /app

COPY target/*.jar app.jar

# 时区设置
RUN apk add --no-cache tzdata && \
    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && \
    apk del tzdata

# 创建非 root 用户
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

ENV JAVA_OPTS="-Xms512m -Xmx1024m -XX:+UseG1GC"

EXPOSE 8080

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar /app/app.jar"]
```

**提交代码：**

```bash
cd /f/python资料
git add .
git commit -m "优化: 使用 Alpine 基础镜像减小体积"
git push
```

---

### 2. Spring Boot 分层构建（15 分钟实施）

**效果：** 后续推送时间从 6 分钟降到 1 分钟

**步骤：**

#### A. 修改 pom.xml（3 个模块）

```bash
# 1. nms4cloud-pos3boot/nms4cloud-pos3boot-app/pom.xml
# 2. nms4cloud-pos4cloud/nms4cloud-pos4cloud-app/pom.xml
# 3. nms4cloud-pos5sync/nms4cloud-pos5sync-app/pom.xml
```

在每个 pom.xml 的 `<build>` 部分添加：

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <!-- 启用分层 -->
                <layers>
                    <enabled>true</enabled>
                </layers>
            </configuration>
        </plugin>
    </plugins>
</build>
```

#### B. 修改 Dockerfile（3 个模块）

```dockerfile
# ============================================================================
# 阶段 1: 提取分层
# ============================================================================
FROM eclipse-temurin:21-jre-alpine AS builder

WORKDIR /app

COPY target/*.jar app.jar

# 提取分层
RUN java -Djarmode=layertools -jar app.jar extract

# ============================================================================
# 阶段 2: 构建最终镜像
# ============================================================================
FROM eclipse-temurin:21-jre-alpine

WORKDIR /app

# 按顺序复制各层（利用 Docker 缓存）
COPY --from=builder /app/dependencies/ ./
COPY --from=builder /app/spring-boot-loader/ ./
COPY --from=builder /app/snapshot-dependencies/ ./
COPY --from=builder /app/application/ ./

# 时区设置
RUN apk add --no-cache tzdata && \
    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && \
    apk del tzdata

# 创建非 root 用户
RUN addgroup -S spring && adduser -S spring -G spring
USER spring:spring

ENV JAVA_OPTS="-Xms512m -Xmx1024m -XX:+UseG1GC"

EXPOSE 8080

# 使用 JarLauncher 启动
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS org.springframework.boot.loader.JarLauncher"]
```

#### C. 提交代码

```bash
cd /f/python资料
git add .
git commit -m "优化: 启用 Spring Boot 分层构建"
git push
```

---

## 📅 本周可做

### 3. 部署本地镜像仓库（1 小时实施）

**效果：** 推送时间从 1 分钟降到 10 秒

**步骤：**

#### A. 创建配置文件

```bash
# 在你的项目中创建
mkdir -p k8s/registry
cd k8s/registry
```

创建 `registry-deployment.yaml`：

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: registry

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: registry-pvc
  namespace: registry
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 100Gi

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: docker-registry
  namespace: registry
spec:
  replicas: 1
  selector:
    matchLabels:
      app: docker-registry
  template:
    metadata:
      labels:
        app: docker-registry
    spec:
      containers:
      - name: registry
        image: registry:2
        ports:
        - containerPort: 5000
        env:
        - name: REGISTRY_STORAGE_DELETE_ENABLED
          value: "true"
        volumeMounts:
        - name: registry-data
          mountPath: /var/lib/registry
        resources:
          requests:
            cpu: 500m
            memory: 512Mi
          limits:
            cpu: 1000m
            memory: 1Gi
      volumes:
      - name: registry-data
        persistentVolumeClaim:
          claimName: registry-pvc

---
apiVersion: v1
kind: Service
metadata:
  name: docker-registry
  namespace: registry
spec:
  selector:
    app: docker-registry
  ports:
  - port: 5000
    targetPort: 5000
  type: ClusterIP
```

#### B. 部署到 K8s

```bash
kubectl apply -f registry-deployment.yaml

# 验证
kubectl get pods -n registry
kubectl get svc -n registry

# 测试
kubectl run test-pod --rm -i --restart=Never \
  --image=curlimages/curl -- \
  curl http://docker-registry.registry.svc.cluster.local:5000/v2/_catalog
```

#### C. 修改 Jenkinsfile

在 `environment` 部分添加：

```groovy
environment {
    // ... 现有配置 ...

    // 本地镜像仓库
    LOCAL_REGISTRY = 'docker-registry.registry.svc.cluster.local:5000'
    USE_LOCAL_REGISTRY = true  // 开关
}
```

修改 `buildAndPushDockerImage` 函数：

```groovy
def buildAndPushDockerImage(String moduleName, String buildContext) {
    def dockerImageName = "${DOCKER_REGISTRY}/${DOCKER_NAMESPACE}/nms4cloud-${moduleName}"
    def localImageName = "${LOCAL_REGISTRY}/nms4cloud-${moduleName}"

    container('kaniko') {
        sh """
            echo ">>> 开始构建镜像..."

            # 推送到本地仓库（如果启用）
            if [ "${USE_LOCAL_REGISTRY}" = "true" ]; then
                echo ">>> 推送到本地仓库..."
                /kaniko/executor \\
                    --context=${buildContext} \\
                    --dockerfile=${buildContext}/Dockerfile \\
                    --destination=${localImageName}:${BUILD_NUMBER} \\
                    --destination=${localImageName}:latest \\
                    --insecure \\
                    --skip-tls-verify \\
                    --compression=gzip \\
                    --compression-level=9 \\
                    --cache=false

                echo "✓ 镜像已推送到本地仓库"
            fi

            # 推送到阿里云（可选，后台执行）
            echo ">>> 推送到阿里云..."
            /kaniko/executor \\
                --context=${buildContext} \\
                --dockerfile=${buildContext}/Dockerfile \\
                --destination=${dockerImageName}:${BUILD_NUMBER} \\
                --destination=${dockerImageName}:latest \\
                --compression=gzip \\
                --compression-level=9 \\
                --cache=false

            echo "✓ 镜像已推送到阿里云"
        """
    }

    env.DOCKER_IMAGE_FULL = "${dockerImageName}:${BUILD_NUMBER}"
    env.LOCAL_IMAGE_FULL = "${localImageName}:${BUILD_NUMBER}"
    env.MODULE_NAME = moduleName
}
```

---

## 📊 效果对比

### 当前状态
```
Maven 构建: 2 分钟
镜像推送: 8 分钟
总计: 10 分钟
```

### 优化后（Alpine）
```
Maven 构建: 2 分钟
镜像推送: 6 分钟
总计: 8 分钟
节省: 20%
```

### 优化后（Alpine + 分层，首次）
```
Maven 构建: 2 分钟
镜像推送: 6 分钟
总计: 8 分钟
节省: 20%
```

### 优化后（Alpine + 分层，后续）
```
Maven 构建: 2 分钟
镜像推送: 1 分钟  ← 只推送代码层
总计: 3 分钟
节省: 70%
```

### 优化后（Alpine + 分层 + 本地仓库）
```
Maven 构建: 2 分钟
推送到本地: 10 秒
K8s 部署: 5 秒
总计: 2 分 15 秒
节省: 77.5%
```

---

## 🎯 实施优先级

### 第 1 天：Alpine 基础镜像
- 时间：5 分钟
- 效果：节省 20%
- 难度：⭐

### 第 2 天：Spring Boot 分层
- 时间：15 分钟
- 效果：节省 70%（后续构建）
- 难度：⭐⭐

### 第 3-5 天：本地镜像仓库
- 时间：1 小时
- 效果：节省 77.5%
- 难度：⭐⭐⭐

---

## 🔍 验证效果

### 查看镜像大小

```bash
# 阿里云镜像
docker pull crpi-xxx.cn-hangzhou.personal.cr.aliyuncs.com/lgy-images/nms4cloud-pos4cloud:latest
docker images | grep nms4cloud-pos4cloud

# 对比
标准 JRE:  255 MB
Alpine:    205 MB  (节省 50 MB)
```

### 查看推送时间

在 Jenkins 构建日志中：

```
╔════════════════════════════════════════╗
║         推送完成统计                    ║
╚════════════════════════════════════════╝
>>> 推送耗时: 1 分 15 秒
>>> 平均速度: 2.7 MB/s

优化前: 8 分钟
优化后: 1 分 15 秒
节省: 84%
```

---

## 📝 检查清单

### Alpine 基础镜像
- [ ] 修改 3 个 Dockerfile
- [ ] 添加时区支持
- [ ] 提交代码
- [ ] 触发构建
- [ ] 验证应用正常运行

### Spring Boot 分层
- [ ] 修改 3 个 pom.xml
- [ ] 修改 3 个 Dockerfile
- [ ] 提交代码
- [ ] 首次构建（时间相同）
- [ ] 第二次构建（验证加速效果）

### 本地镜像仓库
- [ ] 创建 registry-deployment.yaml
- [ ] 部署到 K8s
- [ ] 验证 Registry 运行正常
- [ ] 修改 Jenkinsfile
- [ ] 测试推送到本地仓库
- [ ] 验证 K8s 可以拉取镜像

---

## 🆘 常见问题

### Q1: Alpine 镜像会有兼容性问题吗？

**A:** 极少数情况会有问题，主要是：
- 使用了 glibc 特定功能（Alpine 使用 musl libc）
- 使用了本地库（.so 文件）

**解决方案：**
```dockerfile
# 如果遇到兼容性问题，安装 glibc 兼容层
RUN apk add --no-cache gcompat
```

### Q2: 分层构建会影响应用启动吗？

**A:** 不会，启动方式略有不同：
- 标准：`java -jar app.jar`
- 分层：`java org.springframework.boot.loader.JarLauncher`

效果完全相同。

### Q3: 本地仓库会占用多少存储？

**A:** 估算：
- 每个镜像：200 MB
- 3 个模块：600 MB
- 保留 10 个版本：6 GB
- 建议分配：50-100 GB

### Q4: 本地仓库挂了怎么办？

**A:** 可以配置回退：
```groovy
if [ "${USE_LOCAL_REGISTRY}" = "true" ]; then
    # 尝试推送到本地
    /kaniko/executor ... || {
        echo "本地仓库不可用，回退到阿里云"
        USE_LOCAL_REGISTRY=false
    }
fi
```

---

## 📞 需要帮助？

如果实施过程中遇到问题，提供以下信息：
1. 具体步骤
2. 错误日志
3. 环境信息（K8s 版本、存储类型等）

我可以帮你调试！
