<div id="chap-descriptor"></div>

[⬆️ 返回目录](#catalog)

## 描述符

优先级的哲学

Python 的属性查找顺序（MRO -> Data Descriptor -> Instance Dict -> Non-Data Descriptor -> Class Attribute）体现了以下哲学：

1.  **最高法律（数据描述符）**：
    *   如果你定义了 `__set__`，说明你对此属性有严格的管理要求（读写都要管）。
    *   **必须拦截**，实例不能自己随便存个值就了事。
    *   *应用：属性验证、只读属性、动态计算。*

2.  **个人自由（实例字典 `__dict__`）**：
    *   如果类没有强制管理（不是数据描述符），那么实例自己的数据最大。
    *   *应用：普通的实例变量 `self.x = 1`。*

3.  **默认规则（非数据描述符）**：
    *   如果实例没数据，就用类的默认逻辑（通常是方法）。
    *   *应用：类方法、`@cached_property`（一旦计算出值放入 `__dict__`，下次就直接取值，不再运行描述符）。*

```python

#模拟getattribute方法

# 数据描述符优先级最高 → 实例属性 → 非数据描述符 → 类属性
def mock_getattribute(obj, name):
    # 获取实例对应的类
    cls = type(obj)
    # 查询类中是否有此属性
    descriptor = getattr(cls, name, None)
    # 判断属性是否是数据描述符 
    is_data_descriptor = hasattr(descriptor, '__set__') or hasattr(descriptor, '__delete__') 
    if is_data_descriptor:
        # 数据描述符有__get__方法， __get__方法一般最后会调用instance.__dict__[name]
        if hasattr(descriptor, '__get__'): 
            return descriptor.__get__(obj, cls)
        else:
            # 如果没有__get__方法,只能调用实例
            if name in obj.__dict__:
                return obj.__dict__[name]
            else:
                return descriptor
    # 实例属性
    if name in obj.__dict__:
        return obj.__dict__[name]            
    # 如果是普通描述符        
    if hasattr(descriptor, "__get__"):
        return descriptor.__get__(obj, cls)
    # 如果是普通类属性
    if descriptor is not None:
        return descriptor
    raise AttributeError(f"{cls.__name__} object has no attribute '{name}'")
```

你注意到的这个分支逻辑：
```python
        # 实例字典无值 → 返回描述符自身（原生逻辑）
        return descr
```
这里的场景确实比较隐晦。如果是普通的属性访问，拿回一个 `<__main__.Descriptor object ...>` 这种描述符对象，通常确实没什么用，甚至会导致后续代码报错。

但在 Python 的设计中，这一步**非常有意义**，主要对应的是 **“仅用于写入控制（Validation/Guard）”** 的场景，以及**内省（Introspection）** 的需求。

我们分两步来看：

### 1. 核心场景：为了实现“高效的验证器”

有些时候，我们定义描述符**只为了控制赋值（`__set__`）**，比如确保赋的值必须是整数。但是，为了读取性能，我们希望**读取时直接从 `__dict__` 读**，不要经过 `__get__` 方法的开销。

这就是 **“有 `__set__` 但无 `__get__`”** 的数据描述符。

#### 代码演示

```python
class IntegerField:
    # 只有 __set__，没有 __get__
    def __set__(self, instance, value):
        if not isinstance(value, int):
            raise TypeError("Must be integer")
        # 把值存入实例的 __dict__ 中，键名与属性名一致
        # 假设我们在类中定义时叫 'age'，这里就存入 instance.__dict__['age']
        instance.__dict__['age'] = value

class Person:
    age = IntegerField()

p = Person()
```

#### 场景 A：已经赋值之后（正常流程）
```python
p.age = 20  # 触发 IntegerField.__set__，将 20 存入 p.__dict__['age']

print(p.age) 
# 输出：20
# 原因：
# 1. 发现 age 是数据描述符 (有 __set__)
# 2. 发现 age 没有 __get__
# 3. 查 p.__dict__，发现有 'age': 20
# 4. 直接返回 20
```
这是这种模式最主要的目的：**写入时严查，读取时飞快（由 C 语言底层的字典查找直接搞定）。**

#### 场景 B：尚未赋值之前（你问的场景）
如果你实例化对象后，**还没有给它赋值**，直接读取，会发生什么？

```python
p = Person()
print(p.age)
# 输出：<__main__.IntegerField object at 0x...>
```

**这里的意义在于：**
1.  **标识“存在”而非“错误”**：这告诉开发者（或元编程工具），`Person` 类确实有一个叫 `age` 的属性定义（Schema），只是当前实例还没有具体的值。如果直接抛出 `AttributeError`，就好像这个类压根没定义过 `age` 一样。
2.  **提供默认值/元数据访问**：返回描述符对象本身后，你可以访问描述符上的其他属性。
    *   例如：ORM 框架（如 Django/SQLAlchemy）中，`User.name` 会返回一个字段对象（Descriptor），你可以通过它获取字段的元数据（如 `max_length`、`verbose_name`），用于生成表单或 SQL。

### 2. 类比理解

这其实和**方法（Method）**的逻辑是一致的，只是更“裸”一点。

想象一下普通的方法：
```python
class A:
    def func(self):
        pass

a = A()
print(a.func) 
# 输出：<bound method A.func of ...>
```
当你只“引用”而不“调用”时，Python 会把那个对象给你。

对于没有 `__get__` 的数据描述符：
*   如果实例里有值，它就把值给你（这是为了实用性做的优化）。
*   如果实例里没值，它就把描述符这个对象本身给你（这是为了逻辑的一致性：因为在类属性里确实能找到它）。

### 3. 总结

**“直接返回描述符”** 这个分支主要发生在：
**使用了“验证器模式”（只写不读的描述符），且该属性在实例中尚未初始化时。**

如果不返回描述符而是抛错，会导致我们无法通过 `hasattr(obj, 'age')` 来检查属性定义，也无法在 ORM 定义阶段获取字段信息。

这个脚本定义了三种不同的描述符，并演示了当它们与实例字典（`__dict__`）冲突时的不同行为。你可以直接运行这段代码。

### 测试代码 (`test_descriptors.py`)

```python
# 1. 定义三种典型的描述符

class DataDescriptor:
    """数据描述符：同时定义了 __get__ 和 __set__"""
    def __get__(self, instance, owner):
        return "【数据描述符】的值 (来自 __get__)"

    def __set__(self, instance, value):
        print(f"DataDescriptor __set__ 被调用，设置值为: {value}")
        instance.__dict__['_hidden_data'] = value

class NonDataDescriptor:
    """非数据描述符：只定义了 __get__ (通常是方法)"""
    def __get__(self, instance, owner):
        return "【非数据描述符】的值 (来自 __get__)"

class IntegerValidator:
    """特殊数据描述符：有 __set__ 但没有 __get__ (你的核心疑问场景)"""
    def __set__(self, instance, value):
        if not isinstance(value, int):
            raise ValueError("必须是整数")
        # 将值直接存入实例字典，模拟高效读取
        instance.__dict__['age'] = value

# 2. 定义测试类
class DemoClass:
    # 类属性定义
    data_attr = DataDescriptor()          # 场景 1
    method_attr = NonDataDescriptor()     # 场景 2
    age = IntegerValidator()              # 场景 3 (无 __get__ 的数据描述符)

    def __init__(self):
        # 初始化时，故意在实例字典里塞入同名数据，制造冲突！
        self.__dict__['data_attr'] = "【实例字典】里的恶意覆盖值"
        self.__dict__['method_attr'] = "【实例字典】里的覆盖值"

# ==========================================
# 开始测试
# ==========================================

obj = DemoClass()

print("-" * 50)
print("场景 1：数据描述符 vs 实例字典")
print(f"实例字典里有值吗？ {obj.__dict__['data_attr']}")
print(f"obj.data_attr 结果: {obj.data_attr}")
print("结论：数据描述符优先级 > 实例字典。") 
print("(即使字典里有值，Python 也会强行调用描述符的 __get__)")

print("-" * 50)
print("场景 2：非数据描述符 (方法) vs 实例字典")
print(f"实例字典里有值吗？ {obj.__dict__['method_attr']}")
print(f"obj.method_attr 结果: {obj.method_attr}")
print("结论：实例字典优先级 > 非数据描述符。")
print("(这允许我们在实例级别覆盖类的方法)")

print("-" * 50)
print("场景 3A：无 __get__ 的数据描述符 (未赋值前)")
# 这里对应你代码中的 `return descr` 分支
print(f"实例字典里有 'age' 吗？ {'age' in obj.__dict__}")
print(f"obj.age 结果: {obj.age}")
print("结论：字典没值且无 __get__ -> 返回描述符对象本身。")
print("(此时通过类型检查可知它是一个 IntegerValidator 对象)")

print("-" * 50)
print("场景 3B：无 __get__ 的数据描述符 (赋值后)")
obj.age = 18  # 触发 __set__，把 18 写入 obj.__dict__['age']
print(f"实例字典里有 'age' 吗？ {obj.__dict__['age']}")
print(f"obj.age 结果: {obj.age}")
print("结论：字典有值且无 __get__ -> 直接返回字典里的值。")
print("(这是为了性能优化的‘验证器模式’)")
```

### 运行结果与解析

当你运行上面的代码，你会看到如下输出（以及对应的原理解析）：

#### 场景 1：数据描述符的霸权
```text
场景 1：数据描述符 vs 实例字典
实例字典里有值吗？ 【实例字典】里的恶意覆盖值
obj.data_attr 结果: 【数据描述符】的值 (来自 __get__)
```
*   **对应你代码逻辑：** `if is_data_descriptor` 分支 -> `if hasattr(descr, '__get__')`。
*   **意义：** 即使我在 `__init__` 里强行写了 `self.__dict__['data_attr'] = ...`，访问属性时依然走了描述符。这就是为什么 `@property` 是安全的，无法被实例变量轻易覆盖。

#### 场景 2：非数据描述符的退让
```text
场景 2：非数据描述符 (方法) vs 实例字典
实例字典里有值吗？ 【实例字典】里的覆盖值
obj.method_attr 结果: 【实例字典】里的覆盖值
```
*   **对应你代码逻辑：** `if is_data_descriptor` 为 False -> 进入 `if name in obj.__dict__` -> 直接返回字典值。
*   **意义：** 这就是 Python 允许 Monkey Patch（猴子补丁）或者在该实例上重写方法的原理。

#### 场景 3A：无 `__get__` 且无值（返回描述符本身）
```text
场景 3A：无 __get__ 的数据描述符 (未赋值前)
实例字典里有 'age' 吗？ False
obj.age 结果: <__main__.IntegerValidator object at 0x...>
```
*   **对应你代码逻辑：**
    1.  `is_data_descriptor` 为 True (因为有 `__set__`)。
    2.  `hasattr(descr, '__get__')` 为 False。
    3.  `name in obj.__dict__` 为 False。
    4.  **`return descr` (返回描述符对象)**。
*   **意义：** 可以在类定义阶段或元编程阶段拿到这个 Validator 对象，查看它的配置（虽然在这个简单例子里看不出太多作用，但在 Django 字段定义中非常关键）。

#### 场景 3B：无 `__get__` 但有值（性能模式）
```text
场景 3B：无 __get__ 的数据描述符 (赋值后)
实例字典里有 'age' 18
obj.age 结果: 18
```
*   **对应你代码逻辑：**
    1.  `is_data_descriptor` 为 True。
    2.  `hasattr(descr, '__get__')` 为 False。
    3.  `name in obj.__dict__` 为 True (因为赋值过)。
    4.  **`return obj.__dict__[name]`**。
*   **意义：** 实现了“写时校验，读时极速”。读取 `obj.age` 时不需要调用任何 Python 方法，直接查哈希表，速度最快。
*   

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-descriptor)
