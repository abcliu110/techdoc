<div id="chap-Recursive Wildcard"></div>

[⬆️ 返回目录](#catalog)


## 递归通配符

`**` 在路径中通常被称为 **"递归通配符" (Recursive Wildcard)** 或 **"Globstar"**。

简单直接的回答：
1.  **它表示什么？** 它匹配**零级或多级目录**（即：递归匹配所有子目录）。
2.  **它是 Java 专有的吗？** **不是**。虽然它在 Java 生态系统（如 Spring、Maven、Ant）中非常常见，但它广泛应用于 Linux Shell、Git、JavaScript、Python 等多种技术栈中。

---

### 1. 它的具体含义（对比 `*`）

*   **单星号 `*`**：
    *   只匹配**当前层级**的文件或文件夹名称。
    *   例子：`/home/user/*.txt`
    *   匹配：`/home/user/a.txt`
    *   **不**匹配：`/home/user/docs/a.txt` （因为它不进入子目录）

*   **双星号 `**`**：
    *   匹配路径中的**任意层级目录**（包括零层）。
    *   例子：`/home/user/**/*.txt`
    *   匹配：`/home/user/a.txt` （匹配 0 层目录）
    *   匹配：`/home/user/docs/a.txt` （匹配 1 层子目录）
    *   匹配：`/home/user/docs/work/project/a.txt` （匹配多层子目录）

---

### 2. 为什么你会觉得它是 "Java 专有" 的？

这确实有一个历史渊源。这种 `**` 的写法最著名的推广者之一是 **Apache Ant** 构建工具（它是 Java 写的）。

*   **Ant-style Path Patterns（Ant 风格路径模式）**：
    在 Java 开发中（特别是 Spring 框架、Maven、Gradle），这种语法被称为“Ant 风格”。
    *   **Spring Security**: `.requestMatchers("/admin/**")` 表示 `/admin` 下的所有 URL。
    *   **Maven/Gradle**: `include '**/*.java'` 表示编译所有子文件夹里的 Java 文件。
    *   **Spring Boot 配置**: `classpath*:/mapper/**/*.xml`。

因为 Java 开发者每天都在用这些工具，所以很容易误以为这是 Java 语言本身的特性，但实际上这是这些**库/工具**定义的规则。

---

### 3. 其他非 Java 领域的应用

为了证明它不是 Java 专有，以下是它在其他地方的用法：

1.  **Git (`.gitignore`)**
    在 `.gitignore` 文件中，你可以写：
    ```text
    **/node_modules/
    ```
    这表示不管 `node_modules` 文件夹藏在项目的哪个深处，都要忽略它。

2.  **Linux Shell (Bash 4.0+, Zsh)**
    如果你使用的是 Zsh（Mac 默认终端）或者开启了 `globstar` 的 Bash：
    ```bash
    # 列出当前目录下所有的 .jpg 图片，无论它们藏多深
    ls **/*.jpg
    ```

3.  **JavaScript / Node.js**
    前端构建工具（如 Webpack, Gulp）和测试工具通常使用 `glob` 库：
    ```javascript
    // 匹配 src 目录下所有的 .js 文件
    gulp.src('src/**/*.js')
    ```

4.  **YAML (CI/CD)**
    GitHub Actions 或 GitLab CI 的路径触发规则：
    ```yaml
    paths:
      - "src/**"
    ```

### 总结
**`**` 是一个通用的路径匹配标准（Glob pattern 的扩展），用于表示“递归查找子目录”。** 它不是 Java 语言的语法，但在 Java 框架配置中非常流行。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-Recursive Wildcard)