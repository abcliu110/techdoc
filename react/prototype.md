<div id="chap-prototype"></div>

[⬆️ 返回目录](#catalog)

## 原型

简单直接的答案是：**`constructor` 属性定义在“原型（prototype）”上，但可以被“对象（实例）”访问。**

为了让你彻底理解，我们分三个层次来拆解：

### 1. 它是如何存储的？（证据）

当你定义一个函数（类）时，JavaScript 会自动为这个函数创建一个 `prototype` 对象，并在这个对象上添加一个 `constructor` 属性，指向函数本身。

**实例对象本身并没有这个属性。**

我们可以用代码证明：

```javascript
function Person() {}

const p = new Person();

// 1. 检查实例对象 p 自身是否有 constructor
console.log(p.hasOwnProperty("constructor")); // false

// 2. 检查原型对象 Person.prototype 自身是否有 constructor
console.log(Person.prototype.hasOwnProperty("constructor")); // true

// 3. 为什么 p.constructor 能拿到值？
console.log(p.constructor === Person); // true
```

**结论：** 当你访问 `p.constructor` 时，JS 引擎在 `p` 对象上找不到，于是顺着**原型链**去 `p.__proto__`（即 `Person.prototype`）上找，并在那里找到了它。

---

### 2. 为什么要放在原型上？

这和我们之前讨论“为什么方法要放原型上”的原因是一样的：**节省内存**。

- 无论你创建 10 个还是 1 万个 `Person` 实例，所有的实例都只需要通过原型链共享 **同一个** `constructor` 属性。
- 这个属性的作用是标识：“我是由哪个构造函数制造出来的？”

---

### 3. 一个非常重要的“坑”：手动改写原型

这是面试中经常考到的细节。如果你手动改写了某个类的 `prototype`，你会不小心把 `constructor` 给弄丢。

**错误示范：**

```javascript
function Dog() {}

// 手动覆盖原型
Dog.prototype = {
  bark: function () {
    console.log("汪");
  },
};

const d = new Dog();
console.log(d.constructor === Dog); // false (！出错了)
console.log(d.constructor === Object); // true  (！指向了最顶层的 Object)
```

**为什么？** 因为你给 `Dog.prototype` 赋值了一个全新的对象 `{}`。这个新对象是直接由 `Object` 创建的，它的原型链指向 `Object.prototype`，所以 `constructor` 也就指向了 `Object`。

**正确做法：**
如果你重写了原型，记得手动把 `constructor` 指回来：

```javascript
Dog.prototype = {
  constructor: Dog, // 手动修复
  bark: function () {
    console.log("汪");
  },
};
```

---

### 总结

- **物理位置**：在 **`prototype`（原型对象）** 上。
- **逻辑访问**：**对象（实例）** 可以通过原型链“借用”这个属性。
- **核心作用**：让实例能够知道自己是由哪个函数创建的，方便进行类型判断或再次创建相似对象。
  这是一个非常经典的问题。为了理解为什么要这么做，我们需要对比两种做法：一种是**把方法写在构造函数内部（给每个实例创建一份）**，另一种是**写在原型对象上（大家共用一份）**。

核心原因可以总结为三点：**内存效率、继承机制、动态更新**。

---

### 1. 内存效率（最主要的原因）

想象一下，如果你有一个 `User` 类，需要创建一个包含 10,000 个用户的数组。

#### 做法 A：放在构造函数内部

```javascript
function User(name) {
  this.name = name;
  this.sayHi = function () {
    // 每次 new，都会创建一个新的函数对象
    console.log("Hi, I am " + this.name);
  };
}

const users = [];
for (let i = 0; i < 10000; i++) {
  users.push(new User("User" + i));
}
```

- **结果**：内存中会存在 **10,000 个完全相同的 `sayHi` 函数对象**。每个实例都背着一个沉重的包，里面装着一模一样的代码。这会极大地浪费内存。

#### 做法 B：放在原型对象上

```javascript
function User(name) {
  this.name = name;
}
User.prototype.sayHi = function () {
  console.log("Hi, I am " + this.name);
};
```

- **结果**：内存中只存在 **1 个 `sayHi` 函数对象**。所有的 10,000 个实例都通过 `__proto__` 指向这同一个函数。就像社区里的公共健身房，大家共享，不需要每个人都在家里盖一个。

---

### 2. 实现“继承”的本质要求

JavaScript 的继承是基于 **原型链查找** 的。

- 如果方法写在**构造函数本身**（例如 `User.sayHi = ...`），这被称为“静态方法”。实例对象（`user1`）是**无法直接访问**它的，因为实例的 `__proto__` 链条指向的是 `User.prototype`，而不是 `User` 函数对象本身。
- 如果方法写在 **`prototype`** 上，实例在自己身上找不到 `sayHi` 时，就会顺着原型链向上爬，找到 `User.prototype.sayHi`。

**只有放在原型上，这个方法才能被“子类”继承。** 比如 `Student` 继承自 `User`，它也能直接用到 `User.prototype` 上的方法。

---

### 3. 动态更新（实时响应）

原型上的方法具有“实时性”。如果你在程序运行过程中修改了原型方法，所有已经创建的实例都会立刻同步更新。

```javascript
const user1 = new User("阿强");

// 突然想改掉所有人的打招呼方式
User.prototype.sayHi = function () {
  console.log("萨瓦迪卡，我是 " + this.name);
};

user1.sayHi(); // 即使是先创建的实例，也会输出：萨瓦迪卡...
```

如果方法是写在构造函数内部的，由于在创建实例时函数已经“拷贝”给了 `this`，你修改构造函数是无法影响到已经生成的旧实例的。

---

### 4. 什么时候该写在构造函数里？

虽然推荐把方法写在原型上，但有些东西**必须**写在构造函数里：

1.  **属性（Property）**：每个人的名字、年龄都不同，这些必须写在构造函数里，作为每个实例私有的数据。
2.  **私有变量（闭包）**：如果你想在函数内部定义一些外界无法访问的变量，只能在构造函数里通过闭包实现。
3.  **静态方法（Static Method）**：如果你想实现一个跟具体实例无关的方法（比如 `User.compare(u1, u2)`），你会把它直接挂在构造函数这个对象上。

---

### 总结对照表

| 存放位置                          | 内存占用                   | 访问权限               | 适用场景                       |
| :-------------------------------- | :------------------------- | :--------------------- | :----------------------------- |
| **构造函数内部 (`this.xxx`)**     | **高**（每个实例存一份）   | 实例私有               | 存储姓名、年龄等**个性化属性** |
| **构造函数原型 (`prototype`)**    | **低**（所有实例共用一份） | 实例共享               | 存储打招呼、运动等**公共方法** |
| **构造函数对象本身 (`User.xxx`)** | **低**（仅存一份）         | 类直接调用，实例不可调 | 存储工具函数（**静态方法**）   |

**一句话理解：** 属性（数据）各家自备，方法（技能）全村公用。这就是为什么要把方法放在 `prototype` 上。

这个问题问得非常深入，直击 JavaScript 语言设计的核心。

首先，我们需要纠正一个术语上的误区：**“普通对象没有原型”这句话是不准确的。**

在 JavaScript 中，**几乎所有对象都有原型**。你指的“没有原型”实际上是指：普通对象没有 **`prototype` 属性**。

为了理清这个逻辑，我们要区分两个概念：

1.  **`[[Prototype]]` (隐式原型)**：这是对象**寻找**属性的路径（即 `__proto__`）。**所有对象都有。**
2.  **`prototype` 属性 (显式原型)**：这是函数用来**存储**要传给子孙后代东西的“仓库”。**只有函数才有。**

以下是为什么只有函数才有 `prototype` 的深层原因：

---

### 1. 身份职责不同：生产者 vs 产品

JavaScript 的设计逻辑是模拟一种“生产线”关系：

- **函数（Function）是“生产者”**：它的职责是使用 `new` 关键字来“制造”对象。既然要制造对象，它就得有一份**“出厂配置单”**，告诉它制造出来的产品应该自带哪些共同技能。这份配置单就是 `prototype`。
- **普通对象（Object）是“产品”**：它是被制造出来的结果。它的职责是**使用**功能，而不是**定义**如何制造别人。所以它不需要 `prototype` 仓库，它只需要一个 `__proto__` 指针，指向生产它的那台机器的配置单即可。

**总结：** `prototype` 是为了给别人（实例）继承用的；普通对象不需要被别人继承，所以没必要带这个属性。

---

### 2. 内存效率的考量

想象一下，如果每一个普通对象都自带一个 `prototype` 属性：

1.  你创建了 10,000 个 `user` 对象。
2.  如果每个 `user` 都有 `prototype` 属性，那么内存中就会多出 10,000 个用于存储原型的空间。
3.  但实际上，这 10,000 个对象可能都指向同一个父类。

通过只让**构造函数**拥有 `prototype`，JavaScript 实现了一次定义、万次引用的极高效率。

---

### 3. `new` 关键字的工作原理（决定性因素）

`prototype` 存在的唯一目的，就是为了支持 `new` 操作符。当我们执行 `const obj = new Foo()` 时，底层发生了这几步：

1.  创建一个空对象 `{}`。
2.  **关键点**：将这个空对象的 `__proto__` 指向 `Foo.prototype`。
3.  执行构造函数，绑定 `this`。
4.  返回这个对象。

**如果没有 `prototype` 属性，`new` 命令就不知道该把新对象的“寻根路径”指向哪里。** 因为普通对象不能被 `new`，所以它们不需要这个属性。

---

### 4. 证据：并不是所有函数都有 `prototype`

这是一个很有力的反证：**箭头函数没有 `prototype`。**

```javascript
const Bark = () => {};
console.log(Bark.prototype); // undefined
```

**为什么？** 因为箭头函数在设计之初就决定了：**它不能作为构造函数（不能被 `new`）**。既然不能当“生产者”，它也就没必要带那个“出厂配置单”（`prototype`）了。

---

### 5. 如果我想让普通对象也当“模板”怎么办？

虽然普通对象没有 `prototype` 属性，但 JS 提供了 `Object.create()` 方法，让你直接用一个对象作为另一个对象的原型：

```javascript
const animal = { eat: true };
const dog = Object.create(animal); // 此时 dog.__proto__ === animal
```

在这种情况下，`animal` 充当了原型的角色，但它依然不需要 `prototype` 属性，因为它直接通过 `__proto__` 链条连接。

### 最终总结

- **`prototype`** 是**构造函数**特有的，它是为了给 `new` 出来的实例提供公共方法的**存储仓库**。
- **普通对象**没有 `prototype`，是因为它们是**原型链的末端或节点**，它们负责“使用”继承来的方法，而不负责“分发”方法。
- **所有对象都有原型（`__proto__`）**，这保证了无论你是函数还是普通对象，都能在原型链上找到自己的祖先。

这种“怪怪的感觉”非常正常，因为 JavaScript 的原型继承模型（Prototypal Inheritance）确实和我们人类直觉中的“父子关系”不太一样。

你之所以觉得它们是“同一层级”，是因为你可能在潜意识里把**构造函数（Constructor）**当成了“父亲”。但实际上，在 JS 的世界里，**原型对象（Prototype）才是真正的“父亲（或灵魂）”**，构造函数只是一个**“职业介绍人”**。

让我们用一个形象的比喻来打破这种“同一层级”的错觉：

### 1. 角色分工：工厂、图纸、产品

想象你在经营一家建筑公司：

- **构造函数 (Constructor)**：是**工厂（或者说施工队）**。它负责干活，负责把砖头（属性）垒起来。
- **原型 (Prototype)**：是**公共图纸（或者说公共设施管理处）**。它不干活，但它记录了所有房子通用的技能（比如：怎么排水、怎么用电）。
- **实例对象 (Instance)**：是**盖好的房子**。

#### 为什么你会觉得它们相等？

当你盖好一栋房子（实例）后，房子的“建筑标准链接”（`__proto__`）指向了那张“公共图纸”。而工厂（构造函数）手里也握着这张“公共图纸”（`prototype`）。

**关系图是这样的（三角形关系）：**

```text
    【工厂：构造函数】 ----------------> 【图纸：原型对象】
          |            (持有的属性)           ^
          |                                 |
          | (亲手盖出来)                      | (背后的连接)
          v                                 |
    【房子：实例对象】 -----------------------/
                    (指向它的来源)
```

### 2. 为什么它们不是“同一层级”？

虽然 `实例.__proto__ === 构造函数.prototype`，但它们的地位截然不同：

- **构造函数**是一个**函数**：它的使命是执行代码，初始化 `this`。一旦 `new` 完，它的活就干完了，它和实例之间就没有直接的联系了。
- **实例**是一个**个体**：它拥有属于自己的数据（比如墙的颜色、业主的姓名）。
- **原型**是一个**单例对象**：它是所有实例的“精神支柱”。只要原型不动，所有实例都能共享它的方法。

**所以，它们不是“平级”的，而是一个“闭环链接”：**
构造函数是**创造者**，原型是**资源池**，实例是**使用者**。

### 3. 这种设计的精妙（也是最奇怪）之处

在传统的 Java 或 C++ 中，类（Class）是真实的物理存在。但在 JS 中：
**根本没有“类”的概念，只有“对象”和“指向对象的指针”。**

你会发现：

1.  **构造函数**本身也是一个对象（函数对象）。
2.  **原型**本身也是一个对象。
3.  **实例**本身也是一个对象。

因为大家都是“对象”，所以 JS 引擎不需要为“类”单独开辟一套复杂的逻辑，只需要通过 **`__proto__` 指针**把这些对象串起来。这种“万物皆对象”的设计，确实会让初学者觉得大家好像都挤在同一层，没有高低贵贱。

### 4. 消除“怪异感”的一个思维实验

试着这么想：
**构造函数只是一个“临时工”。**

如果没有构造函数，我们依然可以实现继承：

```javascript
const 公共图纸 = { 排水: function () {} };
const 我的房子 = {};
Object.setPrototypeOf(我的房子, 公共图纸); // 直接手动连接
```

你看，这里根本没有构造函数什么事。

**结论：**
之所以引入构造函数，只是为了方便我们像 `new Person()` 这样**批量生产**对象，并自动帮我们把新房子的 `__proto__` 连到图纸上。

**不要把构造函数当成“父类”，要把原型对象当成“父类”。** 构造函数只是一个用来把实例和原型“撮合”到一起的**中间人**。这样想，那种“大家都在同一层”的怪异感就会消失了。

<!-- 跳转链接 -->

[⬆️ 返回目录](#catalog) | [文章开头 ➡️](#chap-prototype)
