
## 偏函数

一句话概括：**`partial` 是一个实现了 `__call__` 方法的类（Class），它像一个“容器”，在初始化时存下函数和参数，在调用时把存储的参数和新传入的参数合并，然后去执行原函数。**

我们可以通过三个层面来理解它的原理：

---

### 1. 核心逻辑：Python 模拟实现
`partial` 并不是一个神奇的黑魔法，它本质上就是下面这个 Python 类的样子：

```python
class MyPartial:
    def __init__(self, func, *args, **kwargs):
        self.func = func
        self.args = args
        self.kwargs = kwargs

    def __call__(self, *new_args, **new_kwargs):
        final_args = self.args + new_args
        final_kwargs = self.kwargs.copy()
        final_kwargs.update(new_kwargs)
        return self.func(*final_args, **final_kwargs)

```

**使用演示：**
```python
def add(a, b, c):
    return a + b + c


p = MyPartial(add, 2, 3)
print(p(4))
print(p(10))

```

---

### 2. 关键细节解析

#### A. 为什么是类而不是简单的闭包（Closure）？
虽然用函数闭包也能实现类似效果（比如 `lambda` 或嵌套函数），但 Python 选择用类来实现 `partial`，主要是为了提供**自省（Introspection）能力**。

当你创建一个偏函数 `p` 后，你可以访问它的属性来查看它“冻结”了什么：

```python
from functools import partial

def test(a, b, c): pass

p = partial(test, 1, c=3)

# 你可以查看内部状态
print(p.func)     # <function test at ...>
print(p.args)     # (1,)
print(p.keywords) # {'c': 3}
```
这在调试和编写装饰器时非常有用，因为它没有把原来的函数完全藏起来，你依然能把原来的东西取出来。

```python
from functools import partial

print(int("110", 2))
int2 = partial(int, base=2)
print(int2("110"))
print(int2("111"))

```

```python
from functools import partial
def log(level, message):
    print(f"[{level.upper()}] {message}")


# 快速生成不同级别的日志函数
info = partial(log, "info")
Warning = partial(log, "warning")
error = partial(log, "error")

info("This is an info message.")
Warning("This is a warning message.")
error("This is an error message.")
```

#### B. 参数合并规则（Merging Rules）
`partial` 的实现中，参数合并是非常严格的：
1.  **位置参数 (`*args`)**：`固定参数` 排在前面，`新参数` 排在后面。这意味着你只能固定“左边”的参数。
2.  **关键字参数 (`**kwargs`)**：`新参数` 会覆盖 `固定参数`。

这也是为什么说 `MethodType` 是 `partial` 的特例：
`MethodType` 实际上就是把实例 `obj` 放在了 `args` 的第一个位置（`self`），当你调用方法时，剩下的参数就接在 `self` 后面，完美符合 `final_args = self.args + new_args`。


在 Python 中，偏函数（Partial Function）主要通过标准库 `functools.partial` 来实现。

就像我们刚才讨论的，它的核心作用是 **“预先固定参数，简化函数调用”**。虽然用 `lambda` 也能做类似的事，但偏函数在某些场景下更清晰、更不容易出错。

以下是 Python 中偏函数的几个主要应用场景：

### 1. 简化函数签名（最经典的用法）
当某个函数的某些参数在一段代码逻辑中是固定的，使用偏函数可以创建一个“专用版本”的函数，使代码更具可读性。

**例子：进制转换**
Python 的 `int()` 函数默认按十进制转换，但它可以接收 `base` 参数。如果你需要频繁转换二进制字符串：

```python
from functools import partial

# 原始写法：每次都要写 base=2
print(int('1001', base=2))
print(int('1010', base=2))

# 偏函数写法：创建一个专门处理二进制的函数
int2 = partial(int, base=2)

print(int2('1001'))  # 9
print(int2('1010'))  # 10
```
**好处：** 隐藏了细节，`int2` 这个名字比 `int(..., base=2)` 更能表达意图。

---

### 2. 回调函数适配（GUI 编程与异步任务）
这是偏函数最实用的场景之一。
很多框架（如 `tkinter`, `Qt`, 或者异步任务队列）要求传入的回调函数（Callback）**不能带参数**，或者只能接受特定数量的参数。但你的业务逻辑往往需要额外的参数。

**例子：Tkinter 按钮事件**
假设你要创建 3 个按钮，分别打印不同的内容。

```python
import tkinter as tk
from functools import partial

def on_click(msg):
    print(f"Button clicked: {msg}")

root = tk.Tk()

# ❌ 错误写法：on_click("A") 会在创建时直接执行，而不是点击时执行
# btn = tk.Button(root, command=on_click("A")) 

# ✅ 偏函数写法：
# partial 返回的是一个函数对象，没有被执行，点击时才会触发，并自动带上 "A"
btn_a = tk.Button(root, text="A", command=partial(on_click, "A"))
btn_b = tk.Button(root, text="B", command=partial(on_click, "B"))

btn_a.pack()
btn_b.pack()
root.mainloop()
```

**为什么不用 Lambda？**
很多初学者会写 `command=lambda: on_click("A")`。虽然可行，但在循环中创建 lambda 往往会遇到 **“迟绑定（Late Binding）”** 的坑（所有 lambda 都指向循环变量的最后一个值），而 `partial` 是 **“早绑定（Early Binding）”**，参数在定义时就固定了，更安全。

---

### 3. 在数据处理管道中使用（配合 map/filter）
Python 的高阶函数如 `map`、`filter` 通常只接受单参数函数。如果你的处理函数需要多个参数，就必须用偏函数把它“降维”。

**例子：计算幂**
假设你有一个数字列表，想求它们的平方。

```python
from functools import partial

def power(base, exponent):
    return base ** exponent

numbers = [1, 2, 3, 4]

# map 需要一个只接收 base 的函数，所以我们固定 exponent=2
square = partial(power, exponent=2)
cube = partial(power, exponent=3)

# 这样就可以直接扔进 map 了
results = list(map(square, numbers)) 
print(results) # [1, 4, 9, 16]
```

---

### 4. 动态生成功能函数（模板化）
当你有一组结构相似的函数，但只有一点点配置不同时，可以用偏函数批量生成。

**例子：日志分级**
```python
from functools import partial

def log(level, message):
    print(f"[{level.upper()}] {message}")

# 快速生成不同级别的日志函数
info = partial(log, "info")
warn = partial(log, "warning")
error = partial(log, "error")

info("System starting...")  # 输出: [INFO] System starting...
error("Connection lost!")   # 输出: [ERROR] Connection lost!
```

---

### 5. 解决 Lambda 的“迟绑定”问题（进阶）
这是面试中常考的一个点。

**问题场景：**
```python
# 使用 Lambda
funcs = []
for i in range(3):
    # lambda x: x * i 这里的 i 是指向外部变量 i 的引用
    funcs.append(lambda x: x * i)

# 循环结束后，i 变成了 2
print(funcs[0](10)) # 期望 0，实际输出 20 (10 * 2)
print(funcs[2](10)) # 期望 20，实际输出 20 (10 * 2)
```

**使用 Partial 解决：**
`partial` 会在定义时就把参数值复制一份存下来。
```python
from functools import partial

funcs = []
for i in range(3):
    # 定义时，i 的当前值就被“冻结”进去了
    funcs.append(partial(lambda x, y: x * y, y=i))

print(funcs[0](10)) # 输出 0
print(funcs[2](10)) # 输出 20
```

### 总结

Python 中偏函数（`functools.partial`）主要用于：

1.  **接口适配**：把需要多个参数的函数，伪装成只需更少参数（或无参数）的函数，传给 `Button`、`map` 等调用方。
2.  **代码复用**：为通用函数提供特定配置的快捷方式（如 `int2`, `log_error`）。
3.  **快照参数**：在循环或动态生成中，锁住当前的变量值，避免作用域污染问题。