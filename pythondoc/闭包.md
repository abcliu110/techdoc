<div id="chap-descriptor"></div>

[⬆️ 返回目录](#catalog)

## 闭包

在 Python 的闭包实现机制中，**`cell` (单元对象)** 是核心中的核心，它是连接“外部函数作用域”与“内部函数”的物理桥梁。

除了 `cell`，要彻底理解闭包的底层原理，还有几个关键概念：**自由变量 (Free Variable)**、**`co_cellvars`**、**`co_freevars`** 以及 **`__closure__`**。

以下是这些概念的详细技术拆解：

---

### 1. 什么是 Cell 对象？

#### 本质
`cell` 是 Python 解释器（CPython）为了实现闭包而特意设计的一种**容器对象**。它存储在**堆内存（Heap）**中，而不是栈内存中。

#### 为什么要用 Cell？
通常情况下，函数执行时的局部变量存储在**栈帧（Stack Frame）**中。当函数执行完毕，栈帧销毁，局部变量也就随之消失了。

但是在闭包场景下：
1.  外部函数执行完了，栈帧要销毁。
2.  内部函数（闭包）以后还要运行，并且要访问外部函数的变量。

**冲突出现了**：内部函数想访问的变量，随着外部函数的退出本该“死掉”。

**解决方案（Cell 的作用）**：
Python 发现一个变量被闭包引用时，就不会把它仅仅放在栈里，而是创建一个 **Cell 对象** 放在堆里。
*   **外部函数**的局部变量指向这个 Cell。
*   **内部函数**（闭包）的 `__closure__` 属性也指向这个 Cell。
*   Cell 内部（`cell_contents`）才真正存着那个数据（比如整数 `10`）。

这样，即使外部函数销毁了，Cell 依然存在（引用计数不为 0），内部函数依然可以通过 Cell 找到那个值。

---

### 2. 闭包相关的“其他概念”

要看懂 Python 也是怎么识别和编译闭包的，你需要关注以下几个概念，它们存在于函数的 **Code Object (`__code__`)** 中：

#### A. 自由变量 (Free Variable)
*   **定义**：在代码块中使用，但不是在本地定义的，也不是全局变量的变量。
*   **通俗理解**：就是内部函数里用到、定义在外部函数里的那个变量。

#### B. `co_cellvars` (Cell Variables)
*   **位置**：存在于 **外部函数** 的 `__code__` 中。
*   **含义**：编译器分析外部函数代码时，发现哪些局部变量被内部函数引用了，就会把这些变量名放入 `co_cellvars` 元组中。
*   **作用**：告诉解释器，“在这个函数运行时，这几个变量别只放栈里，要给它们创建 Cell 对象”。

#### C. `co_freevars` (Free Variables)
*   **位置**：存在于 **内部函数** 的 `__code__` 中。
*   **含义**：编译器分析内部函数代码时，发现引用了外部的变量，就把这些变量名放入 `co_freevars` 元组中。
*   **作用**：告诉解释器，“运行这个函数时，如果用到这几个变量，去 `__closure__` 里的 Cell 找，别在本地找”。

#### D. `__closure__`
*   **位置**：存在于 **函数对象**（运行时）上。
*   **含义**：这是一个包含 Cell 对象的**元组**。它直接对应 `co_freevars` 中的变量顺序。

---

### 3. 深度透视：代码与内存结构

让我们通过代码自省（Introspection）把这些概念串起来：

```python
def outer():
    x = 100    # 被引用，将变成 Cell
    y = 200    # 未被引用，只是普通局部变量

    def inner():
        # x 是自由变量，引用了外部的 x
        return x + 1

    return inner

# 1. 分析外部函数 (编译阶段)
print("External - co_cellvars:", outer.__code__.co_cellvars) 
# 输出: ('x',) 
# 解释: 编译器发现 x 被里面用了，y 没被用。所以 x 是 cellvar。

# 2. 运行外部函数，获取闭包
closure_func = outer()

# 3. 分析内部函数 (编译阶段)
print("Internal - co_freevars:", closure_func.__code__.co_freevars)
# 输出: ('x',)
# 解释: 编译器发现 inner 用到了外面的 x。

# 4. 分析运行时结构 (运行阶段)
print("Closure Storage:", closure_func.__closure__)
# 输出: (<cell at 0x...: int object at 0x...>,)
# 解释: 这是一个元组，里面存了一个 Cell 对象。

# 5. 查看 Cell 里的内容
cell = closure_func.__closure__[0]
print("Cell Contents:", cell.cell_contents)
# 输出: 100
```

### 4. 总结：闭包的生命周期逻辑

这些概念是如何协作的：

1.  **编译期**：
    *   Python 编译 `outer`，发现 `x` 被嵌套函数用了。于是把 `"x"` 标记在 `outer.co_cellvars` 里。
    *   Python 编译 `inner`，发现 `x` 来自外面。于是把 `"x"` 标记在 `inner.co_freevars` 里。

2.  **运行期 (调用 `outer` 时)**：
    *   `outer` 开始执行。
    *   遇到变量 `x`，解释器看到它在 `co_cellvars` 里，于是创建一个 **Cell 对象**，把 `100` 放进去。
    *   定义 `inner` 函数时，解释器把刚才创建的那个 Cell 对象，打包塞给 `inner` 函数对象的 `__closure__` 属性。

3.  **运行期 (调用 `inner` 时)**：
    *   `inner` 开始执行。
    *   遇到代码 `return x + 1`。
    *   解释器查 `co_freevars` 发现 `x` 是自由变量。
    *   解释器去 `__closure__[0]` 里取出那个 Cell 对象，再从 Cell 里取出 `100`。
    *   计算 `100 + 1`。

### 一图胜千言（逻辑图）

```text
Stack Frame (Outer)      Heap Memory              Function Object (Inner)
+-----------------+      +------------+          +---------------------+
| local var "x"   | ---> | Cell Object| <------- | __closure__[0]      |
| (Reference)     |      | value: 100 |          +---------------------+
+-----------------+      +------------+          | code.co_freevars:   |
        |                                        | ('x',)              |
(Outer return后销毁)                              +---------------------+
        X
(但是 Cell 在堆里，
 被 Inner 引用着，
 所以不死)
```

这就是 Python 闭包实现的全部技术细节。


<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-closure)