<div id="chap-member-descriptor"></div>

[⬆️ 返回目录](#catalog)

## 成员描述符

`MemberDescriptor`（成员描述符）是 Python 能够实现高性能 `__slots__` 和内置类型（如 `datetime`、`array` 等）属性访问的核心机制。

它的核心秘密可以用一句话概括：**它把“查字典（Hash Lookups）”变成了“算地址（Pointer Arithmetic）”。**

### 关键特性总结

#### A. 为什么它是数据描述符？
`MemberDescriptor` 实现了 `__set__`。这是必须的。
虽然定义了 `__slots__` 的类通常没有 `__dict__`，但如果它的子类没有定义 `__slots__`，子类就会有 `__dict__`。
为了防止子类在 `__dict__` 里存一个同名属性从而导致混乱，`MemberDescriptor` 必须是**数据描述符**，以确保它的优先级高于 `__dict__`。

#### B. 速度与内存
1.  **速度快**：指针加法（O(1)）远快于哈希查找（虽也是 O(1) 但常数大且有冲突处理）。
2.  **省内存**：不需要维护哈希表（通常哈希表需要预留 1/3 的空位来减少冲突），也不需要存 key 的字符串引用。

#### C. 类型限制
因为 `offset` 是固定的，所以 `__slots__` 定义的结构是静态的。你不能像普通对象那样随意动态增加新属性（除非子类有 `__dict__`）。

#### D. 什么时候会遇到它？

除了 `__slots__`，Python 的大量内置类型属性都是由 `MemberDescriptor` 实现的。

```python
class MemberDescriptor:
    def __init__(self, name, offset):
        self.name = name
        self.offset = offset

    def __get__(self, instance, owner):
        if instance is None:
            return self
        value = instance._data[self.offset]
        if value is None:
            raise AttributeError(f"Attribute '{self.name}' is not set.")
        return value

    def __set__(self, instance, value):
        instance._data[self.offset] = value
        
class Celsius:
    colour = MemberDescriptor("temperature", 0)
    radius = MemberDescriptor("radius", 1)
    
    def __init__(self, temperature=0):
        self._data = [None, None]  # 使用列表存储属性值
        self.temperature = temperature

c = Celsius(25)
c.radius = 5
c.colour = 30
print(c.colour)  # 输出: 25
```


<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-member-descriptor)