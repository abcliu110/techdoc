<div id="chap-common-descriptor"></div>

[⬆️ 返回目录](#catalog)

## 常用描述符

常用的描述符实现主要分为三类，它们分别利用了 Python 属性查找顺序中的不同“特权”位置：

1.  **缓存属性 (`@CachedProperty`)**：利用“非数据描述符优先级**低**”的特性。
2.  **强校验字段 (`TypedField`)**：利用“数据描述符优先级**高**”的特性。
3.  **属性访问控制 (`@Property`)**：模拟原生 property，完全接管读写。

下面是这三种经典场景的纯 Python 实现：

---

### 1. 缓存属性 (`CachedProperty`)
**核心原理**：这是一个**非数据描述符**（只有 `__get__`）。
一旦第一次计算出结果，就把它塞入实例的 `__dict__` 中。第二次访问时，因为实例字典优先级高于非数据描述符，Python 会直接取字典里的值，不再调用 `__get__`。

```python
class CachedProperty:
    def __init__(self, func):
        self.__func__ = func
        self.__name__ = func.__name__
        self.__doc__ = func.__doc__
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        print(f"正在计算 {self.__name__} ...")
        value = self.__func__(instance)
        # 第一次当实例的字典中没有self.__name__时， 会去调用普通描述符的__get__方法, 这里执行函数并且在实例中缓存值。实例中有值就不会去再次去查普通描述符 
        instance.__dict__[self.__name__] = value
        return value
                

class NetworkModel:
    def __init__(self, url):
        self.url = url

    @CachedProperty
    def content(self):
        # 模拟耗时操作
        return f"Response from {self.url}"     

print(NetworkModel.__dict__)
model = NetworkModel("http://google.com")

print("第一次访问:")
print(model.content)  # 会打印 "正在计算..."

print("\n第二次访问:")
print(model.content)  # 直接返回结果，不会打印 "正在计算..."     

model.__dict__.pop("content") #删除缓存, 必须会重新获取
print(model.content)    


```

cached_property应用实例

```python
from functools import cached_property
class RoomService:
    @cached_property
    def rooms(self):        
        print(f"从数据库中获取所有的房间信息")
        result_list = ["A", "B"]
        return result_list


rs = RoomService()
# 方法变成属性，并且在实例中缓存方法的执行的结果 instance.__dict__["func"] = fun(instance)方法运行的结果
print(rs.rooms)
print(rs.rooms)
```

### 2. 强类型/范围校验字段 (`IntField`)
**核心原理**：这是一个**数据描述符**（有 `__set__`）。
即使实例字典里有值，Python 也会强制调用 `__set__`，让我们有机会做拦截校验。此外使用了 `__set_name__` (Python 3.6+) 自动获取变量名。
```python

class IntegerField:
    def __init__(self, min_value, max_value):
        self.__min__ = min_value
        self.__max__ = max_value
    def __set_name__(self, owner, name):
        self.__name__ = name
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.__name__)
    
    def __set__(self, instance, value):
        if not isinstance(value, int):
            raise TypeError(f"类型必须为int")
        if value < self.__min__:
            raise ValueError(f"{self.__name__}不能小于{self.__min__}")
        if value > self.__max__:
            raise ValueError(f"{self.__name__}不能大于{self.__max__}")
        instance.__dict__[self.__name__] = value
    
class User:
    age = IntegerField(1, 100)

u = User()
u.age = 80  
print(u.age)
u.age = 101   
print(u.age)
        

```

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-common-descriptor)
