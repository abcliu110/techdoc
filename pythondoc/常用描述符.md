<div id="chap-common-descriptor"></div>

[⬆️ 返回目录](#catalog)

## 常用描述符

常用的描述符实现主要分为三类，它们分别利用了 Python 属性查找顺序中的不同“特权”位置：

1.  **缓存属性 (`@CachedProperty`)**：利用“非数据描述符优先级**低**”的特性。
2.  **强校验字段 (`TypedField`)**：利用“数据描述符优先级**高**”的特性。
3.  **属性访问控制 (`@Property`)**：模拟原生 property，完全接管读写。

下面是这三种经典场景的纯 Python 实现：

---

### 1. 缓存属性 (`CachedProperty`)
**核心原理**：这是一个**非数据描述符**（只有 `__get__`）。
一旦第一次计算出结果，就把它塞入实例的 `__dict__` 中。第二次访问时，因为实例字典优先级高于非数据描述符，Python 会直接取字典里的值，不再调用 `__get__`。

```python
class CachedProperty:
    def __init__(self, func):
        self.__func__ = func
        self.__name__ = func.__name__
        self.__doc__ = func.__doc__
    
    def __get__(self, instance, owner):
        if instance is None:
            return self
        print(f"正在计算 {self.__name__} ...")
        value = self.__func__(instance)
        # 第一次当实例的字典中没有self.__name__时， 会去调用普通描述符的__get__方法, 这里执行函数并且在实例中缓存值。实例中有值就不会去再次去查普通描述符 
        instance.__dict__[self.__name__] = value
        return value
                

class NetworkModel:
    def __init__(self, url):
        self.url = url

    @CachedProperty
    def content(self):
        # 模拟耗时操作
        return f"Response from {self.url}"     

print(NetworkModel.__dict__)
model = NetworkModel("http://google.com")

print("第一次访问:")
print(model.content)  # 会打印 "正在计算..."

print("\n第二次访问:")
print(model.content)  # 直接返回结果，不会打印 "正在计算..."     

model.__dict__.pop("content") #删除缓存, 必须会重新获取
print(model.content)    


```

cached_property应用实例

```python
from functools import cached_property
class RoomService:
    @cached_property
    def rooms(self):        
        print(f"从数据库中获取所有的房间信息")
        result_list = ["A", "B"]
        return result_list


rs = RoomService()
# 方法变成属性，并且在实例中缓存方法的执行的结果 instance.__dict__["func"] = fun(instance)方法运行的结果
print(rs.rooms)
print(rs.rooms)
```

### 2. 强类型/范围校验字段 (`IntField`)
**核心原理**：这是一个**数据描述符**（有 `__set__`）。
即使实例字典里有值，Python 也会强制调用 `__set__`，让我们有机会做拦截校验。此外使用了 `__set_name__` (Python 3.6+) 自动获取变量名。
```python

class IntegerField:
    def __init__(self, min_value, max_value):
        self.__min__ = min_value
        self.__max__ = max_value
    def __set_name__(self, owner, name):
        self.__name__ = name
    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__.get(self.__name__)
    
    def __set__(self, instance, value):
        if not isinstance(value, int):
            raise TypeError(f"类型必须为int")
        if value < self.__min__:
            raise ValueError(f"{self.__name__}不能小于{self.__min__}")
        if value > self.__max__:
            raise ValueError(f"{self.__name__}不能大于{self.__max__}")
        instance.__dict__[self.__name__] = value
    
class User:
    age = IntegerField(1, 100)

u = User()
u.age = 80  
print(u.age)
u.age = 101   
print(u.age)
        

```

### 3. 模拟原生 `@property`
**核心原理**：这是一个完全的**数据描述符**。
它需要同时支持装饰器语法（`@prop.setter`）来注册 getter 和 setter 函数。

```python
class MockProperty:
    def __init__(self, fget=None, fset=None, fdelete=None):
        self.fget = fget
        self.fset = fset
        self.fdelete = fdelete

    def __get__(self, instance, owner):
        if instance is None:
            return self
        if self.fget is None:
            raise AttributeError(f"unreachable attribute!!!")
        return self.fget(instance)

    def __set__(self, instance, value):
        if self.fset is None:
            raise AttributeError(f"can't set attribute!!!")
        self.fset(instance, value)

    def __delete__(self, instance):
        if self.fdelete is None:
            raise AttributeError(f"can't delete attribute!!!")
        self.fdelete(instance)

    def setter(self, fset):
        return type(self)(self.fget, fset, self.fdelete)

    def deleter(self, fdelete):
        return type(self)(self.fget, self.fset, fdelete)


class Circle:
    def __init__(self, radius):
        self._radius = radius

    @MockProperty
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        if value < 0:
            raise ValueError(f"radius must be non-negative")
        self._radius = value

    @radius.deleter
    def radius(self):
        del self._radius


c = Circle(5)
print(c.radius)  # 调用 __get__
c.radius = 10
print(c.radius)  # 调用 __get__
del c.radius
print(c.radius)  # 抛出 AttributeError
```
### 4. `staticmethod`

在 Python 中，普通的类方法在被实例调用时，会自动绑定（Binding），将实例本身作为第一个参数 (`self`) 传进去。

而 `staticmethod` 的作用就是**阻止这种绑定**。无论你通过类访问，还是通过实例访问，它都原封不动地返回那个函数，不夹带任何 `self` 或 `cls`。


```python
class MyStatic:
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        return self.func


class Test:
    def Hello(self):
        return "Hello, World!"

    @MyStatic
    def greet():
        return "Hello, World!"


t = Test()
print(t.greet())
print(Test.greet())
print(t.Hello())

# Exception has occurred: TypeError
# Test.Hello() missing 1 required positional argument: 'self'
#     print(Test.Hello())
#           ~~~~~~~~~~^^
# TypeError: Test.Hello() missing 1 required positional argument: 'self'

print(Test.Hello())
```


```python
class MyStatic:
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        return self.func


class ClassMethod:
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        def bound_method(*args, **kwargs):
            return self.func(owner, *args, **kwargs)

        return bound_method


class Test:
    def Hello(self):
        return "Hello, World!"

    @ClassMethod
    def welcome(cls):
        return "Hello, World!"

    @MyStatic
    def greet():
        return "Hello, World!"

    def direct_function():
        print("[DirectFunction] I am just a function inside a class namespace.")


t = Test()
# 普通描述符，类和实例都可以调用
print(t.greet())
print(Test.greet())

# 实例方法，只能通过实例
print(t.Hello())
# 或者类.func(实例)来调用
print(Test.Hello(t))
```

在 Python 中，使用 `@classmethod` 装饰器定义的方法与直接通过类名访问方法（通常指直接在类中定义一个不带 `self` 的普通函数，或者直接调用实例方法）有本质的区别。

主要区别在于 **“谁被作为第一个参数传入”** 以及 **“继承时的多态行为”**。

以下是详细的对比分析：

### 1. 核心机制区别

#### A. `@classmethod` (类方法)
*   **绑定行为**：方法被绑定到**类**上，而不是实例。
*   **参数传递**：调用时，Python 会**自动**将当前的类（Class）作为第一个参数传入，通常约定命名为 `cls`。
*   **调用方式**：既可以用 `类名.方法()` 调用，也可以用 `实例.方法()` 调用。

#### B. 类直接访问普通函数 (不带 `self` 和装饰器)
*   **绑定行为**：在 Python 3 中，这仅仅是一个定义在类命名空间下的**普通函数**。
*   **参数传递**：调用时，**没有任何参数**会被自动传入。
*   **调用方式**：只能用 `类名.方法()` 调用。如果用 `实例.方法()` 调用会报错（因为 Python 会试图把实例作为第一个参数传入，导致参数数量不匹配）。

#### C. 类直接访问实例方法 (带 `self`)
*   **行为**：这相当于手动调用函数。
*   **参数传递**：必须**手动**传递一个实例作为第一个参数。
*   **场景**：`MyClass.method(instance_obj)`。

---

### 2. 代码对比演示

为了清晰说明，我们对比 `@classmethod` 和“直接在类里写的普通函数（伪静态方法）”。

```python
class Demo:
    name = "Base Class"

    # 情况 1: @classmethod
    @classmethod
    def class_method(cls):
        print(f"[ClassMethod] Current class is: {cls.__name__}, Name: {cls.name}")

    # 情况 2: 类中直接定义的普通函数 (无 self, 无装饰器)
    def direct_function():
        print("[DirectFunction] I am just a function inside a class namespace.")

# --- 1. 基本调用 ---
Demo.class_method()    
# 输出: [ClassMethod] Current class is: Demo, Name: Base Class
# 说明: 自动传入了 Demo 类给 cls

Demo.direct_function() 
# 输出: [DirectFunction] I am just a function inside a class namespace.
# 说明: 正常运行，就像调用普通函数一样

# --- 2. 实例调用的区别 ---
obj = Demo()

obj.class_method()     
# 成功: 输出同上。即便通过实例调用，传入的依然是类对象。

# obj.direct_function() 
# 报错: TypeError: direct_function() takes 0 positional arguments but 1 was given
# 原因: 通过实例调用时，Python 强制把 obj 传进去，但函数没定义参数接收。
```

### 3. 最大的区别：继承 (Inheritance)

这是使用 `@classmethod` 最重要的原因。

*   **`@classmethod` 是多态的**：如果你在一个子类上调用该方法，`cls` 参数会变成**子类**。
*   **直接访问方法是硬编码的**：普通函数无法感知它是被哪个类调用的。

```python
class Parent:
    data = "Parent Data"

    @classmethod
    def get_info_cm(cls):
        # cls 会根据调用者变化
        return cls.data

    def get_info_direct():
        # 这里很难获取是哪个子类在调用，通常只能硬编码 Parent.data
        return Parent.data

class Child(Parent):
    data = "Child Data"

# --- 测试继承行为 ---

print(Parent.get_info_cm())      # 输出: Parent Data
print(Child.get_info_cm())       # 输出: Child Data  <-- 关键！自动指向了子类数据

print(Parent.get_info_direct())  # 输出: Parent Data
print(Child.get_info_direct())   # 输出: Parent Data <-- 也就是没法根据子类改变行为
```

### 4. 总结表

| 特性 | `@classmethod` | 类直接访问普通函数 (无装饰器) |
| :--- | :--- | :--- |
| **第一个参数** | 自动传入当前**类对象** (`cls`) | 不传入任何参数 |
| **通过实例调用** | ✅ 支持 (传入该实例所属的类) | ❌ 报错 (参数不匹配) |
| **继承行为** | **多态** (子类调用时 `cls` 为子类) | **静态** (无法感知子类，通常写死父类名) |
| **主要用途** | 工厂模式、操作类属性、多态构造函数 | 仅当做命名空间使用 (不推荐，建议用 `@staticmethod`) |

### 5.什么时候该用哪个？

1.  **必须使用 `@classmethod` 的场景**：
    *   你需要访问类的属性（如 `cls.variable`）。
    *   你需要实现**工厂模式**（例如 `cls()` 来创建一个当前类的实例，且支持子类继承）。
    *   你需要根据调用的类不同而执行不同的逻辑（多态）。

2.  **可以直接访问（但建议用 `@staticmethod`）的场景**：
    *   如果一个方法既不需要 `self` (实例)，也不需要 `cls` (类)，它只是恰好逻辑上属于这个类。
    *   **注意**：在 Python 中，不要直接在类里写“裸”函数。如果你不需要 `cls` 也不需要 `self`，请加上 **`@staticmethod`** 装饰器。这样既可以通过类调用，也可以通过实例调用，且代码意图更清晰。

### 6.补充：为什么不直接写 `def method():` 而要用 `@staticmethod`？
虽然 `Class.method()` 可以运行，但它破坏了通过实例调用 (`instance.method()`) 的能力。为了接口的一致性，Python 提供了 `@staticmethod`，让方法既能被类调用，也能被实例调用，且不强制传入第一参数。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-common-descriptor)