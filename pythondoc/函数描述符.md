<div id="chap-function-descriptor"></div>

[⬆️ 返回目录](#catalog)

## 函数描述符

1. `MethodType`（在 Python 中通常表现为 `types.MethodType`，即**绑定方法**对象）的实现原理其实非常直观。它的核心本质是一个**闭包（Closure）**或者说是一个**部分应用（Partial Application）**的包装器。

它存在的唯一目的就是：**把“实例（self）”和“函数”打包在一起，并在调用时自动把实例塞给函数。**

2. 动态绑定过程（JIT Binding）

方法绑定不是在类定义时发生的，而是在**你通过点号访问属性时（Runtime）动态发生的**。

3. 为什么是“非数据”描述符？

因为函数对象**没有实现 `__set__`**。

这就赋予了方法一个极其重要的特性：**它可以被实例属性覆盖（Shadowing）**。这正是我们能在运行时修改某个特定实例的行为（Monkey Patching）的基础。

### 总结

1.  **本质**：所有 Python 函数（`def` 定义的）天然都是描述符，因为它们实现了 `__get__`。
2.  **绑定机制**：`__get__` 根据调用方式（类调用 vs 实例调用）决定是返回原函数，还是返回一个包含 `self` 的 `MethodType` 对象。
3.  **非数据特性**：因为函数没有 `__set__`，所以它们是非数据描述符。这允许我们在实例级别通过直接赋值 `obj.method = ...` 来覆盖类定义的方法，提供了极大的灵活性。

```python
class MyMethodType:
    def __init__(self, func, instance):
        self.func = func
        self.instance = instance

    def __call__(self, *args, **kwargs):
        return self.func(self.instance, *args, **kwargs)

    def __repr__(self):
        cls_name = self.instance.__class__.__name__
        addr = hex(id(self.instance))
        return f"<bound method {cls_name}.{self.func.__name__} of {cls_name} object at {addr}>"


class Function:
    def __init__(self, func):
        self.func = func
        self.__name__ = func.__name__
        self.__doc__ = func.__doc__

    def __get__(self, instance, owner):
        # 通过类访问
        if instance is None:
            return self
        # 通过实例访问
        return MyMethodType(self.func, instance)


class Person:
    def __init__(self, name):
        self.name = name

    @Function
    def greet(self):
        """
        这是一个问候方法
        """
        return f"Hello, my name is {self.name}"


p = Person("Alice")
print(p.greet)
print(Person.greet)  # 通过类访问
print(p.greet())  # 通过实例访问
```

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-function-descriptor)

