<div id="chap-generator"></div>

[⬆️ 返回目录](#catalog)


## 生成器


Python 生成器的原理可以从**宏观的语法行为**和**微观的底层实现**两个层面来理解。

简单来说，生成器的核心原理是：**函数栈帧（Stack Frame）的挂起与恢复**。

下面深入剖析它的工作机制：

---

### 1. 核心概念：栈帧（Stack Frame）

要理解生成器，首先要理解 Python 函数是如何执行的。

*   **普通函数**：当调用一个普通函数时，Python 会在内存栈上创建一个“栈帧”用来保存变量、参数和代码执行位置。当函数 `return` 时，这个栈帧会被**销毁**，所有的局部变量都会消失。
*   **生成器函数**：当 Python 编译器发现函数中有 `yield` 关键字时，它会给这个函数打上标记（`CO_GENERATOR`）。当调用这个函数时，它**不会立即执行代码**，而是返回一个**生成器对象（Generator Object）**。

### 2. 底层原理：从“销毁”到“封存”

生成器的魔法在于它改变了栈帧的生命周期。

#### A. 栈帧并未在堆栈中销毁
生成器对象的底层结构（在 CPython 中是 `PyGenObject`）会持有一个对该函数**栈帧（PyFrameObject）的引用**。

*   **普通函数**：调用 -> 创建栈帧 -> 运行 -> 返回 -> **销毁栈帧**。
*   **生成器**：调用 -> 创建栈帧 -> **封存栈帧**（保存在堆内存中） -> 返回生成器对象。

#### B. `yield` 的作用：挂起（Suspend）
当你调用 `next(gen)` 时：
1.  Python 找到生成器对象保存的栈帧。
2.  **恢复（Resume）**：将栈帧“激活”，从上次停止的指令位置（`f_lasti`）继续执行。
3.  **执行**：代码运行直到遇到 `yield` 语句。
4.  **挂起（Suspend）**：
    *   计算 `yield` 后面的值。
    *   **保存现场**：保存当前的指令指针（表明运行到了哪里）和所有的局部变量状态。
    *   将控制权交还给调用者，并返回产出的值。
5.  栈帧依然存在于内存中，只是处于“暂停”状态。

### 3. 字节码层面的视角

我们可以看一个简单的例子和它的字节码：

```python
def my_gen():
    yield 1
    yield 2

import dis
dis.dis(my_gen)
```

**关键字节码指令：`YIELD_VALUE`**

输出的大致逻辑如下：
1.  `LOAD_CONST 1` (加载数字 1)
2.  **`YIELD_VALUE`**
    *   这条指令是生成器的灵魂。它告诉解释器：**“把栈顶的值弹出来返回给调用者，然后把当前的栈帧状态冻结住，不要销毁我。”**
3.  `POP_TOP` (下次回来时，从这里继续)
4.  `LOAD_CONST 2` (加载数字 2)
5.  `YIELD_VALUE`
...

### 4. 迭代器协议的实现

生成器之所以能用于 `for` 循环，是因为它自动实现了**迭代器协议**：

1.  **`__iter__` 方法**：返回生成器自己（`return self`）。
2.  **`__next__` 方法**：
    *   这是 `next(g)` 背后的实际调用。
    *   它负责触发上述的“恢复栈帧 -> 运行 -> 挂起栈帧”的过程。
    *   如果函数执行完毕（没有更多的 `yield`，或者遇到 `return`），它会抛出 `StopIteration` 异常，告诉 `for` 循环结束了。

### 5. 总结：生成器对象结构

在 CPython 源码中，生成器对象（`PyGenObject`）大致包含以下关键信息：

*   **`gi_frame`**：指向该生成器当前拥有的栈帧（里面存了局部变量 `a=1` 等）。
*   **`gi_code`**：指向编译后的字节码（即函数的 `__code__`）。
*   **`gi_running`**：一个标志位，防止生成器在多线程或递归中被非法重入。

### 比喻

*   **普通函数**就像你做一张试卷，做完（Return）就交卷了，试卷（栈帧）被扔进碎纸机。
*   **生成器**就像你读一本小说：
    *   你读了一会儿，累了，放一个**书签**（Yield）。
    *   你合上书去做别的事（控制权交还）。
    *   下次你想读时（Next），你拿起书，翻到书签的那一页，从**上一行结束的地方**继续读。
    *   书（栈帧）一直保留在桌子上，直到你读完或把它扔掉。

### 为什么使用它？
理解了原理，就知道它的优势：
1.  **省内存**：不需要一次性构建巨大的列表，因为栈帧里只存当前的状态，用完即走。
2.  **惰性求值**：只有你需要下一个值时，它才计算，非常适合处理无限数据流。

```python
CODE_RANGE = [
    ("LOAD_CONST", 0),
    ("STORE_FAST", "init"),
    ("LOAD_CONST", 100),
    ("STORE_FAST", "limit"),
    ("LOAD_CONST", 2),
    ("STORE_FAST", "step"),
    # 初始化变量
    ("LOAD_FAST", "init"),
    ("STORE_FAST", "i"),
    # 循环开始 LOOP_START
    ("LOAD_FAST", "i"),
    ("LOAD_FAST", "limit"),
    ("COMPARE_LE", None),
    ("JUMP_IF_FALSE", 16),
    ("LOAD_FAST", "i"),
    ("YIELD_VALUE", None),
    ("LOAD_FAST", "i"),
    ("LOAD_FAST", "step"),
    ("ADD", None),
    ("STORE_FAST", "i"),
    ("JUMP", 8),
    # 循环结束 LOOP_END
]


class Generator:
    def __init__(self, code):
        self.code = code
        self.stack = []
        self.locals = {}
        self.ip = 0

    def __iter__(self, *args):
        return self

    def __next__(self):
        while self.ip < len(self.code):
            cmd, arg = self.code[self.ip]
            if cmd == "LOAD_CONST":
                self.stack.append(arg)
            elif cmd == "STORE_FAST":
                self.locals[arg] = self.stack.pop()
            elif cmd == "LOAD_FAST":
                self.stack.append(self.locals[arg])
            elif cmd == "COMPARE_LE":
                right = self.stack.pop()
                left = self.stack.pop()
                self.stack.append(left <= right)
            elif cmd == "JUMP_IF_FALSE":
                condition = self.stack.pop()
                if not condition:
                    self.ip = arg
                    continue
            elif cmd == "YIELD_VALUE":
                value = self.stack.pop()
                self.ip += 1
                return value
            elif cmd == "ADD":
                right = self.stack.pop()
                left = self.stack.pop()
                self.stack.append(left + right)
            elif cmd == "JUMP":
                self.ip = arg
                continue
            self.ip += 1
        raise StopIteration


gen = Generator(CODE_RANGE)
for _ in range(1, 100, 1):
    print(next(gen))
```

这是一个非常深刻的计算机系统设计问题。

你的直觉是对的：**完成同一个任务（比如赋值），栈模式确实需要跑更多的指令条数。**

但是，当我把说“一步到位需要更多指令”时，我指的不是“跑代码的时候要执行多少行”，而是**“虚拟机一共需要认识多少个单词（指令种类）”**。

这在计算机科学中被称为 **“组合爆炸” (Combinatorial Explosion)** 问题。

我们可以用**“乐高积木” vs “定制模具”**来比喻。

---

### 1. 场景模拟：我们需要做四种数学运算

假设我们只做加法（+），但数据来源有三种：**常量（比如1）**、**变量（比如a）**、**函数返回值**。

#### A. 栈模式（Python的选择）：乐高积木
栈模式的核心思想是：**“原子化”**。每个指令只做一件事，做到极致。

*   `LOAD`: 只负责搬运（不管是搬1还是搬a）。
*   `STORE`: 只负责存。
*   `ADD`: 只负责把手里的两个东西相加（根本不关心这两个东西是从哪来的）。

**VM 需要认识的指令总数：只有 3 个** (`LOAD`, `STORE`, `ADD`)。

**无论你想怎么组合，这 3 个指令就够了：**
*   `a = 1 + 2` -> LOAD, LOAD, ADD, STORE
*   `a = b + c` -> LOAD, LOAD, ADD, STORE
*   `a = b + 1` -> LOAD, LOAD, ADD, STORE

虽然代码行数多（每次都得4行），但虚拟机的设计非常简单，只有3个零件。

---

#### B. “一步到位”模式：定制机器
如果你非要“一步到位”，把“取值、运算、赋值”合成一条指令，为了覆盖所有情况，你得设计多少种指令？

来看看为了支持加法，你需要发明哪些指令：

1.  **情况1（常数+常数）**：`a = 1 + 2`
    *   你需要发明指令：`ADD_CONST_CONST_TO_VAR` (常数加常数存入变量)
2.  **情况2（变量+变量）**：`a = b + c`
    *   你需要发明指令：`ADD_VAR_VAR_TO_VAR` (变量加变量存入变量)
3.  **情况3（变量+常数）**：`a = b + 1`
    *   你需要发明指令：`ADD_VAR_CONST_TO_VAR`
4.  **情况4（常数+变量）**：`a = 1 + b`
    *   你需要发明指令：`ADD_CONST_VAR_TO_VAR`

**看！光是一个简单的加法，你就被迫发明了 4 种新指令！**

如果你还要支持减法、乘法、除法呢？
*   4种加法指令
*   4种减法指令
*   4种乘法指令
*   4种除法指令
*   ...
**指令集的数量瞬间变成了 $N \times M$ 的倍数增长。**

---

### 2. 数学上的对比

假设有 $N$ 种运算（加减乘除...）和 $M$ 种数据来源（常量、局部变量、全局变量...）。

*   **栈模式（解耦）**：
    你需要设计的指令数量是 **$N + M$**。
    （你需要 $M$ 种加载指令，和 $N$ 种运算指令。它们混合使用。）

*   **一步到位模式（耦合）**：
    你需要设计的指令数量是 **$N \times M \times M$**。
    （每种运算都要考虑到左边是啥，右边是啥，存到哪里）。

### 3. 现实中的复杂性

再举个更复杂的例子：`a = b + c + d`

*   **栈模式**：
    不需要新指令。就是不断地 `LOAD`, `ADD`, `LOAD`, `ADD`, `STORE`。依然是用那3个积木搭出来的。

*   **一步到位模式**：
    傻眼了。之前的指令都是“两个数相加”，现在三个数怎么办？
    *   难道要发明一个 `ADD_3_VARS_TO_VAR`？
    *   那如果有 10 个数相加呢？

**结论：**
“一步到位”看似在执行时省了步骤，但它导致**指令集（词汇表）过于庞大和僵化**。

Python 为了保持虚拟机（解释器）的简单和通用，选择了**栈模式**：
1.  指令数量少，容易实现。
2.  极度灵活，几个基础指令能组合出宇宙万物。
3.  代价是：运行同样的代码，需要执行的“微操作”次数（字节码长度）会多一点。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-generator)