<div id="chap-decorate"></div>

[⬆️ 返回目录](#catalog)


## 装饰器

Python 对 `@aop_decorator` 的识别和处理，本质上是 **编译器的语法糖（Syntactic Sugar）** 加上 **函数对象的重绑定**。

简单来说，Python 解释器在读取代码时，会将 `@` 语法自动转换成一次**函数调用**和**赋值操作**。

我们可以从三个层面来深入剖析：

### 1. 等价代码（一语道破）

当 Python 解释器看到这段代码：

```python
@aop_decorator
def calculate(x, y):
    ...
```

它在内部实际上执行的是下面这段代码：

```python
def calculate(x, y):
    ...

# 核心步骤：将定义的函数作为参数传入装饰器，用返回值覆盖原名
calculate = aop_decorator(calculate)
```

这就是根本机制：**定义原函数 $\rightarrow$ 传给装饰器 $\rightarrow$ 拿回新函数 $\rightarrow$ 覆盖原变量名。**

### 2. 执行流程（解释器在做什么？）

这个过程发生在 **“定义时”（Definition Time）**，也就是 Python 刚刚加载这个 `.py` 文件的时候，而不是在调用 `calculate()` 的时候。

具体步骤如下：

1.  **识别定义**：解释器读取到 `def calculate...`，并在内存中创建了一个函数对象（我们暂且叫它 `Original_Func`）。
2.  **发现装饰器**：解释器看到 `def` 头顶上有个 `@aop_decorator`。
3.  **执行劫持**：
    *   它**不会**把 `Original_Func` 赋值给变量名 `calculate`。
    *   相反，它立即调用 `aop_decorator(Original_Func)`。
4.  **替换变量**：
    *   `aop_decorator` 执行完毕，返回一个新的对象（通常是一个闭包/内层函数，我们叫它 `Wrapper_Func`）。
    *   解释器将这个 `Wrapper_Func` 赋值给变量名 `calculate`。

**结果**：当你后续在代码里写 `calculate(2, 3)` 时，你实际调用的是 `Wrapper_Func(2, 3)`。

### 3. 代码实战：AOP 是如何实现的？

为了让你更清楚“处理”的过程，我们需要看 `aop_decorator` 内部必须长什么样才能配合这个机制。

```python
import time
from functools import wraps

def aop_decorator(func):
    # 【阶段1】这里是“定义时”执行的代码
    # Python 加载文件时，print("装载装饰器") 会立即执行
    
    @wraps(func)  # 保持原函数的元数据（如 __name__, __doc__）
    def wrapper(*args, **kwargs):
        # 【阶段2】这里是“运行时”执行的代码（AOP 切面逻辑）
        print(">>> [Before] AOP Start: Logging/Auth check")
        
        start_time = time.time()
        
        # 调用原始函数（由于闭包机制，wrapper 记得 func）
        result = func(*args, **kwargs)
        
        end_time = time.time()
        print(f">>> [After] Cost: {end_time - start_time}s")
        
        return result
    
    # 返回这个 wrapper 函数，它将替换掉原本的 calculate
    return wrapper

@aop_decorator
def calculate(x, y):
    time.sleep(0.1)
    return x * y

# --- 验证 ---
# 调用 calculate 时，其实是在调用 wrapper
print(calculate(10, 20))
```

### 4. 底层字节码视角（如果不信）

如果你使用 `dis` 模块查看 Python 编译后的字节码，这个过程会暴露无遗：

```python
import dis
dis.dis(compile("""
@aop_decorator
def calculate(x, y):
    return x * y
""", '', 'exec'))
```

**输出解读（简化版）：**

1.  `LOAD_NAME (aop_decorator)`: 先把装饰器函数加载进来。
2.  `LOAD_CONST (code object calculate)`: 加载 `calculate` 的函数体代码。
3.  `MAKE_FUNCTION`: 创建原始的 `calculate` 函数对象。
4.  **`CALL_FUNCTION`**: 关键点！带着刚才创建的函数对象，调用栈顶的 `aop_decorator`。
5.  **`STORE_NAME (calculate)`**: 将调用的返回值（wrapper），存入变量名 `calculate`。

### 总结

Python 识别 `@aop_decorator` 的逻辑非常简单粗暴：

1.  **识别**：看到 `@` 符号。
2.  **处理**：
    *   先编译下面的函数。
    *   把函数丢给 `@` 后面的东西去处理。
    *   用处理后的结果**鸠占鹊巢**，替换掉原来的函数名。

这就是为什么装饰器可以用来做 AOP（面向切面编程）：因为它给了你一个机会，在函数正式投入使用前，**偷梁换柱**，把一段“夹带私货”的逻辑（Wrapper）包装在原函数外面。

Python 解释器在处理 `@property` 时，**并没有**给它开任何“后门”或特殊待遇。它和 `@aop_decorator` 一样，完全遵循标准的装饰器语法糖规则。

我们可以对比一下两者的区别：

### 1. 语法层面（完全一致）

当你在类里面写：

```python
class User:
    @property
    def age(self):
        return 18
```

Python 解释器在**定义类的时候**，实际上执行的是：

```python
class User:
    # 1. 先定义原始函数
    def age(self):
        return 18
    
    # 2. 立即执行装饰器逻辑：调用 property 类，传入函数
    # 3. 用返回值覆盖原变量名 'age'
    age = property(age) 
```

看到没？这一步和之前的 `calculate = aop_decorator(calculate)` **一模一样**。

### 2. 结果层面（核心区别）

虽然语法过程一样，但 `property` 和普通装饰器的**返回值类型**不同，导致了后续用法的巨大差异。

#### 普通装饰器 (AOP)
*   **输入**：函数。
*   **返回**：一个新的**函数**（Wrapper）。
*   **调用**：`obj.calculate()`。因为 `calculate` 依然是个可调用的函数对象。

#### @property 装饰器
*   **输入**：函数（Getter）。
*   **返回**：一个 **`property` 类的实例对象**（这就是一个**描述符**）。
*   **调用**：`obj.age`。
    *   此时 `User.age` 不再是一个函数了，它是一个对象！
    *   当你访问 `obj.age` 时，Python 发现 `age` 是个描述符，于是自动触发了它的 `__get__` 方法，运行了原本的 getter 函数。

### 3. 验证一下（眼见为实）

我们可以直接打印类型来看看：

```python
class AopClass:
    @staticmethod  # staticmethod 也是装饰器
    def func(): pass

class PropClass:
    @property
    def attr(self): return 1

# 验证 AOP/普通装饰器
# func 被替换成了 staticmethod 对象（或者 wrapper 函数）
print(AopClass.func) 
# <function AopClass.func at ...> (如果是自定义wrapper) 或 <staticmethod object ...>

# 验证 @property
# attr 被替换成了 property 对象
print(PropClass.attr)
# <property object at 0x...>  <-- 注意：它是一个对象，不是函数！
```

### 4. 进阶：那 `@age.setter` 是怎么回事？

既然 `age` 已经被替换成了一个 `property` 对象，那下面的代码也就好理解了：

```python
class User:
    @property
    def age(self):
        return 18
    # 此时，User.age 已经是一个 property 实例对象了

    @age.setter  # 这里的 age 就是上面生成的那个对象
    def age(self, value):
        print(f"Set to {value}")
```

这背后的等价代码是：

```python
class User:
    def age(self): return 18
    age = property(age)  # age 变成了 property 对象
    
    # 定义 setter 函数（临时变量）
    def _age_setter(self, value): 
        print(f"Set to {value}")
    
    # 调用 property 对象的 setter 方法
    # 这会返回一个新的 property 对象（包含 getter 和 setter）
    # 然后再次覆盖 age 变量
    age = age.setter(_age_setter)
```

这就是为什么你在上一个问题里看到 `return type(self)(...)` 很重要——因为 `@age.setter` 必须返回一个新的描述符对象来替换旧的。

### 总结

*   **@property 没有魔法**：它利用了标准的装饰器语法 `name = func(name)`。
*   **property 是个类**：`@property` 实际上是实例化了一个类。
*   **结果是描述符**：它把函数名替换成了一个**描述符对象**，从而利用描述符协议拦截了属性访问。

```python
import types

def make_cell(value):
    return (lambda: value).__closure__[0]


def aop_log_time(func):
    def wrapper(*args, **kwargs):
        import time

        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(
            f"Function '{func.__name__}' executed in {end_time - start_time:.4f} seconds"
        )
        return result

    func_cell = make_cell(func)
    closure = (func_cell,)
    aop_func = types.FunctionType(
        wrapper.__code__,  # 切面逻辑的字节码
        func.__globals__,  # 复用原函数的全局作用域
        func.__name__,  # 保留原函数名
        func.__defaults__,  # 保留原函数默认参数
        closure,  # 保留原函数闭包（如果有）
    )

    aop_func.__doc__ = func.__doc__
    aop_func.__annotations__ = func.__annotations__
    return aop_func



@aop_log_time
def add(x, y):  
    """Adds two numbers and returns the result."""      
    return x + y


result = add(5, 7)
print(f"Result of add: {result}")
print(add.__doc__)

```


<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-decorate)