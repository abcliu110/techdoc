<div id="chap-request"></div>

[⬆️ 返回目录](#catalog)


## request

这三个字段分别代表了 HTTP 请求中不同维度的信息：**“找谁”**、**“谁发来的”**、**“具体要什么”**。

我们可以假设一个场景：
*   **用户**（IP: `203.0.113.10`）
*   **浏览器**访问地址：`http://www.example.com/search?q=golang`
*   **服务器**接收到了这个请求。

以下是这三个字段在 `fmt.Printf` 中的具体含义：

---

### 1. `r.Host` —— “用户想找谁” (目标域名)

*   **含义**：客户端在 HTTP 请求头里的 `Host` 字段。通常是**域名**（可能带端口）。
*   **形式**：`域名` 或 `域名:端口`
*   **示例**：`www.example.com` 或 `localhost:8080`
*   **关键点**：
    *   它**不是**服务器的机器名，而是浏览器地址栏里输入的域名。
    *   在虚拟主机（一台服务器挂多个网站）场景下，Nginx 或 Go 就是靠这个字段区分用户到底想访问 A 网站还是 B 网站。

### 2. `r.RemoteAddr` —— “谁发来的请求” (来源 IP)

*   **含义**：发起网络请求的**客户端网络地址**。
*   **形式**：`IP:端口`
*   **示例**：`203.0.113.10:54321` (注意：端口是随机的高位端口)
*   **关键点**：
    *   它代表**直接**连接到服务器的那台机器的 IP。
    *   **坑**：如果你的 Go 程序前面加了 Nginx、阿里云 SLB 或 Cloudflare，这个 `RemoteAddr` 往往会变成**Nginx 或负载均衡器的内网 IP**（比如 `127.0.0.1:xxx`），而不是真实用户的 IP。
    *   *获取真实 IP 的方法*：通常需要读取 Request Header 里的 `X-Forwarded-For` 或 `X-Real-IP`。

### 3. `r.URL` —— “具体要什么资源” (路径与参数)

*   **含义**：请求行（Request-Line）里的 URI 部分。
*   **形式**：`path` + `query`
*   **示例**：`/search?q=golang`
*   **关键点（非常重要）**：
    *   虽然它叫 URL，但在服务端接收到的 `r.URL` 结构体中，通常**只有路径（Path）和查询参数（Query）**。
    *   **Scheme (http/https)** 和 **Host** 通常是**空的**！
    *   这就是为什么你在写反向代理时，必须手动补全 `r.URL.Scheme = "http"` 和 `r.URL.Host = r.Host`，否则 `RoundTrip` 会报错，因为它不知道该往哪发。

---

### 总结对照表

假设你在本地（localhost）运行代码，浏览器访问 `http://localhost:8080/api/v1/user?id=100`

| 代码 | 打印结果示例 | 解释 |
| :--- | :--- | :--- |
| **`r.Host`** | `localhost:8080` | 浏览器认为它访问的是这个域名（相当于信封上的“收件人”）。 |
| **`r.RemoteAddr`** | `127.0.0.1:63452` | 实际上是这台机器的这个端口发起的 TCP 连接（相当于快递员的“发件地址”）。 |
| **`r.URL`** | `/api/v1/user?id=100` | 具体的资源路径（相当于信里的“正文”）。注意它**没有**包含 `http://localhost:8080` 前缀。 |

### 这里的 `fmt.Printf` 输出会像这样：
```text
Received request GET from localhost:8080 to 127.0.0.1:63452 /api/v1/user?id=100
```
*(注：如果是在公网服务器，RemoteAddr 会是真实的公网 IP)*

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-request)