<div id="chap-forwardproxy"></div>

[⬆️ 返回目录](#catalog)


## 正向代理
**完全正确！你抓住了问题的核心。**

这正是 **正向代理 (Forward Proxy)** 和 **反向代理/普通服务器 (Reverse Proxy / Origin Server)** 在处理请求时最根本的区别。

我们可以通过 HTTP 协议的原始报文来一眼看穿这个差异：

### 1. 为什么正向代理时 `r.URL.Host` 会有值？

这是由 **HTTP 协议规定** 的。当客户端（比如浏览器）配置了代理服务器时，它发送的 HTTP 请求行格式会发生变化。

#### 场景 A：普通请求 / 反向代理（你直接访问网站）
浏览器发出的原始报文：
```http
GET /index.html HTTP/1.1
Host: www.baidu.com
```
*   **RequestURI**: `/index.html` (只有路径)
*   **Go 解析结果**:
    *   `r.RequestURI` = `/index.html`
    *   `r.URL.Path` = `/index.html`
    *   **`r.URL.Host` = "" (空的！因为请求行里没写)**
    *   **`r.URL.Scheme` = "" (空的！)**
    *   `r.Host` = `www.baidu.com` (从 Header 里拿的)

#### 场景 B：正向代理（浏览器通过你的 Go 代理访问网站）
浏览器发出的原始报文（注意第一行！）：
```http
GET http://www.baidu.com/index.html HTTP/1.1
Host: www.baidu.com
```
*   **RequestURI**: `http://www.baidu.com/index.html` (完整的绝对路径)
*   **Go 解析结果**:
    *   `r.RequestURI` = `http://www.baidu.com/index.html`
    *   **Go 此时解析这个完整字符串，自然就能拆解出：**
    *   **`r.URL.Scheme` = `http` (有值了)**
    *   **`r.URL.Host` = `www.baidu.com` (有值了)**
    *   `r.URL.Path` = `/index.html`

---

### 2. 这对写代码意味着什么？

理解了这一点，你就明白了为什么网上的 **反向代理代码** 和 **正向代理代码** 写法不一样。

#### 写正向代理时（Forward Proxy）
因为 `r.URL.Host` 已经有值了，你**不需要**手动告诉 `RoundTrip` 往哪里发，你只需要清理 `RequestURI` 即可。

```go
// 正向代理 Handler
func handleForwardProxy(w http.ResponseWriter, r *http.Request) {
    // 1. r.URL.Host 此时已经是 "www.baidu.com" 了
    // 2. r.URL.Scheme 此时已经是 "http" 了
    
    // 3. 只需要清空 RequestURI (防止报错)
    r.RequestURI = ""
    
    // 4. 直接发送！不需要手动设置 Host
    client.Do(r) 
}
```

#### 写反向代理时（Reverse Proxy / Gateway）
因为 `r.URL.Host` 是空的，如果你不手动填，`RoundTrip` 根本不知道发给谁。

```go
// 反向代理 Handler
func handleReverseProxy(w http.ResponseWriter, r *http.Request) {
    // 1. r.URL.Host 是空的 ""
    
    // 2. 必须清空 RequestURI
    r.RequestURI = ""
    
    // 3. 【必须】手动指定转发目标
    r.URL.Scheme = "http"
    r.URL.Host = "127.0.0.1:9090" // 告诉它去哪里
    
    // 4. 发送
    client.Do(r)
}
```

### 3. 特殊情况：HTTPS 的 CONNECT 请求

如果是 HTTPS 正向代理，浏览器会发送 `CONNECT` 请求：

```http
CONNECT www.google.com:443 HTTP/1.1
Host: www.google.com:443
```

在这种情况下：
*   `r.Method` 是 `CONNECT`
*   `r.URL.Host` 是 `www.google.com:443`
*   **注意**：`r.URL.Scheme` 通常是空的（因为 CONNECT 只是建立隧道，不涉及 http/https 协议语义），但在处理时你通常直接用 `Host` 建立 TCP 连接。

### 总结

你的理解非常到位：

*   **正向代理**：`r.URL.Host` **有值**。（因为客户端发来的是绝对路径 `http://...`）
*   **反向代理**：`r.URL.Host` **无值**。（因为客户端发来的是相对路径 `/...`）

这就是为什么在反向代理中，我们总是需要配置 `proxy_pass` (Nginx) 或者在 Go 里写 `r.URL.Host = target`，而在正向代理中通常不需要配置目标地址的原因。

这是一个非常关键的观测结果！这说明了一个核心问题：

**你的客户端（浏览器或 curl）并没有把你的 Go 程序当作“代理服务器”，而是把它当作了“最终的目标服务器”。**

即使你把代码写成了代理的样子，但**HTTP 协议的请求格式是由客户端（Client）决定的**，而不是由服务端（Server）决定的。

让我们来拆解为什么会出现 `GET index.html` 而不是 `GET http://...`。

---

### 1. 场景还原：你可能是这样测试的

你很可能是在浏览器地址栏输入了：`http://localhost:8080/index.html`，或者用了命令 `curl http://localhost:8080/index.html`。

#### 此时发生了什么？
1.  客户端认为：`localhost:8080` 就是**最终目的地**（Origin Server）。
2.  客户端构建请求行：按照标准 HTTP 规范，发给最终服务器时，只发送**相对路径**。
3.  **实际报文**：
    ```http
    GET /index.html HTTP/1.1
    Host: localhost:8080
    ```
4.  **Go 服务端收到后**：
    *   `r.Method`: GET
    *   `r.RequestURI`: `/index.html`
    *   **`r.URL.Host`: "" (空！)** —— 因为请求行里没有。
    *   `r.Host`: `localhost:8080`

**结论**：在这种测试方法下，你的 Go 程序收到的就是标准的“反向代理/Web服务器”格式请求。

---

### 2. 正确的“正向代理”测试方法

要让客户端发送 `GET http://www.baidu.com/index.html HTTP/1.1`，你必须**显式地告诉客户端：“请使用代理”**。

#### 方法 A：使用 curl 指定代理 (`-x`)
你应该这样运行命令：

```bash
# -x 指定代理地址，后面的 URL 写完整的目标地址
curl -v -x http://localhost:8080 http://www.baidu.com/index.html
```

#### 此时发生了什么？
1.  curl 知道 `localhost:8080` 是个**代理**（Proxy）。
2.  curl 知道最终目标是 `baidu.com`。
3.  curl 构建请求行：按照标准 HTTP 规范，发给正向代理时，必须发送**绝对路径**。
4.  **实际报文**：
    ```http
    GET http://www.baidu.com/index.html HTTP/1.1
    Host: www.baidu.com
    ```
5.  **Go 服务端收到后**：
    *   `r.Method`: GET
    *   `r.RequestURI`: `http://www.baidu.com/index.html`
    *   **`r.URL.Host`: "www.baidu.com" (有值了！)**
    *   `r.Host`: `www.baidu.com`

---

### 3. 透明代理 (Transparent Proxy) 的特例

还有一种情况，你的观测是正确的，那就是做 **透明代理**（例如通过 iptables 强行劫持流量转发到你的端口）。

在透明代理模式下：
1.  用户（客户端）根本不知道代理的存在，它以为自己直接连的百度。
2.  客户端发出的自然是 `GET /index.html`。
3.  你的 Go 程序截获了这个流量。
4.  此时 `r.URL.Host` 是空的。
5.  **关键点**：你需要通过 `r.Host` 或者读取底层的 socket 信息（`SO_ORIGINAL_DST`）来还原用户到底想访问谁。

---

### 4. 总结：如何编写兼容的代码？

既然你可能会收到“相对路径”请求（场景1），也可能收到“绝对路径”请求（场景2），一个健壮的代理服务器代码应该同时处理这两种情况。

**通用代理代码逻辑（伪代码）：**

```go
func handleProxy(w http.ResponseWriter, r *http.Request) {
    // 1. 克隆请求
    outReq := r.Clone(context.Background())
    
    // 2. 无论哪种情况，RequestURI 都必须清空
    outReq.RequestURI = ""

    // 3. 智能判断 Host
    if outReq.URL.Host != "" {
        // 情况 A: 标准正向代理请求 (GET http://baidu.com/...)
        // r.URL.Host 已经有值了，啥都不用做，直接发
    } else {
        // 情况 B: 被当成普通服务器访问 (GET /index.html) 或 透明代理
        // 此时 r.URL.Host 是空的，必须手动补全
        
        // 策略1：如果只是简单的反向代理，直接写死目标
        // outReq.URL.Scheme = "http"
        // outReq.URL.Host = "www.baidu.com"
        
        // 策略2：如果是透明代理，尝试信任 r.Host (不一定安全，视场景而定)
        outReq.URL.Scheme = "http"
        outReq.URL.Host = r.Host 
    }

    // 4. 发送
    transport.RoundTrip(outReq)
}
```

### 你的测试结果说明了什么？
说明你目前是在**以“访问普通网站”的方式访问你的代理服务器**。在这种模式下，你的代码必须手动设置 `r.URL.Host`，否则转发会失败。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-forwardproxy)