<div id="chap-mutex"></div>

[⬆️ 返回目录](#catalog)


## Mutex

在 Go 语言的 `sync.Mutex` 实现机制中，**自旋（Spinning）** 和 **P 的本地队列（P's Local Run Queue）** 密切相关。

互斥锁为了优化性能，不会一遇到锁被占用就立刻把协程挂起（因为挂起和恢复的系统开销很大），而是先尝试“自旋”一会。但是，自旋必须满足严格的条件，否则会浪费 CPU。而 **P 队列的状态** 就是判断能否自旋的关键条件之一。

以下是详细解释：

---

### 一、自旋的条件 (Spinning Conditions)

在 `sync.Mutex` 的源码中，判断是否可以自旋的逻辑主要封装在 runtime 的 `canSpin` 函数中。

只有**同时满足**以下所有条件，协程才会进入自旋：

1.  **锁处于正常模式**：
    *   如果锁处于**饥饿模式**，禁止自旋。因为饥饿模式下锁必须严格交给排在队头的协程，新来的不能插队。
2.  **锁当前是被锁住的**：
    *   如果锁没被锁住，那还自旋什么？直接去抢啊。
3.  **多核 CPU (`GOMAXPROCS > 1`)**：
    *   这是最核心的物理条件。如果是单核，持有锁的协程和请求锁的协程在同一个 CPU 上。请求者自旋占用了 CPU，持有者就没法运行，也就没法释放锁。单核自旋会导致死锁或极度浪费。
4.  **自旋次数未超标**：
    *   最多自旋 **4 次**。如果转了 4 圈还没等到锁，说明锁竞争比较激烈或者持有时间较长，就不等了，准备去休眠。
5.  **P 的本地运行队列是空的 (Critical)**：
    *   **重点**：当前协程所在的 **P (Processor)** 的本地运行队列（Local Run Queue）必须没有其他待运行的 G。
    *   **原因**：如果 P 的队列里还有别的协程在排队等着干活，当前的协程却在这里空转浪费 CPU，这是调度器不允许的。如果有活干，就应该立刻把 CPU 让出来，而不是在这里空等锁。

---

### 二、P 队列是什么 (P's Local Run Queue)

你提到的“P 队列”，在 Go 的 GMP 调度模型中，指的是 **P 的本地运行队列（Local Run Queue）**。

#### 1. GMP 模型背景简述
*   **G (Goroutine)**: 协程，包含代码和状态。
*   **M (Machine)**: 内核线程，实际执行代码的地方。
*   **P (Processor)**: 逻辑处理器，管理 G 的上下文，决定哪个 G 在 M 上跑。

#### 2. P 队列的具体含义
每个 P 都拥有一个**私有的**、**固定容量**（256 容量的环形数组）的队列，用来存放**等待运行的 Goroutine**。

*   **作用**：当一个 G 创建了新的 G'（或者唤醒了某个 G），优先会把这个 G' 放到当前 P 的本地队列里。
*   **特点**：
    *   **速度快**：因为是 P 私有的，M 在执行 P 里的 G 时，访问这个队列通常**不需要加锁**（或者只需要很轻量的锁），比访问全局队列快得多。
    *   **优先级高**：M 找活干的时候，先看 P 的本地队列，再看全局队列（Global Queue），最后去别的 P 偷（Work Stealing）。

#### 3. P 队列与 Mutex 自旋的关系
结合第一部分的“条件5”，这下就串起来了：

当一个协程在 `Mutex.Lock()` 中想要自旋时，它会去检查：“**我的 P 老大，你的小本本（本地队列）上还有别的 G 等着运行吗？**”

*   **如果有（P 队列非空）**：
    *   说明系统比较忙，CPU 资源宝贵。
    *   **决策**：停止自旋，立即挂起当前协程，让出 M 和 P 去执行队列里那个等待的 G。
*   **如果没有（P 队列为空）**：
    *   说明当前 P 比较闲，CPU 空着也是空着。
    *   **决策**：允许自旋。赌一把锁马上就会释放，利用这段空闲时间等一等，避免昂贵的线程切换。

### 总结

*   **自旋的条件**：必须是**多核**、**正常模式**、**尝试次数少**，且最重要的是**当前 P 没事干（队列为空）**。
*   **P 队列**：是 **Processor 的本地任务队列**，存放待执行的 Goroutine。它的非空状态会直接**打断** Mutex 的自旋，强制协程去休眠，以保证 CPU 优先处理确定的任务。

进入饥饿模式的条件非常明确，只有一个核心指标：**等待时间**。

### 核心触发条件
**当一个 Goroutine 在等待队列（信号量）中被唤醒，尝试获取锁但失败（被新来的抢走了），且它发现自己等待锁的总时间超过了 1 毫秒（1ms），它就会将 Mutex 切换进入饥饿模式。**

---

### 详细的过程解析

为了更清晰地理解，我们模拟一下这个场景：

1.  **排队等待**：
    协程 `G_Old` 尝试加锁失败，进入信号量队列休眠，记录了一个**开始等待时间戳** `t0`。

2.  **被唤醒 (Wake up)**：
    持有锁的协程释放了锁，唤醒了队列头部的 `G_Old`。

3.  **竞争失败 (Lose the race)**：
    `G_Old` 醒来准备去拿锁。但是，非常不凑巧，此时刚好有一个新来的协程 `G_New` 正在 CPU 上运行并请求锁。
    *   由于 `G_New` 正在运行（热缓存），而 `G_Old` 刚被调度（冷启动），**`G_New` 动作更快，抢到了锁**。
    *   `G_Old` 被抢了，只能准备再次回去睡觉。

4.  **检查时间 (Check Time)**：
    在回去睡觉之前，`G_Old` 此时非常“生气”，它看了一下当前时间 `t1`。
    *   它计算：`等待时长 = t1 - t0`。
    *   **判定**：如果 `等待时长 > 1ms`。

5.  **切换模式 (Switch Mode)**：
    `G_Old` 在下一次修改 `state` 字段时，会强制把 `mutexStarving`（第3位）置为 **1**。
    此时，Mutex 正式进入**饥饿模式**。

---

### 饥饿模式生效后的影响

一旦 `G_Old` 把模式切换为饥饿模式，规则立刻改变：

1.  **不再竞争**：此时持有锁的 `G_New` 释放锁时，**不会**只是简单地把锁置为空闲，而是直接把锁的所有权**指定移交（Handoff）**给队列头部的 `G_Old`。
2.  **新人让路**：此时如果有其他的 `G_New2` 试图加锁，它发现是饥饿模式，**禁止自旋**，也**禁止抢锁**，直接乖乖排到队列的**尾部**。

### 什么时候退出饥饿模式？

为了防止系统长期处于低性能的饥饿模式（因为饥饿模式禁止了高效的自旋），Go 设定了**退出条件**。当某个协程（比如 `G_Old`）最终拿到了锁，它会判断：

1.  **我是最后一个**：如果等待队列里已经没有其他协程了（我是最后一个娃）。
2.  **由于我太快了**：或者我获取锁所花的等待时间 **小于 1ms**。

只要满足上述任意一个条件，该协程就会把 `mutexStarving` 位清零，将锁切换回**正常模式**。

### 总结

进入饥饿模式是因为**“老实排队的人被插队太多次，且等待太久（>1ms）”**，系统为了保证**公平性**及防止**尾部延迟（Tail Latency）**过高而启动的一种保护机制。

这是一个非常深刻的问题，触及到了 Go 调度器（GMP 模型）和操作系统内核交互的核心机制。

简单来说：**“休眠”的协程（Goroutine）本质上只是内存中的一个数据结构（G）。唤醒它，并不是像推醒一个人那样，而是把这个数据结构从“等待区”移动回“待办事项清单（运行队列）”，等着 CPU 此时此刻正在跑的线程（M）下次去取它。**

下面通过三个层面来拆解这个“唤醒”过程：

---

### 第一层：逻辑层面（数据结构的移动）

当协程 `G1` 因抢不到锁而进入休眠时，它并没有“消失”，而是发生了两件事：
1.  **状态变更**：它的状态从 `_Grunning`（运行中）变成了 `_Gwaiting`（等待中）。
2.  **挂载**：它把自己打包成一个 `sudog`（一种包装结构），挂到了这个 Mutex 对应的**信号量哈希表（Semaphore Table）**里。
    *   此时，`G1` 已经脱离了 P（处理器）的运行队列，M（线程）不再理会它，转而去跑别的协程了。

**当持有锁的 `G2` 释放锁并发送信号时：**

1.  **查找**：`G2` 执行 `runtime_Semrelease`，通过 Mutex 的地址在哈希表里找到了正在休眠的 `G1`。
2.  **改状态**：`G2`（或者说是 Runtime 系统）直接修改 `G1` 的状态，从 `_Gwaiting` 改回 **`_Grunnable`（可运行）**。
3.  **重新入队**：这是最关键的一步。`G2` 会把 `G1` 从哈希表里摘下来，**重新塞回到某个 P 的本地运行队列（Local Run Queue）或者全局运行队列（Global Run Queue）里**。

**结论**：`G1` “知道”自己被唤醒，是因为它的状态变了，且位置变了（回到了运行队列）。它不需要自己“监听”，而是被动地被别人挪了位置。

---

### 第二层：调度层面（M 是如何调用它的）

你可能会问：*“G1 此时还在内存里躺着呢，谁去执行它？”*

**答案是：正在干活的 M（系统线程）。**

M 的工作是一个死循环（调度循环 `schedule()`）：
1.  M 问 P：“你的本地队列里有 G 吗？”
2.  如果有，取出来执行。
3.  如果没有，去全局队列找；再去别的 P 那里偷（Work Stealing）。

**唤醒流程**：
1.  当 `G2` 把 `G1` 放入运行队列后，`G1` 就变成了“待办事项”。
2.  当某个 M（可能是刚刚跑完 `G2` 的那个 M，也可能是别的空闲 M）在下一轮调度循环中，从队列里**取到了** `G1`。
3.  **恢复上下文**：M 读取 `G1` 保存的 PC（程序计数器）和 SP（栈指针），将 CPU 的寄存器复位到 `G1` 休眠前的位置。
4.  **继续执行**：CPU 从 `G1` 停下的那行代码（通常是 `Lock` 函数内部）继续往下跑。

所以，并不是 M 突然“收到通知”去调用它，而是 M 在例行检查任务清单时，**发现**了多了个 `G1`，于是自然而然地去执行了。

---

### 第三层：底层（如果 M 都在休眠怎么办？）

这是一个极端情况。如果系统中所有的 M 都在休眠（比如没有任务了），或者没有足够的 M 来处理这个新唤醒的 `G1`，Go 运行时需要依靠操作系统（OS）来唤醒物理线程。

这里涉及到了 **Futex**（Linux 下的快速用户空间互斥锁）或其他 OS 原语：

1.  **G2 唤醒 G1 时**：Go 运行时会检查是否有空闲的 P（Processor）。
2.  **启动 M**：如果有空闲的 P，但没有空闲的 M（Spinning M），Go 会调用 `wakep()`。
3.  **系统调用**：`wakep()` 最终可能会触发系统调用（如 `futex(WAKE)`），通知操作系统内核：“喂，醒醒，把那个睡着的线程（Thread/M）叫起来干活”。
4.  **M 被唤醒**：操作系统唤醒一个阻塞在内核态的线程 M。这个 M 醒来后，会去绑定 P，然后发现运行队列里的 `G1`，开始执行。

---

### 总结流程图

1.  **等待者 G1**：抢锁失败 $\rightarrow$ 打包进 `sudog` $\rightarrow$ 存入哈希表 $\rightarrow$ **脱离运行队列（休眠）**。
2.  **释放者 G2**：`Unlock` $\rightarrow$ 查哈希表找到 `G1` $\rightarrow$ `goready(G1)`。
3.  **goready 内部**：
    *   将 `G1` 状态改为 `Runnable`。
    *   将 `G1` **塞进 P 的运行队列**。
    *   （如有必要）**唤醒一个闲置的 M**。
4.  **执行者 M**：调度循环 $\rightarrow$ 发现队列里有 `G1` $\rightarrow$ **上下文切换** $\rightarrow$ `G1` 复活。

**一句话总结**：
等待的协程就像是在“银行大厅睡觉的客户”，M 是“叫号员”。释放锁的人（上一个客户）并没有直接摇醒睡觉的客户，而是**把睡觉客户的名字写到了叫号员的“待办名单”上**。叫号员处理完手头的事，一看名单，自然就会叫这个客户去窗口办事了。

你的理解非常敏锐，这确实是 Go 高性能并发的关键所在。

你的观点主要包含两个部分：
1.  **关于信号量**：“Go 的信号量不是 OS 的信号量，只是模拟。” $\rightarrow$ **完全正确**。
2.  **关于唤醒数量**：“G2 把所有协程改为 `_Grunnable` 让它们竞争。” $\rightarrow$ **不对，通常只唤醒一个**。

下面详细拆解这两个核心点：

---

### 1. 为什么说它是“模拟”的信号量？

你是对的。Go 的 `sync.Mutex` 也就是我们常说的“用户态锁”，它的信号量逻辑主要是在 **Go Runtime（运行时）** 层面实现的，而不是直接映射到操作系统的信号量。

#### 区别在哪里？

*   **操作系统的信号量 (OS Semaphore)**：
    *   操作对象是 **线程 (Thread)**。
    *   如果阻塞，意味着内核会将当前线程挂起（上下文切换），这非常重（涉及内核态/用户态切换、缓存失效等），开销大。

*   **Go 的信号量 (Runtime Semaphore)**：
    *   操作对象是 **协程 (Goroutine)**。
    *   **关键点**：当 G1 需要进入信号量休眠时，Go 运行时只是把 G1 的状态改为 `_Gwaiting`，把它放到一个内部的哈希表（`semaTable`）里存起来。
    *   **M（系统线程）并没有睡！** 执行 G1 的那个 M 发现 G1 睡了，它会立马去 P 的队列里找下一个 G2 来跑。
    *   **收益**：这个过程完全在**用户态**完成，仅仅是内存变量的修改和函数调用，不涉及昂贵的操作系统线程切换。

#### 什么时候会用到 OS 的信号量？
只有一种情况：**当 M 实在没活干了**（P 的队列空了，全局队列空了，偷也偷不到），Go 才会让 M 线程去睡在操作系统的信号量（Linux 上通常是 `futex`）上，等待以后有活了被唤醒。但这与 Mutex 的争抢关系不大。

---

### 2. 是唤醒“所有人”还是“一个人”？

**结论：一次只唤醒一个。**

你提到的“把所有在信号量里的协程全部改为 `_Grunnable`”，这在计算机科学里有个专门的术语叫 **“惊群效应” (Thundering Herd Problem)**。

如果释放锁时唤醒了所有 100 个等待者：
1.  100 个 G 同时变成 `Runnable`。
2.  调度器忙疯了，要把它们塞到 P 的队列里。
3.  100 个 G 冲上来抢一把锁，结果必然是 **1 个抢到，99 个失败**。
4.  这 99 个失败者又要重新经历“入队、休眠”的过程。
这不仅浪费 CPU，还严重影响性能。

#### Go 是怎么做的？

Go 的 `semrelease`（释放信号量）操作非常精准：

1.  **查表**：根据锁的地址，在运行时的 `semaTable` 哈希表中找到对应的等待队列（`sudog` 队列）。
2.  **挑一个**：通常是**队头**的那个（FIFO，先进先出）。
3.  **只唤醒它**：
    *   将这**唯一一个** G 的状态改为 `_Grunnable`。
    *   把它放入当前 P 的运行队列。
4.  **其他人继续睡**：队列里剩下的 G 继续保持 `_Gwaiting` 状态，完全不知道外面发生了什么。

---

### 3. 既然只唤醒一个，那“竞争”体现在哪里？

这里要结合我们之前聊的 **正常模式**：

*   **场景**：锁被释放，队列里的 `G_Wake` 被唤醒了。
*   **对手**：此时，可能有崭新的 `G_New` 刚刚调用 `Lock()`，它正在 CPU 上**自旋**。
*   **竞争**：`G_Wake` 刚醒（处于就绪状态，还要等调度），而 `G_New` 正在运行。
    *   虽然只唤醒了一个人，但这个人要和**外面源源不断新来的人**竞争。

**如果是在饥饿模式下：**
*   唤醒一个 `G_Wake`。
*   **没有竞争**：锁直接塞给 `G_Wake`。
*   外面新来的 `G_New` 即使在运行，也不准抢，直接去排队。

### 总结

1.  **Go 的信号量是用户态的**：它“阻塞”的是 Goroutine（让它暂停执行），而不是阻塞物理线程 M（M 会转头去干别的活）。这使得 Go 的锁极其轻量。
2.  **拒绝惊群**：Go 只唤醒**一个**等待者。
3.  **竞争的本质**：是“被唤醒的这一个 G” vs “当前正在 CPU 上自旋的新 G” 之间的单挑，而不是“一群被唤醒的 G”在乱战。

这是一个非常核心的调度问题。理解这个问题的关键在于明白 **P 的本地队列（Local Queue）只存放“准备好干活”的协程**。

我们分四个部分来详细解答。

---

### 一、 为什么要从 P 本地队列移除？

**一句话总结：P 队列是“就绪列表（Ready List）”，不是“停车场”。**

1.  **定义决定**：
    P 的本地队列存放的是状态为 `_Grunnable`（可运行）的协程。这意味着只要 M（线程）拿到了这个 G，下一秒就可以直接执行它的指令。

2.  **避免死循环（忙等待）**：
    如果一个 G 需要等待锁，但它还留在 P 的队列里：
    *   M 取出这个 G。
    *   G 运行，发现锁没开。
    *   G 没法继续往下走，只能再次把自己放回队列。
    *   M 取出下一个...
    *   轮到 G 时，又发现锁没开...
    *   **后果**：这变成了“忙等待”（Busy Waiting），M 线程会一直空转，反复检查锁的状态，白白浪费 CPU 资源。

3.  **让出资源（Yield）**：
    将 G 从 P 队列移除（改为 `_Gwaiting` 状态），意味着 **M 线程可以立刻去取队列里的下一个 G 来运行**。
    *   *比喻*：你在食堂排队打饭（P 队列）。轮到你时（_Grunning），阿姨说红烧肉（锁）还没好。如果你赖在窗口不走（还在队列里），后面的人就没法打饭。正确的做法是你离开窗口，去旁边的椅子上坐着等（_Gwaiting），让后面的人继续打饭。

---

### 二、 还有什么时候会从队列移除？

除了**争抢锁（Mutex）**失败外，任何导致协程无法**立即**继续执行的操作，都会导致它从 P 的队列中移除（即让出 CPU）。

主要场景包括：

1.  **Channel 读写阻塞**：
    *   读一个空管道（`val := <-ch`）或写一个满管道（`ch <- val`）。
    *   G 会被从 P 队列拿走，挂到该 Channel 自己的等待队列（`recvq` 或 `sendq`）里。

2.  **网络 I/O (Netpoller)**：
    *   当你进行网络读取（如 `conn.Read()`）且数据还没到达网卡时。
    *   G 会从 P 队列移除，被扔给 **Netpoller（网络轮询器）** 管理。
    *   *注意*：这里不需要 M 去陪跑，M 会去干别的。等数据到了，Netpoller 会把 G 扔回 P 的队列。

3.  **调用 `time.Sleep()`**：
    *   G 会被移除，放入一个全局的时间堆（Timer Heap）中等待唤醒。

4.  **系统调用 (Syscall)**：
    *   这有点特殊。当 G 调用阻塞式系统调用（如文件 IO）时，**G 和 M 会绑定在一起**，此时它们会**整体脱离** P。
    *   虽然 G 还在 M 上，但在 P 看来，这个 G 已经不在我的队列里了，P 可能会去绑定一个新的 M 来继续运行队列里剩下的 G。

---

### 三、 Go 协程（Goroutine）有哪些状态？

在 Go 源码 `runtime/runtime2.go` 中，协程的状态常量以 `_G` 开头。最核心的状态有以下几种：

| 状态常量 | 含义 | 解释 |
| :--- | :--- | :--- |
| **_Gidle** | 空闲 | 刚分配，还没初始化（仅仅是一块内存）。 |
| **_Gdead** | 死亡 | 协程已退出，或者刚才 Gidle 变成空壳放入对象池等待复用。 |
| **_Grunnable** | **就绪** | **在 P 的队列里（或全局队列）**，等待 M 来执行。 |
| **_Grunning** | **运行中** | 当前正在被 CPU（M）执行。 |
| **_Gsyscall** | 系统调用 | 正在执行系统调用，并未执行用户代码。 |
| **_Gwaiting** | **等待中** | 被阻塞了（锁、Channel、Sleep、网络），**不在 P 队列里**。 |
| **_Gpreempted**| 抢占 | 类似于 _Grunnable，但在强制抢占时的一种特殊标记（Go 1.14+）。 |
| **_Gcopystack**| 栈复制 | 正在进行栈扩容，此时 G 不能被调度。 |

---

### 四、 状态流转图解与触发场景

下面是一个简化的协程生命周期流转：

#### 1. 创建 (`go func`)
*   `_Gdead` -> `_Grunnable`
*   新创建的 G 被加入 P 的本地队列。

#### 2. 被调度执行
*   `_Grunnable` -> `_Grunning`
*   **触发**：M 线程发现 P 队列里有 G，把它取出来跑。

#### 3. 各种阻塞（被移除队列）
*   `_Grunning` -> **`_Gwaiting`**
*   **触发场景**：
    *   `mutex.Lock()` 抢锁失败。
    *   `<-ch` 或 `ch<-` 阻塞。
    *   `time.Sleep()`。
    *   `select` 阻塞。
    *   `waitGroup.Wait()`。

#### 4. 解除阻塞（重回队列）
*   `_Gwaiting` -> **`_Grunnable`**
*   **触发场景**：
    *   锁被 `Unlock`，唤醒了你。
    *   Channel 有数据了/有空间了。
    *   Sleep 时间到了。
    *   **注意**：变为 `_Grunnable` 后，G 并不是立马运行，而是**排队**（进入 P 的队列），等待 M 下次选中它。

#### 5. 系统调用
*   `_Grunning` -> `_Gsyscall`
*   **触发**：调用了 OS 的 API（如读写文件）。
*   **返回**：系统调用结束，变回 `_Grunning`（如果 P 还在等它）或 `_Grunnable`（如果 P 跑了）。

#### 6. 运行超时（被抢占）
*   `_Grunning` -> `_Grunnable`
*   **触发**：Go 运行时监控（sysmon）发现这个 G 运行超过 10ms，强制把它踢下来，防止它长时间占用 CPU。**注意：这种情况不会变成 `_Gwaiting`，而是直接回队列排队。**

#### 7. 退出
*   `_Grunning` -> `_Gdead`
*   **触发**：函数代码执行完毕。

### 总结

*   **移除队列的原因**：为了不占着茅坑不拉屎。只有准备好能运行的 G 才配待在 P 的队列里，阻塞的 G 必须去别的地方（信号量、Channel 等待队、Netpoller）待着。
*   **状态核心**：G 的一生就是在 `_Grunnable`（排队）、`_Grunning`（干活）、`_Gwaiting`（休息）这三个状态中反复横跳，直到死亡。
*   

答案是：**是的，完全是 G 自己把自己“挂”上去的。**

这是一个**主动**的过程，而不是被动的。

当你的代码执行到 `mutex.Lock()` 或者 `<-ch` 时，当前的 Goroutine（简称 G）还在 CPU 上跑，它其实是执行了一段 Go Runtime 的代码。这段代码让 G 像一个“有纪律的排队者”一样，自己完成了填表、排队、交出 CPU 的全过程。

下面我把这个“G 自我流放”的过程拆解给你看，非常精彩：

### 1. 流程拆解：G 是如何把自己送进队列的？

假设 G1 正在运行，执行到了 `mutex.Lock()`，发现锁已经被别人拿了。

#### 第一步：打包自己 (Wrapping)
G1 还在 CPU 上运行。它首先会从缓存里拿出一个叫 `sudog` 的结构体（或者新建一个）。
`sudog` 可以理解为“排队挂号单”。G1 把自己的引用（指针）填进去，同时也把它在等的那个锁（或者 Channel）的信息填进去。
> *潜台词：“我是 G1，我在等这把锁。”*

#### 第二步：自己入队 (Enqueueing)
G1 依然在 CPU 上运行。它拿着这张“挂号单”（`sudog`），执行入队逻辑：
*   **如果是 Mutex**：G1 根据锁的地址，通过哈希算法找到对应的信号量队列，通过 CAS（或加锁）操作，把 `sudog` 链入到那个链表的尾部。
*   **如果是 Channel**：G1 直接把 `sudog` 放到 Channel 结构体里的 `recvq`（接收队列）或 `sendq`（发送队列）里。

**注意：到这一步为止，G1 仍然是 `_Grunning` 状态，它甚至已经把自己放进等待名单了，但它还在 CPU 上干活（干的活就是排队）。**

#### 第三步：交出控制权 (Parking)
排好队后，G1 调用了一个 Runtime 的核心函数：**`gopark`**。
这是一个“自杀式”函数调用。一旦调用它，G1 就开始剥离自己了：
1.  **切换堆栈**：G1 会调用 `mcall`，让当前线程 M 暂时切换到 **`g0` 栈**（这是 M 专用的系统栈，不受 G 限制）。
2.  **修改状态**：在 `g0` 栈上运行的逻辑，会将 G1 的状态从 `_Grunning` 改为 **`_Gwaiting`**。
3.  **切断联系**：把 G1 和当前线程 M 解绑。
4.  **寻找下家**：M 开始执行 `schedule()` 函数，去 P 的本地队列找下一个倒霉蛋（哦不，下一个幸运儿）G2 来运行。

---

### 2. 为什么要设计成“自己动”？

你可能会问：*为什么不搞一个专门的“监控者”来把阻塞的 G 抓走？*

**核心原因：效率。**

*   **没有中间商赚差价**：如果有一个外部线程来管理，就需要频繁的跨线程通信和锁。让正在运行的 G 自己把自己挂上去，利用的是当前 CPU 时间片，数据都在缓存里（Cache Affinity），速度最快。
*   **原子性**：G 自己在入队的时候，通过 CAS 或者轻量级锁保证自己入队成功了，然后再安心去睡。如果别人来操作，很难保证时序的正确性（比如：刚要抓它去睡，结果锁刚好释放了，这就乱套了）。

### 3. 特殊情况：什么时候不是自己动？

绝大多数**阻塞**（Blocking）场景（锁、Channel、Sleep）都是 G 主动调用 `gopark` 挂起自己。

唯有一种情况是**被动**的，那就是**抢占（Preemption）**：
*   如果一个 G 运行时间太长（超过 10ms）而且一直不阻塞。
*   **Sysmon（系统监控线程）** 会发现它霸占 CPU 太久。
*   Sysmon 会向这个 G 发起“信号”（在栈上打个标记）。
*   当 G 执行函数调用时，会检查这个标记，发现自己被通缉了，于是被迫调用调度逻辑，把自己变为 `_Grunnable`（注意不是 Waiting），放回队列尾部。

### 总结

当 G 遇到阻塞时：
1.  **它依然清醒**：它执行 Runtime 代码。
2.  **它自己写名字**：它把自己封装成 `sudog`。
3.  **它自己进队列**：它把 `sudog` 挂到 Mutex/Channel 的链表上。
4.  **它自己吃安眠药**：它调用 `gopark`，修改状态，最后让出 CPU。

就像你去海底捞排队，是你自己**走到**等候区，**自己拿**了号码牌，然后**自己找**个凳子坐下发呆。而不是服务员把你绑过去的。



<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-mutex)