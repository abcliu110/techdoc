<div id="chap-value-assigned"></div>

[⬆️ 返回目录](#catalog)


## 赋值

在 Go 语言中，函数返回值的拷贝原理非常纯粹，核心原则只有一条：**一切皆是值传递（Pass by Value）**。

这意味着，无论你返回的是整数、结构体、指针还是切片，Go 都会将该数据的**内存位模式（Bit Pattern）**完整地拷贝一份给调用者。

为了深入理解，我们需要从**数据类型**和**底层实现（ABI）**两个维度来剖析。

---

### 一、 不同数据类型的拷贝行为

虽然都是“值传递”，但由于不同类型的数据结构不同，拷贝产生的实际效果（浅拷贝 vs 深拷贝）和性能开销也有很大差异。

#### 1. 基础类型（Int, Bool, Float）
*   **行为**：直接拷贝数值本身。
*   **原理**：例如返回一个 `int64`，CPU 直接把这 8 个字节的数据从函数内部拷贝到调用者的位置。
*   **代价**：极低。

#### 2. 结构体（Struct）
*   **行为**：**内存扁平拷贝**。
*   **原理**：Go 会拷贝结构体占用的所有内存字节。
    *   如果结构体很小（如 `type Point struct { x, y int }`），拷贝很快。
    *   如果结构体很大（如包含一个 `[10000]int` 的数组），返回时会发生大规模的内存复制，性能极其低下。
*   **优化建议**：对于大结构体，通常返回其**指针**（`*Struct`），这样只需拷贝 8 字节的地址。

#### 3. 指针（Pointer）
*   **行为**：拷贝地址值。
*   **原理**：返回指针时，拷贝的是内存地址（例如 `0xc000010020`）。调用者和被调用者持有不同的指针变量，但它们指向同一块内存区域。
*   **关键点（逃逸分析）**：如果函数返回了局部变量的指针，Go 编译器会进行**逃逸分析（Escape Analysis）**，将该变量从栈（Stack）移动到堆（Heap）上，以确保函数返回后数据依然可用。这会带来垃圾回收（GC）的开销。

#### 4. “引用类型”：切片（Slice）、Map、Channel、Interface
这是 Go 中最容易让人误解的地方。虽然看起来像引用传递，但**本质依然是值拷贝**。

以 **Slice** 为例，它在运行时的内部结构（`reflect.SliceHeader`）只有三个字段：
```go
type SliceHeader struct {
    Data uintptr // 指向底层数组的指针
    Len  int     // 长度
    Cap  int     // 容量
}
```
*   **原理**：当你返回一个切片时，Go **拷贝了这个 Header（24字节，在64位机器上）**。
*   **效果**：
    *   调用者得到了一个新的 Header，但 `Data` 指针依然指向原来的底层数组。
    *   **表现为浅拷贝**：修改底层数据会影响原切片，但修改 `Len` 或 `Cap` 不会影响原切片。

---

### 二、 底层实现：数据是如何传递的？（栈 vs 寄存器）

Go 语言在函数调用和返回时的底层机制（ABI - Application Binary Interface）在 **Go 1.17** 版本发生了一次重大变革。

#### 1. 传统方式（Go 1.17 之前）：基于栈（Stack-based ABI）
*   **原理**：调用者（Caller）在自己的栈帧中预留一部分空间用于存放返回值。被调用者（Callee）计算完结果后，直接把数据写到这块栈内存中。
*   **缺点**：频繁的内存读写（栈在内存中），给 CPU 缓存（Cache）和流水线带来压力，速度相对较慢。

#### 2. 现代方式（Go 1.17 及以后）：基于寄存器（Register-based ABI）
*   **原理**：利用 CPU 的通用寄存器（AX, BX, CX...）来传递参数和返回值。
*   **过程**：
    1.  如果返回值数量较少且体积小（例如返回 2-3 个 `int` 或指针），Go 编译器会直接将返回值放入 **CPU 寄存器**。
    2.  函数返回后，调用者直接从寄存器读取数据。
    3.  只有当返回值过多或结构体过大，寄存器装不下时，才会回退到使用**栈**传递。
*   **优点**：大幅减少内存访问，性能提升显著（官方数据称综合性能提升约 5%）。

---

### 三、 特殊机制：命名返回值（Named Return Values）

Go 支持命名返回值：
```go
func sum(a, b int) (res int) {
    res = a + b
    return // 裸返回
}
```
**原理**：
*   本质上，`res` 被视为函数的一个**局部变量**。
*   在栈传递模型中，`res` 的地址实际上就是调用者预留的返回值栈空间的地址。
*   在寄存器模型中，`res` 计算完毕后会被装入寄存器。
*   **拷贝发生时机**：对于大对象，修改 `res` 就是直接修改返回值内存；对于小对象，`return` 时将值载入寄存器。

---

### 四、 总结与最佳实践

| 返回类型 | 拷贝内容 | 内存开销 | 注意事项 |
| :--- | :--- | :--- | :--- |
| **基础类型** | 值本身 | 极小 (寄存器) | 无 |
| **小结构体** | 所有字段 | 小 (寄存器) | 如 `struct {x, y int}`，推荐直接返回 |
| **大结构体** | 所有字段 | **大 (栈拷贝)** | **切记返回指针**，否则性能崩塌 |
| **指针** | 内存地址 | 极小 (寄存器) | 会触发逃逸分析，导致对象分配在堆上 (GC压力) |
| **Slice/Map** | header描述符 | 很小 (3个字长) | 内部是浅拷贝，共享底层数据 |

**一句话总结 Go 的返回值原理：**
Go 永远只做**位拷贝（Bitwise Copy）**。如果是小数据，通过**寄存器**拷贝；如果是大数据，通过**栈内存**拷贝；如果是 Slice/Map，拷贝的是**内部指针头**（表现为浅拷贝）。

这是一个非常经典且触及 Go 语言设计核心的问题。

简单直接的回答是：**在 Go 中，Map、Channel 和 Interface 本质上都是“包含了指针的结构体”（或者直接就是指针的别名）。**

当你“值拷贝”它们时，你**拷贝的是这个内部的指针（或描述符）**，而不是指针指向的那个巨大的底层数据结构。

为了彻底讲清楚，我们需要剥开它们的**运行时（Runtime）源码**外衣，看看它们的真身到底是什么。

---

### 一、 Map 的本质：原本就是一个指针

当我们声明一个 Map 时：`var m map[string]int`，在 Go 的运行时（Runtime）代码中，`map` 实际上是一个指向 `hmap` 结构体的**指针**。

#### 1. 源码证据
在 Go 源码 `runtime/map.go` 中，创建一个 map 的函数签名大致如下：
```go
func makemap(t *maptype, hint int, h *hmap) *hmap
```
注意返回值是 `*hmap`。

#### 2. 拷贝过程
```go
m1 := make(map[string]int) // m1 本质上是一个 *hmap 指针，指向堆上的哈希表
m2 := m1                   // 值拷贝：把 m1 的指针地址（8字节）拷贝给 m2
```
*   **动作**：Go 确实进行了值拷贝，它拷贝了 8 个字节的内存地址。
*   **结果**：`m1` 和 `m2` 是两个独立的指针变量，但它们存储的**地址值相同**，因此指向了同一个 `hmap` 实体。
*   **类比**：你有一把钥匙（m1），你配了一把一模一样的钥匙（m2）。虽然钥匙是两把，但它们开的是同一扇门。

---

### 二、 Channel 的本质：也是一个指针

Channel 与 Map 非常相似。当我们使用 `make(chan int)` 时，得到的是一个指向 `hchan` 结构体的**指针**。

#### 1. 源码证据
在 `runtime/chan.go` 中：
```go
func makechan(t *chantype, size int) *hchan
```
返回值明确是 `*hchan`。

#### 2. 拷贝过程
```go
ch1 := make(chan int) // ch1 是一个 *hchan 指针
ch2 := ch1            // 值拷贝：拷贝了指针地址
```
*   **动作**：拷贝了指针。
*   **结果**：`ch1` 和 `ch2` 指向同一个环形队列（Ring Buffer）和锁对象。
*   **现象**：这就是为什么你在函数里往 `ch2` 发送数据，外面的 `ch1` 能收到。

---

### 三、 Interface 的本质：两个指针（Fat Pointer）

Interface 和 Map/Channel 稍有不同，它不是单指针，而是一个**“胖指针”（Fat Pointer）**，即一个包含两个字段的小结构体。

#### 1. 源码证据
在 `runtime/runtime2.go` 中，接口在运行时的表示是 `iface`（带方法的接口）或 `eface`（空接口 `interface{}`）：

```go
type iface struct {
    tab  *itab          // 1. 指向类型信息（Type Info + 方法表）的指针
    data unsafe.Pointer // 2. 指向具体数据（Concrete Data）的指针
}
```
它的大小是 **2 个机器字长**（在 64 位机器上是 16 字节）。

#### 2. 拷贝过程
```go
var i1 interface{} = MyStruct{Name: "Go"}
i2 := i1 // 值拷贝：拷贝 iface 结构体
```
*   **动作**：Go 进行了值拷贝，将 `i1` 的 `tab` 指针和 `data` 指针完整地拷贝给了 `i2`。
*   **结果**：
    *   `i2` 是一个新的结构体变量。
    *   但是 `i2.data` 和 `i1.data` 指向的是堆内存中同一个 `MyStruct` 实例。
*   **特殊情况**：如果接口里存的是**值类型**（如 `int`），那么 `data` 指针指向的是该值的副本；如果接口里存的是**指针类型**，那么 `data` 指向的就是原指针指向的对象。

---

### 四、 为什么这么设计？

你可能会问：*“既然它们内部是指针，为什么不直接叫引用传递，非要说是值拷贝？”*

这是 Go 语言设计的哲学：**一致性（Consistency）**。

1.  **统一的内存模型**：在 Go 中，`a = b` 永远意味着把 `b` 的内存位模式复制给 `a`。不需要区分“这是引用赋值”还是“这是值赋值”。
    *   对于 `int`，复制数值。
    *   对于 `*int`，复制地址。
    *   对于 `map`（即 `*hmap`），复制地址。
    *   对于 `interface`，复制两个地址。

2.  **隐藏复杂性**：
    *   如果 Map 是纯结构体，每次传递都要拷贝整个哈希表，性能会崩塌。
    *   如果 Go 强迫用户必须写 `*map` 来传递，代码会变得很难看（如 `(*m)["key"]`）。
    *   因此，Go 编译器在类型层面把 `map` 定义为一种隐式的指针类型，既保留了“值拷贝”的简单规则，又获得了“引用传递”的高效性能。

### 总结图表

| 类型 | 变量里的实际内容 | 拷贝发生时 | 结果 (效果) |
| :--- | :--- | :--- | :--- |
| **Slice** | `struct {data*, len, cap}` | 拷贝这 3 个字段 (24字节) | **浅拷贝**。底层数组共享，但容量变化不共享。 |
| **Map** | `*hmap` (指针) | 拷贝 1 个指针 (8字节) | **共享**。完全操作同一个哈希表。 |
| **Channel** | `*hchan` (指针) | 拷贝 1 个指针 (8字节) | **共享**。完全操作同一个队列。 |
| **Interface**| `struct {type*, data*}` | 拷贝这 2 个指针 (16字节) | **共享**。指向同一份数据和类型信息。 |

**一句话总结：**
**Map、Channel、Interface 之所以是“值拷贝”，是因为它们在 Go 语言的定义中，就是用来“包装指针”的轻量级结构体（或直接是指针）。拷贝它们，等于拷贝了“遥控器”，而不是拷贝了“电视机”。**

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-value-assigned)