<div id="chap-goroutine"></div>

[⬆️ 返回目录](#catalog)


## 协程

Go 让线程（M）执行协程（G）的根本原理，可以概括为：**“系统栈调度 + 汇编级别的上下文切换”**。

这并不是操作系统层面的线程切换，而是 Go Runtime 在**用户态**通过修改 CPU 寄存器（主要是栈指针 SP 和指令指针 PC）来实现的“偷天换日”。

以下是 M 执行 G 的完整生命周期闭环：

---

### 1. 核心前提：M 的双重身份

要理解这个过程，必须知道 M（系统线程）身上时刻背着两个“灵魂”：

1.  **`g0`（调度者）**：M 启动时创建的第一个 G，拥有系统大栈（8MB）。M 用它来运行调度逻辑（找任务、垃圾回收、切栈）。
2.  **User G（执行者）**：M 找到的具体的业务协程（如 `go func`），拥有用户小栈（2KB）。

**M 的一生，就是在 `g0` 栈和 User G 栈之间反复横跳。**

---

### 2. 执行循环：`schedule()`

M 启动后，不会执行用户的代码，而是进入一个死循环，这个循环的核心函数叫 `schedule()`。此时 M 运行在 **`g0` 栈**上。

#### 第一步：找工作 (Find Runnable G)
`schedule()` 函数会按照优先级寻找可以运行的 G：
1.  **Check 1**: 看看有没有需要处理的 GC 任务。
2.  **Check 2**: 看看本地队列（P 的 Local Queue）有没有 G？
3.  **Check 3**: 看看全局队列（Global Queue）有没有 G？（需要加锁）
4.  **Check 4**: 去偷别的 P 的任务（Work Stealing）。
5.  **Check 5**: 都没有？去查网路轮询器（Netpoller）有没有就绪的 G。

假设找到了一个协程 `gp`。

---

### 3. 上下文切换：`gogo()` (核心魔法)

找到了 `gp` 后，Runtime 需要把 CPU 的控制权从 `g0` 移交给 `gp`。这是通过汇编函数 `gogo` 完成的。

函数调用链：`schedule()` -> `execute(gp)` -> `gogo(&gp.sched)`

**`gogo` 到底做了什么？（汇编层面）**
它是一段极短的汇编代码，根据 `gp` 里保存的上下文信息（`sched` 字段），直接修改 CPU 寄存器：

1.  **切换栈指针 (SP)**：
    `MOV SP, gp.sched.SP`
    *   也就是把 CPU 的 SP 寄存器，从 `g0` 的栈地址，瞬间指到了 `gp` 的用户栈地址。
2.  **恢复上下文**：
    把 `gp` 之前休眠时保存的通用寄存器（R1, R2...）恢复。
3.  **跳转指令 (PC)**：
    `JMP gp.sched.PC`
    *   把指令指针指向 `gp` 上次停下的代码位置（如果是新创建的 G，就是函数入口）。

**瞬间，CPU 就在执行用户的代码了，而且使用的是用户的栈。操作系统根本不知道发生了这种切换。**

---

### 4. 执行用户代码

此时，M 变成了 `gp` 的载体，逐行执行用户写的代码。

---

### 5. 任务结束：`goexit` (清理与回归)

当用户的函数执行完毕（比如 `return` 了），G 并不是直接消失，它需要通知调度器。

**关键设计**：
在创建 G (`newproc`) 时，Runtime 偷偷在 G 的栈底（Stack Bottom）设置了一个返回地址，指向了 **`runtime.goexit`** 函数。

所以，当用户函数 `return` 时，实际上是“返回”到了 `runtime.goexit`。

**`goexit0` 的工作**：
1.  **切回 `g0` 栈**：通过汇编 `systemstack` 切回系统栈。
2.  **清理 G**：把 `gp` 的状态置为 `_Gdead`，清空字段。
3.  **解绑**：把 G 和 M 解绑。
4.  **放入空闲列表**：把这个死掉的 G 放入 `P` 的 `gFree` 列表（复用对象，不直接释放内存）。
5.  **再次调用 `schedule()`**：
    M 喊道：“下一个！” -> 回到步骤 2。

---

### 总结图解

可以将 M 想象成一个**工人**，G 是**任务单**。

1.  **在休息室 (`g0` 栈)**：
    工人（M）看着墙上的任务板（调度器），挑了一张任务单（G）。
2.  **前往工位 (上下文切换 `gogo`)**：
    工人拿起任务单，把工具箱（寄存器）换成任务单要求的工具，走到特定的工位（User Stack）。
3.  **干活 (执行 User Code)**：
    工人按照任务单干活。
4.  **完工 (User Return)**：
    活干完了，任务单上最后一行写着：“请回休息室”。
5.  **回休息室 (`goexit`)**：
    工人扔掉废弃的任务单，走回休息室，准备领下一个任务。

**这就是 Go 让线程执行协程的原理：M 在一个死循环中，不断地利用汇编指令，在系统栈（找任务）和用户栈（做任务）之间来回切换。**

你的理解非常准确，甚至触及了 Go 运行时（Runtime）设计的核心。

是的，Go 确实完全接管了这两件事：
1.  **内存管理**：在堆上分配了一块内存作为“用户栈”。
2.  **上下文管理**：手动保存和恢复寄存器状态。

但在**“内存状态”**这一点上，可能和你想象的操作系统层面的切换有一点细微的区别。

下面我针对你提出的三个点（堆上栈、寄存器兼容性、内存状态）进行深度拆解。

---

### 1. 关于“在堆上分配用户栈”

**你说得对。**

在操作系统看来，Go 程序只申请了一大堆内存（Heap）。Go 运行时在这堆内存里“切”出来一小块一小块的内存段，假装它们是“栈”，分配给 Goroutine 使用。

*   **初始大小**：通常是 2KB。
*   **本质**：对于 CPU 而言，栈只是 `SP` (Stack Pointer) 寄存器指向的一块内存地址。只要把 SP 指向堆上的某块地址，CPU 就认为那里是栈。
*   **扩容**：因为这块内存是 Go 自己管理的（而不是 OS 分配的固定线程栈），所以当 2KB 用完了，Go 会在堆上申请一块更大的（比如 4KB），把旧数据**拷贝**过去，然后修改 SP 指针。这就是**连续栈（Contiguous Stack）**技术。

---

### 2. 关于“自己保存寄存器状态（兼容硬件）”

**你是对的，这完全依赖于 Go 团队编写的汇编代码。**

Go 并不像 Java 那样依赖虚拟机的字节码指令集，而是直接编译成机器码。因此，Go 必须针对每种 CPU 架构手写汇编来实现上下文切换。

#### A. 存在哪里？ (`gobuf`)
每个 Goroutine 的结构体 `g` 中，都有一个字段叫 `sched`，它的类型是 `gobuf`。这相当于一个“存档点”。

```go
// src/runtime/runtime2.go
type gobuf struct {
    sp   uintptr  // Stack Pointer (栈顶在哪)
    pc   uintptr  // Program Counter (执行到哪条指令了)
    g    guintptr // 反向引用所属的 g
    ctxt unsafe.Pointer
    ret  uintptr
    lr   uintptr
    bp   uintptr  // Base Pointer (栈底/帧指针)
}
```
你看，这里只保存了极少数几个关键寄存器（SP, PC, BP）。**并没有保存 CPU 所有的通用寄存器**。
*   **为什么？** 为了快。Go 遵循函数调用约定（Calling Convention/ABI）。Go 只有在特定的“安全点”（通常是函数调用或主动挂起时）才会切换协程。根据约定，此时大部分临时寄存器本来就是“易失”的，不需要保存，只需要保存这一套“骨架”寄存器即可恢复现场。

#### B. 怎么兼容不同硬件？
Go 的源码目录下 `src/runtime/` 里有一大堆汇编文件，文件名后缀决定了架构：
*   `sys_amd64.s` (针对 x86-64)
*   `sys_arm64.s` (针对 ARM64)
*   `sys_riscv64.s` (针对 RISC-V)

**编译时**，Go 编译器会根据你的目标平台（`GOARCH`），选择对应的汇编文件编译进去。
例如，`gogo` 函数在 `amd64` 下的操作是操作 `RSP`, `RIP` 寄存器，而在 `arm64` 下则是操作 `SP`, `LR`, `PC` 寄存器。**兼容性是用“穷举法”手写汇编解决的。**

---

### 3. 关于“内存状态”

这一点需要澄清：**Go 协程切换时，不需要切换“内存状态”。**

这里的“内存状态”通常指 **页表（Page Table）、TLB（快表）、CR3 寄存器** 等虚拟内存映射关系。

*   **进程切换 (Process Switch)**：OS 需要切换页表（CR3），因为不同进程的虚拟地址空间是隔离的。这非常慢，会导致 TLB 失效，CPU 缓存变凉。
*   **线程切换 (Thread Switch)**：OS 不需要切换页表（共享进程内存），但需要切入内核态（Ring 0），涉及很多系统寄存器的保存。
*   **协程切换 (Goroutine Switch)**：
    *   **完全在用户态 (Ring 3)**。
    *   **共享所有内存**：所有的 Goroutine 都跑在同一个进程里，大家都共用同一张页表。
    *   **所谓的“切换内存”**：仅仅是把 CPU 的 **SP 寄存器** 的值，从地址 A（协程 1 的栈）改成了地址 B（协程 2 的栈）。

**结论**：对于 CPU 来说，它看到的内存视图（Virtual Memory View）完全没变，只是读写的“栈位置”变了而已。

---

### 总结：Go 是如何欺骗 CPU 的？

Go 的 Runtime 就像一个魔术师，它做了一个精妙的骗局：

1.  **假栈**：在堆上申请一块内存 `0x8000`，告诉 CPU：“这就是你的栈，SP 指向这里”。
2.  **假上下文**：当需要暂停时，把 CPU 的 SP、PC 寄存器抄写到结构体 `g.sched` 里。
3.  **假切换**：当需要恢复另一个 G 时，根据编译时选好的汇编指令（兼容硬件），把另一个 `g.sched` 里的值强行塞回 CPU 寄存器。
4.  **内存不变**：因为大家都在同一个屋檐下（同一个进程），不需要动用操作系统最昂贵的内存映射切换。

这就是为什么 Goroutine 切换只需要 **~200 纳秒**，而线程切换需要 **~2 微秒** 的根本原因。



<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-goroutine)