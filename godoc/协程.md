<div id="chap-goroutine"></div>

[⬆️ 返回目录](#catalog)


## 协程

Go 让线程（M）执行协程（G）的根本原理，可以概括为：**“系统栈调度 + 汇编级别的上下文切换”**。

这并不是操作系统层面的线程切换，而是 Go Runtime 在**用户态**通过修改 CPU 寄存器（主要是栈指针 SP 和指令指针 PC）来实现的“偷天换日”。

以下是 M 执行 G 的完整生命周期闭环：

---

### 1. 核心前提：M 的双重身份

要理解这个过程，必须知道 M（系统线程）身上时刻背着两个“灵魂”：

1.  **`g0`（调度者）**：M 启动时创建的第一个 G，拥有系统大栈（8MB）。M 用它来运行调度逻辑（找任务、垃圾回收、切栈）。
2.  **User G（执行者）**：M 找到的具体的业务协程（如 `go func`），拥有用户小栈（2KB）。

**M 的一生，就是在 `g0` 栈和 User G 栈之间反复横跳。**

---

### 2. 执行循环：`schedule()`

M 启动后，不会执行用户的代码，而是进入一个死循环，这个循环的核心函数叫 `schedule()`。此时 M 运行在 **`g0` 栈**上。

#### 第一步：找工作 (Find Runnable G)
`schedule()` 函数会按照优先级寻找可以运行的 G：
1.  **Check 1**: 看看有没有需要处理的 GC 任务。
2.  **Check 2**: 看看本地队列（P 的 Local Queue）有没有 G？
3.  **Check 3**: 看看全局队列（Global Queue）有没有 G？（需要加锁）
4.  **Check 4**: 去偷别的 P 的任务（Work Stealing）。
5.  **Check 5**: 都没有？去查网路轮询器（Netpoller）有没有就绪的 G。

假设找到了一个协程 `gp`。

---

### 3. 上下文切换：`gogo()` (核心魔法)

找到了 `gp` 后，Runtime 需要把 CPU 的控制权从 `g0` 移交给 `gp`。这是通过汇编函数 `gogo` 完成的。

函数调用链：`schedule()` -> `execute(gp)` -> `gogo(&gp.sched)`

**`gogo` 到底做了什么？（汇编层面）**
它是一段极短的汇编代码，根据 `gp` 里保存的上下文信息（`sched` 字段），直接修改 CPU 寄存器：

1.  **切换栈指针 (SP)**：
    `MOV SP, gp.sched.SP`
    *   也就是把 CPU 的 SP 寄存器，从 `g0` 的栈地址，瞬间指到了 `gp` 的用户栈地址。
2.  **恢复上下文**：
    把 `gp` 之前休眠时保存的通用寄存器（R1, R2...）恢复。
3.  **跳转指令 (PC)**：
    `JMP gp.sched.PC`
    *   把指令指针指向 `gp` 上次停下的代码位置（如果是新创建的 G，就是函数入口）。

**瞬间，CPU 就在执行用户的代码了，而且使用的是用户的栈。操作系统根本不知道发生了这种切换。**

---

### 4. 执行用户代码

此时，M 变成了 `gp` 的载体，逐行执行用户写的代码。

---

### 5. 任务结束：`goexit` (清理与回归)

当用户的函数执行完毕（比如 `return` 了），G 并不是直接消失，它需要通知调度器。

**关键设计**：
在创建 G (`newproc`) 时，Runtime 偷偷在 G 的栈底（Stack Bottom）设置了一个返回地址，指向了 **`runtime.goexit`** 函数。

所以，当用户函数 `return` 时，实际上是“返回”到了 `runtime.goexit`。

**`goexit0` 的工作**：
1.  **切回 `g0` 栈**：通过汇编 `systemstack` 切回系统栈。
2.  **清理 G**：把 `gp` 的状态置为 `_Gdead`，清空字段。
3.  **解绑**：把 G 和 M 解绑。
4.  **放入空闲列表**：把这个死掉的 G 放入 `P` 的 `gFree` 列表（复用对象，不直接释放内存）。
5.  **再次调用 `schedule()`**：
    M 喊道：“下一个！” -> 回到步骤 2。

---

### 总结图解

可以将 M 想象成一个**工人**，G 是**任务单**。

1.  **在休息室 (`g0` 栈)**：
    工人（M）看着墙上的任务板（调度器），挑了一张任务单（G）。
2.  **前往工位 (上下文切换 `gogo`)**：
    工人拿起任务单，把工具箱（寄存器）换成任务单要求的工具，走到特定的工位（User Stack）。
3.  **干活 (执行 User Code)**：
    工人按照任务单干活。
4.  **完工 (User Return)**：
    活干完了，任务单上最后一行写着：“请回休息室”。
5.  **回休息室 (`goexit`)**：
    工人扔掉废弃的任务单，走回休息室，准备领下一个任务。

**这就是 Go 让线程执行协程的原理：M 在一个死循环中，不断地利用汇编指令，在系统栈（找任务）和用户栈（做任务）之间来回切换。**

你的理解非常准确，甚至触及了 Go 运行时（Runtime）设计的核心。

是的，Go 确实完全接管了这两件事：
1.  **内存管理**：在堆上分配了一块内存作为“用户栈”。
2.  **上下文管理**：手动保存和恢复寄存器状态。

但在**“内存状态”**这一点上，可能和你想象的操作系统层面的切换有一点细微的区别。

下面我针对你提出的三个点（堆上栈、寄存器兼容性、内存状态）进行深度拆解。

---

### 1. 关于“在堆上分配用户栈”

**你说得对。**

在操作系统看来，Go 程序只申请了一大堆内存（Heap）。Go 运行时在这堆内存里“切”出来一小块一小块的内存段，假装它们是“栈”，分配给 Goroutine 使用。

*   **初始大小**：通常是 2KB。
*   **本质**：对于 CPU 而言，栈只是 `SP` (Stack Pointer) 寄存器指向的一块内存地址。只要把 SP 指向堆上的某块地址，CPU 就认为那里是栈。
*   **扩容**：因为这块内存是 Go 自己管理的（而不是 OS 分配的固定线程栈），所以当 2KB 用完了，Go 会在堆上申请一块更大的（比如 4KB），把旧数据**拷贝**过去，然后修改 SP 指针。这就是**连续栈（Contiguous Stack）**技术。

---

### 2. 关于“自己保存寄存器状态（兼容硬件）”

**你是对的，这完全依赖于 Go 团队编写的汇编代码。**

Go 并不像 Java 那样依赖虚拟机的字节码指令集，而是直接编译成机器码。因此，Go 必须针对每种 CPU 架构手写汇编来实现上下文切换。

#### A. 存在哪里？ (`gobuf`)
每个 Goroutine 的结构体 `g` 中，都有一个字段叫 `sched`，它的类型是 `gobuf`。这相当于一个“存档点”。

```go
// src/runtime/runtime2.go
type gobuf struct {
    sp   uintptr  // Stack Pointer (栈顶在哪)
    pc   uintptr  // Program Counter (执行到哪条指令了)
    g    guintptr // 反向引用所属的 g
    ctxt unsafe.Pointer
    ret  uintptr
    lr   uintptr
    bp   uintptr  // Base Pointer (栈底/帧指针)
}
```
你看，这里只保存了极少数几个关键寄存器（SP, PC, BP）。**并没有保存 CPU 所有的通用寄存器**。
*   **为什么？** 为了快。Go 遵循函数调用约定（Calling Convention/ABI）。Go 只有在特定的“安全点”（通常是函数调用或主动挂起时）才会切换协程。根据约定，此时大部分临时寄存器本来就是“易失”的，不需要保存，只需要保存这一套“骨架”寄存器即可恢复现场。

#### B. 怎么兼容不同硬件？
Go 的源码目录下 `src/runtime/` 里有一大堆汇编文件，文件名后缀决定了架构：
*   `sys_amd64.s` (针对 x86-64)
*   `sys_arm64.s` (针对 ARM64)
*   `sys_riscv64.s` (针对 RISC-V)

**编译时**，Go 编译器会根据你的目标平台（`GOARCH`），选择对应的汇编文件编译进去。
例如，`gogo` 函数在 `amd64` 下的操作是操作 `RSP`, `RIP` 寄存器，而在 `arm64` 下则是操作 `SP`, `LR`, `PC` 寄存器。**兼容性是用“穷举法”手写汇编解决的。**

---

### 3. 关于“内存状态”

这一点需要澄清：**Go 协程切换时，不需要切换“内存状态”。**

这里的“内存状态”通常指 **页表（Page Table）、TLB（快表）、CR3 寄存器** 等虚拟内存映射关系。

*   **进程切换 (Process Switch)**：OS 需要切换页表（CR3），因为不同进程的虚拟地址空间是隔离的。这非常慢，会导致 TLB 失效，CPU 缓存变凉。
*   **线程切换 (Thread Switch)**：OS 不需要切换页表（共享进程内存），但需要切入内核态（Ring 0），涉及很多系统寄存器的保存。
*   **协程切换 (Goroutine Switch)**：
    *   **完全在用户态 (Ring 3)**。
    *   **共享所有内存**：所有的 Goroutine 都跑在同一个进程里，大家都共用同一张页表。
    *   **所谓的“切换内存”**：仅仅是把 CPU 的 **SP 寄存器** 的值，从地址 A（协程 1 的栈）改成了地址 B（协程 2 的栈）。

**结论**：对于 CPU 来说，它看到的内存视图（Virtual Memory View）完全没变，只是读写的“栈位置”变了而已。

---

### 总结：Go 是如何欺骗 CPU 的？

Go 的 Runtime 就像一个魔术师，它做了一个精妙的骗局：

1.  **假栈**：在堆上申请一块内存 `0x8000`，告诉 CPU：“这就是你的栈，SP 指向这里”。
2.  **假上下文**：当需要暂停时，把 CPU 的 SP、PC 寄存器抄写到结构体 `g.sched` 里。
3.  **假切换**：当需要恢复另一个 G 时，根据编译时选好的汇编指令（兼容硬件），把另一个 `g.sched` 里的值强行塞回 CPU 寄存器。
4.  **内存不变**：因为大家都在同一个屋檐下（同一个进程），不需要动用操作系统最昂贵的内存映射切换。

这就是为什么 Goroutine 切换只需要 **~200 纳秒**，而线程切换需要 **~2 微秒** 的根本原因。

P（Processor）的本地队列**直接脱离** M（Machine，线程）运行，这种情况在 Go 的调度机制中被称为 **P 的“抢占”或“剥离”（Handoff / Retake）**。

这主要发生在一个核心场景：**M 陷入了操作系统内核层面的“真阻塞”**，导致 M 没法回来处理 P 队列里剩下的其他 G 了。为了不让 P 里的其他 G 饿死，调度器会强制把 P 拿走，给别的 M 去跑。

以下是具体的触发场景和底层机制：

---

### 1. 阻塞式系统调用 (Blocking System Call) —— 最主要的情况

这是 P 脱离 M 最常见的场景。注意，不是所有的系统调用都会导致脱离，只有那些**耗时较长**或**真正阻塞**的调用。

*   **场景**：比如进行**文件 I/O**（磁盘读写通常没有像网络那样的 epoll 机制）、发送复杂的信号等。
*   **过程**：
    1.  **entersyscall**：当 G1 调用系统调用时，M 会执行 `entersyscall` 函数。
    2.  **标记**：M 会把 P 的状态标记为 `_Psyscall`。这意味着：“我（M）进内核办事了，这个 P 暂时没人管，但如果我回来得快，我还认它。”
    3.  **Sysmon 介入**：Go 有一个后台监控线程叫 **sysmon**。它会不断巡视。
    4.  **超时剥离**：如果 sysmon 发现这个 P 处于 `_Psyscall` 状态太久（超过 20us ~ 10ms，取决于版本和负载），它就会认为 M 被内核卡住了。
    5.  **Retake**：sysmon 会执行 `retake` 操作，把 P 从这个阻塞的 M 身上“抢”走。
    6.  **寻找新 M**：sysmon 会唤醒或创建一个新的 M，把这个 P 交给新 M。
    7.  **P 继续运行**：P 队列里剩下的 G 就在新 M 上继续跑了。
*   **结局**：原来的 M 从系统调用回来后，发现 P 没了（被抢了），它就只能把 G1 放到全局队列，然后自己去休眠或者找空闲的 P。

### 2. CGO 调用 (CGO Calls)

CGO 的机制和系统调用非常相似。

*   **场景**：Go 代码调用 C 语言的代码。
*   **原因**：Go 运行时不知道 C 代码会执行多久，也不知道它会不会阻塞。C 代码执行期间不归 Go 调度器管。
*   **过程**：
    *   当进入 CGO 调用时，M 也会进入类似系统调用的状态。
    *   如果 C 代码执行时间稍长，**sysmon** 也会毫不留情地把 P 抢走，让 P 去服务其他的 G。
    *   执行 C 代码的那个 M 就变成了“专职服务员”，只伺候当前的 C 函数，直到返回。

### 3. runtime.LockOSThread() (绑定线程)

这是一个特殊的 API，用于强制将 G 绑定到当前的 M 上。

*   **场景**：某个 G 需要使用依赖线程局部存储（Thread Local Storage, TLS）的库（比如某些图形库 OpenGL）。
*   **过程**：
    *   当 G 调用 `LockOSThread()` 后，它就锁定了当前的 M。
    *   如果这个 G 此时被阻塞了（比如 `gopark`），或者它主动让出（`Gosched`），这个 M **不能**去执行 P 队列里的其他 G（因为其他 G 没绑定这个 M）。
    *   为了不让 P 闲置，M 会主动把 P 交出来（Handoff），让别的 M 来接管这个 P。

---

### 注意：网络 I/O 通常不会导致 P 脱离

这是一个常见的误区。
*   **场景**：`net.Conn.Read()` 等网络请求。
*   **机制**：Go 的网络库在 Linux 上使用的是 **epoll**（非阻塞 I/O）。
*   **过程**：当 G 进行网络读取时，文件描述符是 set non-blocking 的。调用会立即返回“未就绪”错误。Go 运行时会把 G 扔给 **Netpoller**，然后 **M 不会阻塞**，M 会直接去 P 的队列拿下一个 G 跑。
*   **结论**：这种情况下，M 没有被卡住，所以 **P 不需要脱离 M**。

---

### 总结对比

| 阻塞类型 | M 的状态 | P 的状态 | 是否脱离 |
| :--- | :--- | :--- | :--- |
| **Go 层面阻塞** <br>(Lock, Channel, Sleep) | **不阻塞**。M 切换 G，继续跑 P 队列里的下一个。 | 依然绑定 M | **否** |
| **网络 I/O 阻塞** <br>(Netpoller) | **不阻塞**。M 切换 G，继续跑 P 队列里的下一个。 | 依然绑定 M | **否** |
| **系统调用阻塞** <br>(File I/O, CGO) | **阻塞**。M 停在内核态或 C 代码里动不了。 | **P 被 sysmon 抢走**，交给新 M。 | **是 (脱离)** |

所以，P 脱离 M 的核心原因是：**M 彻底没空了（被操作系统卡住了），为了保证 P 队列里的其他协程能有 CPU 吃，必须把 P 转移走。**


P（Processor）的本地队列**直接脱离** M（Machine，线程）运行，这种情况在 Go 的调度机制中被称为 **P 的“抢占”或“剥离”（Handoff / Retake）**。

这主要发生在一个核心场景：**M 陷入了操作系统内核层面的“真阻塞”**，导致 M 没法回来处理 P 队列里剩下的其他 G 了。为了不让 P 里的其他 G 饿死，调度器会强制把 P 拿走，给别的 M 去跑。

以下是具体的触发场景和底层机制：

---

### 1. 阻塞式系统调用 (Blocking System Call) —— 最主要的情况

这是 P 脱离 M 最常见的场景。注意，不是所有的系统调用都会导致脱离，只有那些**耗时较长**或**真正阻塞**的调用。

*   **场景**：比如进行**文件 I/O**（磁盘读写通常没有像网络那样的 epoll 机制）、发送复杂的信号等。
*   **过程**：
    1.  **entersyscall**：当 G1 调用系统调用时，M 会执行 `entersyscall` 函数。
    2.  **标记**：M 会把 P 的状态标记为 `_Psyscall`。这意味着：“我（M）进内核办事了，这个 P 暂时没人管，但如果我回来得快，我还认它。”
    3.  **Sysmon 介入**：Go 有一个后台监控线程叫 **sysmon**。它会不断巡视。
    4.  **超时剥离**：如果 sysmon 发现这个 P 处于 `_Psyscall` 状态太久（超过 20us ~ 10ms，取决于版本和负载），它就会认为 M 被内核卡住了。
    5.  **Retake**：sysmon 会执行 `retake` 操作，把 P 从这个阻塞的 M 身上“抢”走。
    6.  **寻找新 M**：sysmon 会唤醒或创建一个新的 M，把这个 P 交给新 M。
    7.  **P 继续运行**：P 队列里剩下的 G 就在新 M 上继续跑了。
*   **结局**：原来的 M 从系统调用回来后，发现 P 没了（被抢了），它就只能把 G1 放到全局队列，然后自己去休眠或者找空闲的 P。

### 2. CGO 调用 (CGO Calls)

CGO 的机制和系统调用非常相似。

*   **场景**：Go 代码调用 C 语言的代码。
*   **原因**：Go 运行时不知道 C 代码会执行多久，也不知道它会不会阻塞。C 代码执行期间不归 Go 调度器管。
*   **过程**：
    *   当进入 CGO 调用时，M 也会进入类似系统调用的状态。
    *   如果 C 代码执行时间稍长，**sysmon** 也会毫不留情地把 P 抢走，让 P 去服务其他的 G。
    *   执行 C 代码的那个 M 就变成了“专职服务员”，只伺候当前的 C 函数，直到返回。

### 3. runtime.LockOSThread() (绑定线程)

这是一个特殊的 API，用于强制将 G 绑定到当前的 M 上。

*   **场景**：某个 G 需要使用依赖线程局部存储（Thread Local Storage, TLS）的库（比如某些图形库 OpenGL）。
*   **过程**：
    *   当 G 调用 `LockOSThread()` 后，它就锁定了当前的 M。
    *   如果这个 G 此时被阻塞了（比如 `gopark`），或者它主动让出（`Gosched`），这个 M **不能**去执行 P 队列里的其他 G（因为其他 G 没绑定这个 M）。
    *   为了不让 P 闲置，M 会主动把 P 交出来（Handoff），让别的 M 来接管这个 P。

---

### 注意：网络 I/O 通常不会导致 P 脱离

这是一个常见的误区。
*   **场景**：`net.Conn.Read()` 等网络请求。
*   **机制**：Go 的网络库在 Linux 上使用的是 **epoll**（非阻塞 I/O）。
*   **过程**：当 G 进行网络读取时，文件描述符是 set non-blocking 的。调用会立即返回“未就绪”错误。Go 运行时会把 G 扔给 **Netpoller**，然后 **M 不会阻塞**，M 会直接去 P 的队列拿下一个 G 跑。
*   **结论**：这种情况下，M 没有被卡住，所以 **P 不需要脱离 M**。

---

### 总结对比

| 阻塞类型 | M 的状态 | P 的状态 | 是否脱离 |
| :--- | :--- | :--- | :--- |
| **Go 层面阻塞** <br>(Lock, Channel, Sleep) | **不阻塞**。M 切换 G，继续跑 P 队列里的下一个。 | 依然绑定 M | **否** |
| **网络 I/O 阻塞** <br>(Netpoller) | **不阻塞**。M 切换 G，继续跑 P 队列里的下一个。 | 依然绑定 M | **否** |
| **系统调用阻塞** <br>(File I/O, CGO) | **阻塞**。M 停在内核态或 C 代码里动不了。 | **P 被 sysmon 抢走**，交给新 M。 | **是 (脱离)** |

所以，P 脱离 M 的核心原因是：**M 彻底没空了（被操作系统卡住了），为了保证 P 队列里的其他协程能有 CPU 吃，必须把 P 转移走。**


<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-goroutine)