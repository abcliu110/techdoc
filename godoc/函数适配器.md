<div id="chap-functionadapter"></div>

[⬆️ 返回目录](#catalog)


## 函数适配器

这是一个非常经典的 Go 设计模式，通常被称为**“函数适配器”（Function Adapter）**。

你理解得很对：**把函数定义为类型，就能给它挂载方法；一旦挂载了方法，它就能实现接口。**

这使得我们可以把一个普通的函数，“伪装”成一个复杂的接口实现类来使用。最著名的例子就是标准库中的 `http.HandlerFunc`。

下面我通过**自定义示例**和**标准库示例**两个角度来解释。

---

### 示例一：自定义一个“处理器”接口

假设我们要设计一个通用的接口，用来处理字符串。

#### 1. 定义接口
这是我们要满足的目标接口：
```go
// Handler 是一个接口，规定必须有一个 Handle 方法
type Handler interface {
    Handle(content string)
}
```

#### 2. 传统做法（使用 Struct）
如果不用函数类型，我们需要定义一个结构体来实现它，哪怕逻辑很简单：
```go
type MyStructHandler struct {}

func (m *MyStructHandler) Handle(content string) {
    fmt.Println("Struct handling:", content)
}

// 使用：
// var h Handler = &MyStructHandler{}
```
*痛点：为了写一行逻辑，还得专门造个结构体，太繁琐。*

#### 3. 妙用：把函数定义为类型（函数适配器）
我们可以定义一个函数类型，并让这个**函数类型**去实现接口：

```go
package main

import "fmt"

// 1. 定义接口
type Handler interface {
    Handle(content string)
}

// 2. 定义一个函数类型，它的签名和接口里的方法核心逻辑一致
type HandlerFunc func(content string)

// 3. 【关键】给这个函数类型添加方法，实现接口
// 它的实现逻辑非常简单：就是把自己调用一遍
func (f HandlerFunc) Handle(content string) {
    f(content) // 调用函数本体
}

// 4. 一个普通的函数，逻辑符合 HandlerFunc 的签名
func myLogic(s string) {
    fmt.Println("Function logic handling:", s)
}

func main() {
    // 场景：我们需要一个 Handler 接口
    var h Handler

    // 魔法时刻：
    // 我们把普通函数 myLogic 强转为 HandlerFunc 类型
    // 因为 HandlerFunc 实现了 Handler 接口，所以它可以赋值给 h
    h = HandlerFunc(myLogic)

    // 调用接口方法 -> 实际上调用了 HandlerFunc.Handle -> 实际上调用了 myLogic
    h.Handle("Hello World")
    
    // 甚至可以使用匿名函数
    h2 := HandlerFunc(func(s string) {
        fmt.Println("Anonymous function:", s)
    })
    h2.Handle("Go is cool")
}
```

**原理总结：**
`HandlerFunc(myLogic)` 把纯函数变成了带有 `Handle` 方法的对象，从而满足了 `Handler` 接口。

---

### 示例二：标准库中的 `http.Handler` (最经典案例)

Go 的 HTTP 服务是这个模式的最佳代言人。

#### 1. 接口定义
标准库 `net/http` 定义了一个接口：
```go
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```

#### 2. 函数适配器定义
标准库同时也定义了一个帮助类型 `HandlerFunc`：
```go
// 定义函数类型
type HandlerFunc func(ResponseWriter, *Request)

// 让函数类型实现接口
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r) // 调用自己
}
```

#### 3. 实际应用
这使得我们可以用极简的方式写 Web 服务，而不需要为每个路由都定义一个结构体。

```go
package main

import (
	"fmt"
	"net/http"
)

// 这是一个普通的函数
func hello(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hello, Function Adapter!")
}

func main() {
	// http.Handle 需要接收一个 Handler 接口
	
	// 写法 A: 显式转换
	// 把 hello 函数转换成 http.HandlerFunc 类型，它就有了 ServeHTTP 方法，就是 Handler 了
	http.Handle("/hello", http.HandlerFunc(hello))

	// 写法 B: http.HandleFunc (标准库提供的语法糖)
	// 这个函数内部其实就是帮我不做了 "HandlerFunc(hello)" 这一步转换
	http.HandleFunc("/world", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintf(w, "World!")
	})

	http.ListenAndServe(":8080", nil)
}
```

---

### 为什么要这么做？有什么好处？

#### 1. 让代码极其简洁（避免 Struct 爆炸）
如果没有这个机制，你每写一个简单的回调逻辑，都得定义一个 `struct`，实现一个方法。有了这个机制，你可以直接传入一个函数（或闭包），代码量减少一半以上。

#### 2. 利用闭包持有状态（替代 Struct 字段）
`struct` 可以通过字段存状态，**函数可以通过闭包存状态**。
配合这个模式，我们可以写出很优雅的**中间件**或**配置器**。

**举例：带状态的 Handler**

```go
// 生成一个 Handler，但是带了一个 database 连接作为闭包变量
func dbHandler(dbName string) http.Handler {
    // 返回一个匿名函数，强转为 HandlerFunc
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 这里可以直接用外面的 dbName
        fmt.Fprintf(w, "Writing to database: %s", dbName)
    })
}

// 使用
http.Handle("/db", dbHandler("MySQL_Prod"))
```
这里我们没有定义任何 Struct 结构体，却实现了一个带有内部状态（dbName）的对象，并满足了接口。

### 总结

*   **技术手段**：`type MyFunc func(...)` -> `func (f MyFunc) Method(...) { f(...) }`。
*   **核心目的**：让**单一功能的函数**能够直接满足**接口契约**。
*   **应用场景**：回调函数、HTTP 处理器、中间件、简单的策略模式实现。

这是一种将“函数式编程”的便利性融入到“面向接口编程”的严谨性中的完美胶水代码。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-functionadapter)