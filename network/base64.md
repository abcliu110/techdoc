<div id="chap-base64"></div>

[⬆️ 返回目录](#catalog)


## base64

在使用**分隔符（Delimiter Based）**方案解决粘包问题时，如果消息体（Body）本身包含了分隔符，就会导致接收端提前截断消息，产生逻辑错误。

为了解决这个问题，通常采用 **Base64 编码** 或 **转义字符（Escaping/Byte Stuffing）**。以下是这两种方案的具体实施细节、代码示例以及性能权衡。

---

### 方案一：Base64 编码 (最简单，但带宽开销大)

Base64 是一种将二进制数据转换为 ASCII 字符（A-Z, a-z, 0-9, +, /）的编码方式。
**核心原理**：Base64 字符集中**天然不包含**常见的控制字符（如换行符 `\n`、回车符 `\r` 或空字符 `\0`）。因此，你可以安全地将 Base64 编码后的字符串作为 Body，并在末尾加上 `\n` 作为分隔符。

#### 1. 具体实施步骤
假设分隔符是 `\n` (换行符)。

*   **发送端**：
    1.  准备原始二进制数据 `RawData`。
    2.  执行 `Base64Encode(RawData)` 得到字符串。
    3.  在字符串末尾追加 `\n`。
    4.  发送。
*   **接收端**：
    1.  读取数据流，直到遇到 `\n`。
    2.  去掉末尾的 `\n`。
    3.  执行 `Base64Decode(String)` 还原为 `RawData`。

#### 2. 代码示例 (Python)
```python
import base64

# --- 发送端 ---
raw_data = b"Hello\nWorld" # 原始数据包含分隔符 \n
encoded_body = base64.b64encode(raw_data) # 结果: b'SGVsbG8KV29ybGQ='
packet = encoded_body + b'\n' # 加入分隔符
# 发送 packet...

# --- 接收端 ---
# 假设收到了 packet
received_body = packet.strip() # 去掉 \n
decoded_data = base64.b64decode(received_body)
print(decoded_data) # 输出: b"Hello\nWorld"
```

#### 3. 优缺点分析
*   **优点**：实现极简单，所有语言都有标准库支持；调试方便（传输的是可见字符）。
*   **缺点（开销大）**：
    *   **数据体积增加 33%**：Base64 将每 3 个字节变成 4 个字符。如果你传 100MB 文件，实际传输 133MB。
    *   **CPU 开销**：编解码需要消耗 CPU 资源。

---

### 方案二：转义字符 / 字节填充 (Byte Stuffing) (带宽最高效，实现较复杂)

这是经典协议（如 HDLC、PPP、SLIP）使用的方案。
**核心原理**：定义一个**转义字符（Escape Character）**。如果在数据中遇到了“分隔符”或“转义字符本身”，就在它前面加一个转义字符，并对其进行变形。

#### 1. 具体实施步骤 (以 SLIP 协议逻辑为例)
假设：
*   **分隔符 (END)** = `0xC0` (十进制 192)
*   **转义符 (ESC)** = `0xDB` (十进制 219)

**发送端规则**：
遍历数据中的每一个字节：
1.  如果字节是 `0xC0` (分隔符) -> 写入 `0xDB`, `0xDC`。
2.  如果字节是 `0xDB` (转义符本身) -> 写入 `0xDB`, `0xDD`。
3.  如果是其他字节 -> 直接写入。
4.  最后发送 `0xC0` 表示包结束。

**接收端规则**：
遍历接收到的字节流：
1.  遇到 `0xC0` -> **消息结束**，处理当前包。
2.  遇到 `0xDB` -> **进入转义状态**，读取下一个字节：
    *   如果是 `0xDC` -> 存入 `0xC0`。
    *   如果是 `0xDD` -> 存入 `0xDB`。
3.  遇到普通字节 -> 直接存入缓冲区。

#### 2. 代码示例 (伪代码/逻辑演示)

```python
# 定义常量
DELIMITER = 0xC0
ESCAPE    = 0xDB
ESC_END   = 0xDC
ESC_ESC   = 0xDD

def encode(data: bytes) -> bytes:
    output = bytearray()
    for byte in data:
        if byte == DELIMITER:
            # 遇到分隔符，转义为 ESC + ESC_END
            output.append(ESCAPE)
            output.append(ESC_END)
        elif byte == ESCAPE:
            # 遇到转义符本身，转义为 ESC + ESC_ESC
            output.append(ESCAPE)
            output.append(ESC_ESC)
        else:
            output.append(byte)
    
    output.append(DELIMITER) # 添加包尾
    return output

def decode(stream_data) -> bytes:
    output = bytearray()
    is_escaping = False
    
    for byte in stream_data:
        if byte == DELIMITER:
            return output # 包结束
            
        if is_escaping:
            if byte == ESC_END:
                output.append(DELIMITER)
            elif byte == ESC_ESC:
                output.append(ESCAPE)
            is_escaping = False
        elif byte == ESCAPE:
            is_escaping = True
        else:
            output.append(byte)
            
    return output
```

#### 3. 优缺点分析
*   **优点**：
    *   **带宽开销极小**：在数据不包含特殊字符时，开销为 0。只有遇到特殊字符才增加 1 个字节。
    *   **流式处理**：不需要像 Base64 那样把整个包读完再解码，可以逐字节处理。
*   **缺点**：
    *   **实现复杂**：容易写出 Bug（特别是处理边界情况）。
    *   **内存拷贝**：需要在发送端扫描并重组数据，无法直接利用 `Zero-Copy` 技术（如 `sendfile`）。

---

### 方案三：长度前缀 (Length Field) —— 再次推荐

既然你担心 Base64 的**体积开销**，又觉得转义字符**处理开销（算法复杂度）**麻烦，那么**方案一（长度字段）**其实是唯一能同时解决这两个问题的方案。

*   **无体积膨胀**：无论发什么数据，头部只固定增加 4 字节。
*   **无 CPU 编解码开销**：不需要扫描整个数据体进行 Base64 或转义，只需要读取头部的长度整数。
*   **二进制安全**：Body 可以是任意二进制数据，完全不需要转义。

**结论建议**：
1.  如果你的协议是**基于文本的**（如类似于 Chat 聊天室、简单的控制指令），且数据量小，**Base64 + 分隔符** 是最快能写出来的方案。
2.  如果你是在做**二进制传输**（如传输图片、文件、实时语音、高频游戏包），请务必放弃分隔符方案，改用 **长度字段（Length-Header）** 模式。这是业界的标准做法。

Base64 之所以能保证**绝对不包含**换行符、回车符或其他控制字符，是因为它的**核心设计原理**决定了它的输出字符集是一个**严格受限的“白名单”**。

简单来说：**Base64 的字典里根本就没有那些“危险字符”。**

为了让你理解得更透彻，我们需要看一眼 Base64 的**底层数学逻辑**：

### 1. 核心原理：从“256进制”到“64进制”

*   **原始数据（二进制）**：
    计算机中的字节（Byte）是 8 位的，取值范围是 `0 ~ 255`。
    这意味着原始数据中可能包含 `0`（空字符 \0）、`10`（换行符 \n）、`13`（回车符 \r）等任何 ASCII 码。这就是为什么原始数据不能直接用作文本分隔符的原因。

*   **Base64 的做法**：
    Base64 规定：我不要 256 种可能性，我只要 **64** 种可能性。
    为什么是 64？因为 $2^6 = 64$。
    
    它将每 3 个字节（$3 \times 8 = 24$ bit）的数据，重新切割成 4 个单元，每个单元只有 6 bit（$4 \times 6 = 24$ bit）。

    **关键点来了**：一个 6 bit 的数据，其数值范围只能是 **0 到 63**。

### 2. 严格的“白名单”映射表

既然数值范围被限制在了 0~63 之间，Base64 就设计了一张**索引表（Index Table）**，将这 64 个数字一一对应到 64 个安全的**可见字符**上。

这张表就是 Base64 的“白名单”：

| 数值 (Index) | 字符 (Char) | 说明 |
| :--- | :--- | :--- |
| 0 ~ 25 | **A ~ Z** | 大写字母 |
| 26 ~ 51 | **a ~ z** | 小写字母 |
| 52 ~ 61 | **0 ~ 9** | 数字 |
| 62 | **+** | 加号 |
| 63 | **/** | 斜杠 |
| (填充) | **=** | 仅用于末尾补位 |

**请注意观察这张表：**
*   **换行符 (\n, ASCII 10)** 在这张表里吗？ **不在。**
*   **回车符 (\r, ASCII 13)** 在这张表里吗？ **不在。**
*   **空字符 (\0, ASCII 0)** 在这张表里吗？ **不在。**
*   **分隔符 (|, ,, ;)** 在这张表里吗？ **不在。**

### 3. 举个“变身”的例子

假设你的原始数据里正好有一个死对头——**换行符（ASCII 10）**，它是 8 位的二进制 `00001010`。如果直接发，接收端会以为消息结束了。

我们看看经过 Base64 编码后它变成了什么（为了演示方便，假设后面补了两个 0 字节）：

1.  **原始数据**： `\n` (换行符) + `\0` + `\0`
    二进制：`00001010` `00000000` `00000000`

2.  **重新切割**（每 6 位切一刀）：
    `000010` | `100000` | `000000` | `000000`

3.  **计算十进制值**：
    `2` | `32` | `0` | `0`

4.  **查表映射**：
    *   2 对应表里的 **C**
    *   32 对应表里的 **g**
    *   0 对应表里的 **A**
    *   0 对应表里的 **A**

5.  **最终结果**： `CgAA`

**结论**：原本危险的换行符 `00001010`，经过编码逻辑的“粉碎重组”和“查表”后，变成了安全的字母 `C` 和 `g`。

### 总结

Base64 之所以可以不包含其他字符，是因为它**从数学上**把所有输入数据都强制转换成了 0~63 的索引值，而这个索引值只能映射到那 64 个选定的安全字符。

这就是为什么你可以在 Base64 字符串后面放心地加上 `\r\n` 或 `$` 或 `#` 作为分隔符，因为 Base64 这一辈子都不可能生成这些字符，永远不会发生冲突（Collision）。

这是一个非常好的问题！Base64 算法确实是按“3字节一组”来进行处理的，但在现实世界中，数据的长度不一定是 3 的倍数。

当输入数据的字节数**不是 3 的倍数**时（即剩下了 1 个字节或 2 个字节），Base64 会使用**补位（Padding）**机制来处理，标志符号就是我们在 Base64 字符串末尾经常看到的 **等号 `=`**。

处理规则如下：

### 1. 核心逻辑
Base64 的输出字符串长度**必须是 4 的倍数**。
*   如果数据不够，先在二进制位右边补 `0` 凑成 6 位。
*   如果最终转换出来的字符数不够 4 个，就在末尾加 `=` 凑够 4 个。

具体分为两种情况：

---

### 情况一：剩下了 1 个字节 (余数 = 1)
假设我们要编码字母 **"M"**。
"M" 的 ASCII 码是 77，二进制是 `01001101`。

**步骤演示：**

1.  **摆放数据**：
    目前只有 8 个 bit： `01001101`。
2.  **按 6 位切割**：
    *   **第一组**：取前 6 位 `010011`。
    *   **第二组**：剩下了 2 位 `01`，不够 6 位怎么办？**在后面补 4 个 0**，变成 `010000`。
3.  **计算索引**：
    *   第一组 `010011` = 19 $\rightarrow$ 查表得字符 **`T`**
    *   第二组 `010000` = 16 $\rightarrow$ 查表得字符 **`Q`**
4.  **填充等号**：
    现在得到了 `TQ` (2个字符)。
    Base64 规定输出必须是 4 个字符一组，所以还缺 2 个。
    于是强制补上两个 `=`。

**最终结果**：`TQ==`

---

### 情况二：剩下了 2 个字节 (余数 = 2)
假设我们要编码字符串 **"Ma"**。
"M" (77) = `01001101`，"a" (97) = `01100001`。

**步骤演示：**

1.  **摆放数据**：
    总共有 16 个 bit： `01001101 01100001`。
2.  **按 6 位切割**：
    *   **第一组**：取前 6 位 `010011`。
    *   **第二组**：取接下来的 6 位（M的后2位 + a的前4位） `01 0110` $\rightarrow$ `010110`。
    *   **第三组**：剩下了 a 的最后 4 位 `0001`。不够 6 位，**在后面补 2 个 0**，变成 `000100`。
3.  **计算索引**：
    *   第一组 `010011` = 19 $\rightarrow$ **`T`**
    *   第二组 `010110` = 22 $\rightarrow$ **`W`**
    *   第三组 `000100` = 4  $\rightarrow$ **`E`**
4.  **填充等号**：
    现在得到了 `TWE` (3个字符)。
    为了凑够 4 个字符，在末尾补上一个 `=`。

**最终结果**：`TWE=`

---

### 总结规律

Base64 编码后的长度关系非常明确：

| 输入剩余字节数 | 处理方式 (二进制层面) | 最终填充 (字符层面) | 结果特征 |
| :--- | :--- | :--- | :--- |
| **0 字节** (刚好整除) | 不需要补 0 | 不需要填充 | 没有 `=` |
| **1 字节** | 补 4 个 bit 的 0 | **加 2 个 `=`** | 结尾是 `==` |
| **2 字节** | 补 2 个 bit 的 0 | **加 1 个 `=`** | 结尾是 `=` |

### 为什么要用 `=` ？
等号 `=` 不在 Base64 的 64 个标准字符索引表（0-63）里。
它是一个**没有任何数据含义的特殊哨兵**。

当接收端（解码器）看到：
*   `==`：它就知道，“倒数第二个字符的最后 4 位是废的，扔掉；倒数第一个字符全是废的”。
*   `=`：它就知道，“倒数第一个字符的最后 2 位是废的，扔掉”。

这样就能完美还原出原始的字节数，一个 bit 都不多，一个 bit 也不少。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-base64)