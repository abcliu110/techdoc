<div id="chap-retransmit"></div>

[⬆️ 返回目录](#catalog)


## 重传

好的，作为一个资深程序员，我们重新梳理 TCP 重传机制。这次我修复了 Mermaid 图表中的语法兼容性问题，并保持深度的内核视角分析。

在内核开发者的眼中，**TCP 重传（Retransmission）** 并不是简单的“丢了就补发”，而是**拥塞控制（Congestion Control）状态机切换的“扳机”**。它决定了连接是进入“慢启动（Slow Start）”还是“快速恢复（Fast Recovery）”，这对高并发服务的延时抖动（Jitter）有决定性影响。

以下是完整的深度解析及修复后的流程图。

---

### 一、 超时重传 (RTO) —— 性能的“核打击”

**资深视角**：
超时重传（RTO - Retransmission Timeout）是 TCP 的底线兜底机制。一旦触发 RTO，TCP 协议栈会认为当前网络发生了极其严重的拥塞（连 Dup ACK 都传不回来了）。

**内核行为**：
1.  **重置 cwnd**：拥塞窗口（cwnd）直接降为 1 个 MSS（回到解放前）。
2.  **慢启动**：进入 Slow Start 阶段，带宽利用率断崖式下跌。
3.  **指数退避**：如果重传包还丢，下一次 RTO 时间翻倍（1s -> 2s -> 4s ...）。

**修复后的流程图**：

```mermaid
flowchart TD
    subgraph Send_Loop [发送端内核处理]
        Start[应用层 write 数据] --> Pkt_Gen[封装 TCP Segment]
        Pkt_Gen -->|进入 Send Queue| Send["发送数据包 Seq=N"]
        Send --> Set_Timer{"启动/重置 RTO 定时器"}
    end

    subgraph Network [网络环境]
        Send -->|❌ 丢包或 ACK 严重延迟| Lost((X))
    end

    subgraph Timer_Event [RTO 超时处理]
        Set_Timer -- 等待 ACK --> Wait_ACK
        Wait_ACK -->|✅ 收到 ACK| Update_RTT["更新 SRTT & RTO<br/>停止当前定时器"]
        
        Wait_ACK -- ⏰ RTO 超时 --> Timeout_Trigger[触发超时重传]
        
        Timeout_Trigger --> Penalty["❌ 惩罚机制 (核打击):<br/>1. ssthresh = cwnd / 2<br/>2. cwnd = 1 MSS (慢启动)<br/>3. RTO = RTO * 2"]
        
        Penalty --> Retransmit["重传 Seq=N"]
        Retransmit --> Reset_Timer[重置定时器]
        Reset_Timer -->|注意: 不采样此包的 RTT| Wait_ACK
    end
```

---

### 二、 快速重传 (Fast Retransmit) —— 性能的“急救包”

**资深视角**：
快速重传通过检测**重复 ACK (Duplicate ACK)** 来感知丢包。这通常意味着“包丢了，但路没断”（部分数据包还能到达）。

**内核行为**：
1.  **触发阈值**：通常收到 **3 个** 重复的 ACK（冗余 ACK）。为什么是 3 个？为了过滤掉因为网络路由导致的**乱序（Reordering）**。
2.  **快速恢复**：TCP **不会**像 RTO 那样回到慢启动。它会将 `cwnd` 减半（`ssthresh = cwnd/2`），然后进入 **Fast Recovery** 状态。这是为了保住当前的发送速率。

**修复后的时序图**：

```mermaid
sequenceDiagram
    participant Sender as 发送端 (cwnd=High)
    participant Network
    participant Receiver as 接收端

    Note over Sender, Receiver: 正常流: 发送 Seq 1, 2, 3, 4, 5

    Sender->>Network: Seg 1
    Sender->>Network: Seg 2 (❌ 丢包)
    Sender->>Network: Seg 3
    Sender->>Network: Seg 4
    Sender->>Network: Seg 5

    Network->>Receiver: 收到 Seg 1
    Receiver-->>Sender: ACK 2 (期待 Seq 2)

    Network->>Receiver: 收到 Seg 3 (乱序)
    Note right of Receiver: 发现缺口: 缺 2<br/>触发立即 ACK
    Receiver-->>Sender: 🔴 Dup ACK #1 (ACK 2)

    Network->>Receiver: 收到 Seg 4 (乱序)
    Receiver-->>Sender: 🔴 Dup ACK #2 (ACK 2)

    Network->>Receiver: 收到 Seg 5 (乱序)
    Receiver-->>Sender: 🔴 Dup ACK #3 (ACK 2)

    Note left of Sender: 收到第 3 个重复 ACK<br/>判断 Seg 2 丢失 (非拥塞)

    rect rgb(255, 240, 240)
        Note left of Sender: 🚀 触发快速重传<br/>1. 立即重传 Seg 2<br/>2. ssthresh = cwnd / 2<br/>3. cwnd = ssthresh + 3
    end
    
    Sender->>Network: 重传 Seg 2
    
    Network->>Receiver: 收到 Seg 2
    Note right of Receiver: 缺口补齐<br/>(2,3,4,5 都有了)
    Receiver-->>Sender: ACK 6 (期待 Seq 6)
    
    Note left of Sender: 退出 Fast Recovery<br/>进入拥塞避免
```

---

### 三、 SACK (Selective ACK) —— 现代化的精准补发

**资深视角**：
传统的重传机制（Go-Back-N）非常笨拙。假设发送了 1~10，只有 2 丢了。接收方只能一直 ACK 2。发送方不知道 3~10 到了没，可能一气之下把 2~10 全重发了（浪费带宽），或者只重发 2（增加延迟）。

**内核行为**：
SACK 在 TCP 头部的 Option 字段里携带了“我收到的不连续块”。发送方维护一个 **记分板 (Scoreboard)**，精准标记哪些包丢了，只重传丢失的部分。

**修复后的逻辑图**：

```mermaid
graph TD
    subgraph Receiver_View [接收端视角]
        Recv_Buffer[接收缓冲区]
        Gap["空洞/丢包: Seq 200-300"]
        Block1["已收: Seq 0-199"]
        Block2["SACK块: Seq 301-500"]
        
        Block1 --- Gap --- Block2
    end

    subgraph ACK_Packet [构造 ACK 包]
        Header[TCP Header]
        AckNum["ACK Num: 200"]
        Option["Option: SACK"]
        SackContent["Left Edge: 301, Right Edge: 501"]
        
        Header --> AckNum
        Header --> Option --> SackContent
    end

    subgraph Sender_Logic [发送端记分板 Scoreboard]
        Parse[解析 SACK 选项]
        Mark[标记发送队列状态]
        
        Item1["Seq 0-199: 已确认"]
        Item2["Seq 200-300: ❌ 标记丢失 (Lost)"]
        Item3["Seq 301-500: ✅ 标记已SACK (Sacked)"]
        
        Parse --> Mark
        Mark --> Item2
        
        Action[精准重传]
        Item2 --> Action -->|只重传 Seq 200-300| Retransmit_Gap[重传补洞]
    end

    Receiver_View --> ACK_Packet --> Sender_Logic
```

---

### 四、 总结：资深程序员的调优结论

1.  **区分 RTO 与 Fast Retransmit**：
    *   我们在监控看板上看到 `TcpRetransSegs` 增加时，不要惊慌。如果是 **Fast Retransmit** 增加，说明带宽可能跑满了或者偶尔有丢包，系统还在撑着。
    *   但如果看到 **TCP Timeouts** 增加，说明网络环境恶化，或者中间链路丢包严重，系统吞吐量即将崩盘。

2.  **SACK 必须开**：
    *   `sysctl net.ipv4.tcp_sack` 默认为 1。如果被误关，高丢包率环境下（如跨国传输、弱网 WiFi）性能会下降 50% 以上。

3.  **Linux 的 RACK 优化**：
    *   现在的 Linux 内核（4.4+）已经默认启用了 **RACK (Recent ACK)** 算法，它不再单纯依赖“3个重复 ACK”，而是根据**时间戳**来判断丢包。这解决了“尾部丢包”无法触发快速重传的痛点（因为尾部丢包后，没有后续的包来触发 Dup ACK）。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-retransmit)