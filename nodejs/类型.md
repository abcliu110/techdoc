<div id="chap-type"></div>

[⬆️ 返回目录](#catalog)


## 类型

将 JavaScript 代码迁移到 TypeScript 时，最核心的工作就是把 JS 中“隐式、动态”的类型，转换为 TS 中“显式、静态”的类型定义。

以下是常见 JS 数据类型到 TS 类型的**映射对照表**和**实战转换指南**：

---

### 1. 基础数据类型 (Primitives)
这是最简单的部分，直接一一对应。

| JS 只有值 (Example) | TS 类型 (Type) | 说明 |
| :--- | :--- | :--- |
| `'hello'` / `"world"` | `string` | **注意全小写**，不要写成 `String` |
| `100` / `3.14` | `number` | 整数和浮点数统称 `number` |
| `true` / `false` | `boolean` | 布尔值 |
| `null` | `null` | 通常配合联合类型使用 |
| `undefined` | `undefined` | 通常配合可选属性使用 |
| `Symbol('id')` | `symbol` | 唯一值 |

**转换示例：**
```typescript
// JS
let name = "Alice";
let count = 10;
let isLogin = false;

// TS
let name: string = "Alice";
let count: number = 10;
let isLogin: boolean = false;
```

---

### 2. 数组 (Arrays)
JS 里的数组很灵活，TS 里需要明确“数组里装的是什么”。

#### 情况 A：数组里全是同一种类型
```typescript
// JS: const list = [1, 2, 3];
const list: number[] = [1, 2, 3]; 
// 或者泛型写法: Array<number>
```

#### 情况 B：数组里有多种类型 (混合数组)
```typescript
// JS: const list = [1, "a", 2, "b"];
const list: (number | string)[] = [1, "a", 2, "b"];
```

#### 情况 C：固定长度和位置 (元组 Tuple)
如果数组是用来当“数据对”使用的（例如 React 的 `useState` 返回值）。
```typescript
// JS: const point = [10, 20]; // 坐标 x, y
const point: [number, number] = [10, 20];
```

---

### 3. 对象 (Objects) —— 最常用
JS 的对象在 TS 中通常用 **`interface` (接口)** 来描述。

#### 情况 A：标准对象
```typescript
// JS
const user = {
    name: 'Alice',
    age: 18
};

// TS
interface User {
    name: string;
    age: number;
}
const user: User = { name: 'Alice', age: 18 };
```

#### 情况 B：有时候有，有时候没有 (可选属性)
JS 里经常检查 `if (user.email) ...`。
```typescript
interface User {
    name: string;
    email?: string; // 加问号，表示可以是 string 或者 undefined
}
```

#### 情况 C：当字典用 (动态 Key)
JS 里经常拿对象当 HashMap 用，Key 不确定。
```typescript
// JS: const cache = { "a": 1, "b": 2, "c": 3 ... };

// TS
interface NumberCache {
    [key: string]: number; // 索引签名：Key 是字符串，Value 必须是数字
}
const cache: NumberCache = { "a": 1, "b": 2 };
```

---

### 4. 函数 (Functions)
JS 的函数主要关注：**参数**和**返回值**。

#### 情况 A：普通函数
```typescript
// JS
function add(a, b) {
    return a + b;
}

// TS
function add(a: number, b: number): number {
    return a + b;
}
```

#### 情况 B：没有返回值的函数
```typescript
// JS
function log(msg) {
    console.log(msg);
}

// TS
function log(msg: string): void { // void 表示没有任何返回
    console.log(msg);
}
```

#### 情况 C：回调函数作为参数
```typescript
// JS: function request(callback) { ... }

// TS
function request(callback: (data: string) => void): void {
    // ...
}
```

---

### 5. 复杂/动态场景 (Advanced)

#### 情况 A：一个变量可能是多种类型 (联合类型)
JS 弱类型的典型特征。
```typescript
// JS: id 可能是 1，也可能是 "1"
let id: number | string; 
```

#### 情况 B：固定值的字符串 (字面量类型)
JS 里用来做状态标记。
```typescript
// JS: status 只能是 'success' 或 'fail'
let status: 'success' | 'fail' | 'loading';
```

#### 情况 C：异步 Promise
JS 的 `async/await`。
```typescript
// JS: async function getData() { return "data"; }

// TS: Promise<string> 表示 Promise 解析后的值是 string
async function getData(): Promise<string> {
    return "data";
}
```

#### 情况 D：真的不知道是什么 (Any)
这是最后的退路。
```typescript
// JS: let whatever = ...;
let whatever: any = "hello"; // 放弃类型检查
```

---

### 6. 速查总结表

| JS 场景 | TS 写法 | 例子 |
| :--- | :--- | :--- |
| **基础值** | `string`, `number`, `boolean` | `let n: number = 1;` |
| **纯数组** | `Type[]` | `let arr: string[] = ['a'];` |
| **对象** | `interface` | `interface User { name: string }` |
| **对象可能缺字段** | `?` | `age?: number` |
| **多种可能** | `\|` (联合) | `string \| number` |
| **具体的值** | 字面量 | `'open' \| 'close'` |
| **任意对象(字典)** | `[key: string]: Type` | `[id: string]: any` |
| **无返回值** | `void` | `function(): void` |
| **不确定的类型** | `any` (少用) 或 `unknown` (安全) | `let data: any` |

### 转换技巧：
先把所有变量想象成“盒子”。
1.  盒子装什么？(String? Object?)
2.  盒子一定有东西吗？(Optional `?`)
3.  盒子可以装不同的东西吗？(Union `|`)


**答案是：类 (Class) 本身既是“值”，也是“类型”。**

在 TypeScript 中，`class` 是一个非常特殊的关键字，因为它具有 **“双重身份”**。当你定义一个类时，你不需要像对象那样专门再去写一个 `interface`，因为**类本身这就自动定义了一个同名的类型**。

以下是关于“类与类型”的详细转换与使用指南：

---

### 1. 核心概念：类即类型 (Class is a Type)
当你写下 `class User` 时，TS 自动把 `User` 注册为一个类型。你可以直接用类名作为类型注解。

**JS/TS 代码：**
```typescript
class User {
    name: string;
    age: number;

    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }

    sayHi() {
        console.log("Hi");
    }
}

// 这里的 User 是“类型”：表示变量 u 必须是 User 类的实例（或形状相同）
const u: User = new User("Alice", 18);
```

**结论**：你不需要为了类专门去写 `interface UserInterface`，直接用类名 `User` 即可。

---

### 2. 进阶用法：类实现接口 (`implements`)
虽然类自带类型，但在架构设计中，我们经常先定义一个接口（契约），然后强制让一个或多个类去遵守这个契约。这时使用 `implements` 关键字。

**场景**：你要写个“报警器”，不管是“火灾报警器”还是“防盗报警器”，都必须得有 `alarm()` 方法。

```typescript
// 1. 定义接口（制定标准）
interface Alarm {
    alert(): void;
}

// 2. 类实现接口（执行标准）
// 如果这个类没写 alert 方法，TS 会直接报错
class FireAlarm implements Alarm {
    alert() {
        console.log("起火啦！！！");
    }
}

class DoorAlarm implements Alarm {
    alert() {
        console.log("有人闯入！！！");
    }
}
```

---

### 3. 特殊情况：鸭子类型 (Duck Typing)
TypeScript 是**结构化类型系统**（Structural Typing）。这意味着，只要两个东西“长得一样”，TS 就认为它们是同一个类型。

即便没有 `extends` 也没有 `implements`，只要形状匹配，就可以赋值。

```typescript
class Dog {
    bark() { console.log("汪汪"); }
}

class Cat {
    bark() { console.log("喵喵...啊不对，是汪汪"); } // 长得和 Dog 一样
}

// 注意：这里类型要求是 Dog
const myPet: Dog = new Cat(); // ✅ 竟然不报错！
```
**原因**：`Cat` 类里也有 `bark` 方法，结构满足 `Dog` 的要求，所以 TS 认为它是合法的 `Dog` 类型。

---

### 4. 高级：如何表示“类本身”？(`typeof`)
这是一个初学者很容易晕的地方。

*   **`User`**：指的是**实例的类型**（new 出来的那个对象）。
*   **`typeof User`**：指的是**构造函数本身的类型**（类本身）。

**场景**：你想写一个工厂函数，参数是一个“类”，而不是一个“对象”。

```typescript
class User {
    static standard = "human"; // 静态属性
    constructor(public name: string) {}
}

// 错误写法：arg: User
// 意思是：给我传一个已经 new 好的 User 对象
function createWrong(arg: User) { ... }

// 正确写法：arg: typeof User
// 意思是：给我传 User 这个类（构造函数），我要在里面 new 它
function createInstance(Constructor: typeof User) {
    return new Constructor("Alice");
}

createInstance(User); // ✅ 传入类本身
```

---

### 总结表

| 你的需求 | TS 写法 | 示例 |
| :--- | :--- | :--- |
| **我想限制变量必须是某个类的实例** | 直接使用类名 | `let u: User = ...` |
| **我想强制类必须包含某些方法** | 使用 `interface` + `implements` | `class User implements IUser` |
| **我想把“类本身”作为参数传递** | 使用 `typeof 类名` | `fn(clazz: typeof User)` |
| **我想描述一个普通的 JS 对象** | 使用 `interface` 或 `type` | `interface User { name: string }` |


这是一个**“大杂烩”**式的终极示例。

我构建了一个 **简易的用户管理系统后端**。它在一个文件中融合了你刚才学到的所有知识点：
1.  **基础类型 & 联合类型**
2.  **接口 (Interface)** vs **类 (Class)**
3.  **类实现接口 (`implements`)**
4.  **泛型 (Generics)**
5.  **工具类型 (`Omit`, `Partial`)**
6.  **类作为类型** vs **类作为构造函数 (`typeof`)**
7.  **Node.js 原生 Server**

你可以直接把这段代码复制到 `src/server.ts` 中运行。

### 完整代码示例

```typescript
import http, { IncomingMessage, ServerResponse } from 'http';

// ==========================================
// 1. 类型定义区域 (Type & Interface)
// ==========================================

// [联合类型] 定义固定的字符串值
type UserRole = 'admin' | 'editor' | 'guest';

// [接口] 定义用户数据的形状
interface IUser {
    readonly id: number; // [只读属性] 初始化后不可修改
    name: string;
    email: string;
    role: UserRole;      // 使用上面的联合类型
    isActive?: boolean;  // [可选属性] 可能没有
}

// [泛型接口] 定义通用的 API 响应格式
// T 代表 data 的类型，它可以是 User，也可以是 User数组，也可以是 string
interface IApiResponse<T> {
    code: number;
    success: boolean;
    data?: T;
    error?: string;
}

// [接口] 定义数据库服务的契约 (规范)
// 任何实现这个接口的类，都必须有 add 和 get 方法
interface IDatabaseService {
    add(user: Omit<IUser, 'id'>): IUser; // Omit: 这里的参数不需要传 id
    get(id: number): IUser | undefined;
}

// ==========================================
// 2. 核心逻辑区域 (Class & Implements)
// ==========================================

// [类实现接口] UserDB 类必须遵守 IDatabaseService 的规定
class UserDB implements IDatabaseService {
    // [静态属性] 属于类本身，不属于实例
    static dbName = "MemoryDB v1.0";

    // 私有变量，外部无法直接访问
    private storage: IUser[] = [];

    constructor() {
        console.log(`[System] ${UserDB.dbName} 初始化完成`);
    }

    // 实现接口规定的 add 方法
    // 参数用了 Omit 工具类型，返回值是完整的 IUser
    public add(userInfo: Omit<IUser, 'id'>): IUser {
        const newUser: IUser = {
            id: this.storage.length + 1, // 模拟生成 ID
            isActive: true,              // 默认值
            ...userInfo                  // 展开属性
        };
        this.storage.push(newUser);
        return newUser;
    }

    // 实现接口规定的 get 方法
    public get(id: number): IUser | undefined {
        return this.storage.find(u => u.id === id);
    }
}

// ==========================================
// 3. 高级工厂模式 (typeof Class)
// ==========================================

/**
 * 这个函数接收一个“类”作为参数，而不是“实例”
 * @param DBClass 必须是一个构造函数，且实例化后符合 IDatabaseService 接口
 */
function createDatabase(DBClass: new () => IDatabaseService) {
    return new DBClass(); // 在这里 new 它
}

// 使用工厂创建实例
// 此时 db 的类型被推断为 IDatabaseService
const db = createDatabase(UserDB); 

// 预先存入一个数据方便测试
db.add({ name: "Admin", email: "admin@ts.com", role: "admin" });

// ==========================================
// 4. 工具函数 (Generics)
// ==========================================

// [泛型函数] 自动包装响应格式
function createResponse<T>(data: T, code: number = 200): IApiResponse<T> {
    return {
        code,
        success: code < 400,
        data
    };
}

// [Promise + 泛型] 解析 Body
const parseJSONBody = <T>(req: IncomingMessage): Promise<T> => {
    return new Promise((resolve) => {
        let body = '';
        req.on('data', chunk => body += chunk);
        req.on('end', () => {
            try {
                resolve(JSON.parse(body || '{}'));
            } catch {
                resolve({} as T); // 类型断言：强制告诉 TS 这是 T 类型
            }
        });
    });
};

// ==========================================
// 5. 服务器入口 (Node.js Native)
// ==========================================

const server = http.createServer(async (req, res) => {
    // 统一发送 JSON 的辅助函数
    const send = <T>(payload: IApiResponse<T>) => {
        res.writeHead(payload.code, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(payload));
    };

    const url = new URL(req.url || '/', `http://${req.headers.host}`);
    
    // --- 路由逻辑 ---

    // GET /user?id=1
    if (url.pathname === '/user' && req.method === 'GET') {
        const idStr = url.searchParams.get('id');
        const id = Number(idStr);

        if (!idStr || isNaN(id)) {
            send(createResponse(null, 400)); // 错误请求
            return;
        }

        const user = db.get(id);

        if (user) {
            // 此时 createResponse 的泛型 T 自动推导为 IUser
            send(createResponse(user)); 
        } else {
            send({ code: 404, success: false, error: "User not found" });
        }
        return;
    }

    // POST /user
    if (url.pathname === '/user' && req.method === 'POST') {
        // [关键] 告诉 parseJSONBody，我期望解析出来的是不带 ID 的 User
        // 这样 body 变量就有类型提示了
        const body = await parseJSONBody<Omit<IUser, 'id'>>(req);

        if (!body.name || !body.role) {
            send({ code: 400, success: false, error: "Missing name or role" });
            return;
        }

        const newUser = db.add(body);
        send(createResponse(newUser, 201));
        return;
    }

    // 404
    send({ code: 404, success: false, error: "Endpoint not found" });
});

// 启动
server.listen(3000, () => {
    console.log(`Server running at http://localhost:3000`);
    console.log(`Try: curl http://localhost:3000/user?id=1`);
});
```

### 代码深度解析 (对应之前的知识点)

1.  **`interface IUser`**:
    *   使用了 `readonly`（只读），模拟数据库 ID 不可改。
    *   使用了 `?`（可选），模拟 `isActive` 字段。
    *   使用了 **联合类型** `UserRole`，限制角色只能是那三个字符串。

2.  **`class UserDB implements IDatabaseService`**:
    *   展示了 **Class (实现)** 和 **Interface (契约)** 的配合。
    *   使用了 `private` 属性，符合面向对象封装。
    *   `static dbName` 展示了静态属性。

3.  **`createDatabase(UserDB)`**:
    *   这是最难理解的 **`typeof Class`** 的应用。
    *   函数参数要求传入一个**构造函数**（类本身），而不是类的实例。

4.  **`parseJSONBody<T>`**:
    *   展示了 **泛型** 在工具函数中的威力。
    *   调用时写作 `parseJSONBody<Omit<IUser, 'id'>>(req)`。
    *   TS 会自动推断：`body.name` 是存在的，但 `body.id` 是不存在的（因为被 `Omit` 剔除了），这完美模拟了前端传参不带 ID，后端生成 ID 的场景。

5.  **`IApiResponse<T>`**:
    *   展示了泛型接口。返回的数据结构永远是 `{ code, data }`，但 `data` 里面的样子由调用者决定。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-type)