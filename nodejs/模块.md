<div id="chap-module"></div>

[⬆️ 返回目录](#catalog)


## 模块

答案是：**通常情况下是“一个文件一个模块”，但取决于代码中是否有 `import` 或 `export`。**

在 TypeScript 中，文件的身份有两种状态，这决定了“一个文件”到底是不是“一个模块”。

### 1. 模块模式 (Module) —— 现代标准
只要你的 `.ts` 文件中**包含至少一个**顶级的 `import` 或 `export` 语句，TypeScript 就会把这个文件视为一个**模块**。

*   **特点**：
    *   文件内的变量、函数、类都是**私有的**（局部作用域）。
    *   只有用 `export` 导出的内容，其他文件才能通过 `import` 使用。
    *   **这就是“一个文件一个模块”。**

```typescript
// file1.ts
export const a = 1; // 这是一个模块，因为有 export
const b = 2; // 私有变量，外部无法访问
```

---

### 2. 脚本模式 (Script) —— 新手常踩的坑
如果你的 `.ts` 文件里**没有任何** `import` 或 `export` 语句，TypeScript 会把它视为一个**全局脚本 (Global Script)**。

*   **特点**：
    *   文件内的变量是**全局的**！
    *   它的内容会“污染”整个项目。
    *   **这会导致著名的“重复声明”报错。**

#### ❌ 错误示例（由全局模式引起）

**`file_A.ts`** (没有 export/import)
```typescript
const name = "张三"; 
```

**`file_B.ts`** (也没有 export/import)
```typescript
// 报错！Cannot redeclare block-scoped variable 'name'.
// 因为 file_A 里的 name 是全局的，这里冲突了。
const name = "李四"; 
```

---

### 3. 如何强制让文件变成模块？
如果你写的一个文件暂时不需要引入任何东西，也不需要导出任何东西（比如只是运行一段逻辑），但你不想让它变成全局脚本，你必须在文件末尾加上一行：

```typescript
// myLogic.ts

const name = "只有我可以用的变量";
console.log(name);

// 添加这行空导出，强制告诉 TS：“把我看作一个模块，把作用域锁在这个文件里”
export {}; 
```

### 总结
*   **现代开发（Node.js/React/Vue）**：你会用到大量的 `import`/`export`，所以实际上就是**“一个文件一个模块”**。
*   **例外情况**：如果你使用旧式的 `namespace`（命名空间）语法，可以在一个文件里定义多个“逻辑模块”，或者把一个命名空间拆分到多个文件。但这种写法在现代 Node.js 开发中已经**极少使用**了。

**结论**：放心大胆地认为“一个文件就是一个模块”，但记得如果你遇到“变量重复声明”的错误，检查一下是不是忘了写 `export`。


是的，理解完全正确！👍

**`node_modules/@types` 是 TypeScript 的一个“默认约定”的类型声明目录。**

你可以把它理解为 TypeScript 的 **“外挂字幕文件夹”**。

为了让你彻底明白它的机制，我们需要看透以下 3 点本质：

### 1. 它是 TS 的“自动检索区”

在 `tsconfig.json` 中，有一个配置项叫 `typeRoots`。默认情况下，你不需要配置它，因为它的默认值大概是这样的：

```json
// tsconfig.json 默认行为
{
  "compilerOptions": {
    // 默认去所有层级的 node_modules 下找 @types 文件夹
    "typeRoots": ["./node_modules/@types"]
  }
}
```

这意味着：**只要你把类型定义文件放在 `node_modules/@types/` 目录下，TypeScript 就会自动加载它们，而不需要你手动 import。**

### 2. 这个目录里的东西从哪来？

这个目录里的包，通常都来自一个庞大的开源项目：**DefinitelyTyped**。

*   很多第三方库（比如 `express`, `react`, `jquery`）是用纯 JS 写的，没有类型。
*   全世界的热心开发者（社区）帮这些库写了 `.d.ts` 类型文件。
*   这些文件被统一发布到了 npm 的 `@types` 命名空间下。

**流程是这样的：**
1.  你运行 `npm install -D @types/express`。
2.  npm 会把这个包下载并解压到 `node_modules/@types/express`。
3.  当你写 `import express from 'express'` 时。
4.  TS 发现 `express` 本身没有类型，于是自动去 `node_modules/@types` 里找有没有叫 `express` 的文件夹。
5.  **匹配成功！**

### 3. 目录结构长什么样？

打开你的项目文件夹，结构通常是这样的：

```text
node_modules/
├── axios/              (自带类型，不在 @types 里)
│   ├── index.js
│   └── index.d.ts      <-- 作者自己写的类型
│
├── express/            (不带类型，纯 JS)
│   └── index.js
│
└── @types/             <-- 专门存放补丁类型的目录
    ├── node/           (对应 Node.js 环境的类型)
    │   └── index.d.ts
    │
    └── express/        (对应 Express 库的类型)
        └── index.d.ts
```

### 总结

*   **`@types`**：这是 npm 的一个 **Scope（作用域）**，专门用来发布类型包。
*   **`node_modules/@types`**：这是 TypeScript 编译器默认寻找第三方类型声明的 **文件夹**。

**一句话总结：**
如果你用的库（如 Express）没有“官方说明书”，你就去 `@types` 市场买一本“社区汉化版说明书”，npm 会自动把它放到 `node_modules/@types` 这个书架上，TypeScript 就会自动读到了。



<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-module)