<div id="chap-module"></div>

[⬆️ 返回目录](#catalog)


## 模块

答案是：**通常情况下是“一个文件一个模块”，但取决于代码中是否有 `import` 或 `export`。**

在 TypeScript 中，文件的身份有两种状态，这决定了“一个文件”到底是不是“一个模块”。

### 1. 模块模式 (Module) —— 现代标准
只要你的 `.ts` 文件中**包含至少一个**顶级的 `import` 或 `export` 语句，TypeScript 就会把这个文件视为一个**模块**。

*   **特点**：
    *   文件内的变量、函数、类都是**私有的**（局部作用域）。
    *   只有用 `export` 导出的内容，其他文件才能通过 `import` 使用。
    *   **这就是“一个文件一个模块”。**

```typescript
// file1.ts
export const a = 1; // 这是一个模块，因为有 export
const b = 2; // 私有变量，外部无法访问
```

---

### 2. 脚本模式 (Script) —— 新手常踩的坑
如果你的 `.ts` 文件里**没有任何** `import` 或 `export` 语句，TypeScript 会把它视为一个**全局脚本 (Global Script)**。

*   **特点**：
    *   文件内的变量是**全局的**！
    *   它的内容会“污染”整个项目。
    *   **这会导致著名的“重复声明”报错。**

#### ❌ 错误示例（由全局模式引起）

**`file_A.ts`** (没有 export/import)
```typescript
const name = "张三"; 
```

**`file_B.ts`** (也没有 export/import)
```typescript
// 报错！Cannot redeclare block-scoped variable 'name'.
// 因为 file_A 里的 name 是全局的，这里冲突了。
const name = "李四"; 
```

---

### 3. 如何强制让文件变成模块？
如果你写的一个文件暂时不需要引入任何东西，也不需要导出任何东西（比如只是运行一段逻辑），但你不想让它变成全局脚本，你必须在文件末尾加上一行：

```typescript
// myLogic.ts

const name = "只有我可以用的变量";
console.log(name);

// 添加这行空导出，强制告诉 TS：“把我看作一个模块，把作用域锁在这个文件里”
export {}; 
```

### 总结
*   **现代开发（Node.js/React/Vue）**：你会用到大量的 `import`/`export`，所以实际上就是**“一个文件一个模块”**。
*   **例外情况**：如果你使用旧式的 `namespace`（命名空间）语法，可以在一个文件里定义多个“逻辑模块”，或者把一个命名空间拆分到多个文件。但这种写法在现代 Node.js 开发中已经**极少使用**了。

**结论**：放心大胆地认为“一个文件就是一个模块”，但记得如果你遇到“变量重复声明”的错误，检查一下是不是忘了写 `export`。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-module)