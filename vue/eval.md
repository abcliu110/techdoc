<div id="chap-template"></div>

[⬆️ 返回目录](#catalog)


## eval

`eval` 是 JavaScript 中最强大但也最危险、最影响性能的函数之一。它的核心技术原理涉及到 **JavaScript 引擎的编译流水线**、**词法作用域（Lexical Scope）的破坏**以及 **上下文堆栈** 的特殊处理。

以下是 `eval` 的深入技术原理分析：

---

### 1. 核心机制：运行时的“二次编译”

通常，JS 引擎（如 V8）处理代码的流程是：
> 源代码 -> 词法/语法分析 (Parser) -> 抽象语法树 (AST) -> 字节码 (Bytecode) -> 优化编译 (JIT) -> 执行

当代码执行到 `eval(str)` 时，引擎必须**暂停**当前的执行流，进行以下操作：
1.  **启动解析器**：将 `eval` 接收到的字符串参数当作全新的源代码。
2.  **生成 AST 和字节码**：对这段字符串进行完整的编译过程。
3.  **执行**：在当前的（或全局的）作用域链中执行生成的代码。
4.  **回填结果**：将执行结果返回给原代码，继续执行。

**原理总结**：`eval` 实际上是在运行时唤醒了编译器。这意味着它无法利用引擎在预编译阶段做的任何优化，因为引擎无法预测字符串里到底是什么代码。

---

### 2. 作用域机制：欺骗词法作用域 (Cheating Lexical Scope)

这是 `eval` 最本质的特征。JavaScript 采用的是**词法作用域**（静态作用域），即变量的作用域在代码写好时就确定了。

但 `eval` 能够**动态地修改**当前的词法作用域（Environment Record）。

#### A. 直接调用 (Direct Eval)
当直接使用 `eval(...)` 时，它运行在**调用者的词法环境**中。

```javascript
function foo() {
    var a = 1;
    eval('var a = 2;'); // 修改了 foo 的变量环境(Variable Environment)
    console.log(a); // 输出 2
}
```
**底层原理**：
*   引擎检测到直接的 `eval` 调用。
*   `eval` 内部的代码生成的声明（如 `var a`），会被直接注入到当前执行上下文的 **环境记录 (Environment Record)** 中。
*   如果使用 `let`/`const`（在非严格模式下），它们会存在于一个新的块级词法环境中，但这个环境依然嵌套在当前环境中。

#### B. 间接调用 (Indirect Eval)
如果你将 `eval` 赋值给另一个变量，或者通过表达式调用，由于引用丢失，它变成了“间接调用”。

```javascript
var a = 1;
function foo() {
    var a = 2;
    var myEval = eval; 
    myEval('console.log(a)'); // 输出 1 (全局的 a)
}
```
**底层原理**：
*   ECMAScript 规范规定：**间接 `eval` 调用总是在全局作用域下执行**。
*   它不会访问调用者的闭包或局部变量，而是直接基于 **全局执行上下文** 创建一个新的代码执行环境。

---

### 3. 严格模式 (`'use strict'`) 的沙箱化

在严格模式下，`eval` 的行为发生了根本性的变化（为了安全和优化）。

```javascript
'use strict';
function foo() {
    eval('var a = 2; console.log(a);'); // 输出 2
    console.log(a); // 报错：a is not defined
}
```

**底层原理**：
*   在严格模式下，`eval` 拥有自己的 **私有词法环境**。
*   `eval` 内部声明的变量**不会泄漏**到外部（调用者）的变量环境中。
*   但是，`eval` 内部依然可以**读取/访问**外部作用域的变量。

---

### 4. 性能杀手：为什么引擎讨厌 eval？

这是 `eval` 最大的技术痛点。理解这一点需要了解 V8 等引擎的 **JIT（即时编译）优化策略**。

#### A. 无法进行静态分析
引擎在编译阶段会构建作用域链。它会计算每个变量在内存中的偏移量。
*   例如：引擎看到 `console.log(x)`，在编译时它就知道 `x` 位于作用域链的第 2 层，偏移量 3 的位置。

#### B. 破坏优化 (De-optimization)
一旦函数中存在 `eval`：
1.  **变量查找变慢**：引擎无法确定 `eval` 里的字符串是否包含 `var x = ...`。因此，引擎**不敢**做静态地址映射。
2.  **强制回退**：凡是包含 `eval` 的函数，引擎通常会放弃高级优化（如 Inline Caching），回退到慢速的动态查找（即每次都要按名字去作用域链里逐级寻找变量，而不是直接去内存地址取）。
3.  **污染闭包**：因为 `eval` 可能引用任何外层变量，引擎可能被迫保留所有外层变量，导致内存回收效率降低（因为无法确定哪些变量是真正的死变量）。

> **注意**：现代 V8 引擎非常聪明，它会尝试隔离 `eval`。如果你在严格模式下使用 `eval`，或者没有通过 `eval` 引入新变量，引擎受到的性能影响会小很多，但依然存在。

---

### 5. `eval` vs `new Function`

这经常被混淆，但原理不同。

*   **`eval`**：混入当前上下文（直接调用时），影响当前闭包。
*   **`new Function('code')`**：
    *   **永远在全局作用域创建函数**。
    *   它生成的函数，其 `[[Scope]]` 指向全局对象，而不是创建它的闭包。
    *   它比 `eval` 稍微安全一点，因为它不会修改当前的局部变量，也不会访问当前的局部变量。

```javascript
function test() {
    var a = 1;
    // eval 可以访问局部 a
    eval('console.log(a)'); // 1
    
    // new Function 只能访问全局，找不到局部的 a
    new Function('console.log(a)')(); // 报错或访问全局 a
}
```

### 总结

`eval` 的技术原理可以概括为：
1.  **动态编译**：在运行时调用编译器将字符串转为字节码。
2.  **环境注入**：直接调用时，强行将变量注入当前的 **环境记录 (Environment Record)**，破坏了静态词法作用域规则。
3.  **去优化 (De-opt)**：为了正确性，迫使 JS 引擎放弃静态分析和内存地址优化，转为慢速的动态属性查找。

正是因为它破坏了 JS 引擎“静态分析”代码的能力，所以被称为 `eval is evil`。


这是一个非常精准的总结。在严格模式（`'use strict'`）下，`eval` 的行为从“动态修改当前作用域”变成了“创建一个嵌套的子作用域”。

我们可以把严格模式下的 `eval` 想象成一个**透明的单向玻璃房**：
1.  **外面的人（外部作用域）** 进不去，也拿不到里面的东西（变量不泄漏）。
2.  **里面的人（eval 代码）** 可以清楚地看到外面（访问外部变量）。

下面我通过三个具体的场景代码来验证这几点。

### 场景一：验证“不泄漏” (隔离性)
在严格模式下，`eval` 内部通过 `var` 声明的变量，不会污染到外部。

```javascript
'use strict';

function strictTest() {
    // 执行 eval
    eval("var innerVar = '我是里面的秘密';");

    // 尝试在外部访问
    try {
        console.log(innerVar); 
    } catch (e) {
        console.log("❌ 报错了: " + e.message);
    }
}

strictTest();
// 输出: ❌ 报错了: innerVar is not defined
```

**对比（非严格模式）：**
如果去掉 `'use strict'`, `console.log(innerVar)` 会成功输出 `'我是里面的秘密'`，因为 `innerVar` 会被绑定到 `strictTest` 的作用域上。

---

### 场景二：验证“可读取/修改外部” (连通性)
虽然 `eval` 自己有个私有环境，但这个环境的**上级引用（Outer Reference）**依然指向调用它的环境。所以它能顺着作用域链往上找。

```javascript
'use strict';

var globalStr = "全局变量";

function accessTest() {
    var outerVar = 100;
    
    // eval 内部读取外部变量
    eval("console.log('1. 读取外部: ' + outerVar);"); // 读取局部
    eval("console.log('2. 读取全局: ' + globalStr);"); // 读取全局

    // eval 内部修改外部变量
    eval("outerVar = 999;"); 
    console.log("3. 外部变量被修改为: " + outerVar);
}

accessTest();

/* 输出:
1. 读取外部: 100
2. 读取全局: 全局变量
3. 外部变量被修改为: 999
*/
```

**原理解析：**
`eval` 内部执行 `outerVar = 999` 时，引擎在自己的私有环境中找不到 `outerVar`，于是沿着作用域链去上层（`accessTest` 的环境）找，找到了并修改了它。

---

### 场景三：同名变量的“遮蔽效应” (最能体现私有环境)
这是最能证明“eval 拥有独立私有环境”的例子。如果我们在 `eval` 内部声明一个和外部同名的变量，严格模式下它们互不影响。

```javascript
'use strict';

function shadowTest() {
    var a = "我是外面的旧值";

    eval("var a = '我是里面的新值'; console.log('内部: ' + a);");

    console.log("外部: " + a);
}

shadowTest();

/* 输出:
内部: 我是里面的新值
外部: 我是外面的旧值
*/
```

**深度解析：**
*   **在严格模式下**：`eval` 创建了一个新的声明环境。内部的 `var a` 声明在**这个新环境**里。当 `eval` 打印 `a` 时，用的是新环境的 `a`。当 `eval` 结束，新环境销毁。外部的 `console.log(a)` 访问的是 `shadowTest` 环境里的 `a`，它从未被改变。
*   **在非严格模式下**：`eval` 不会创建新环境，内部的 `var a` 实际上会被视为对外部 `a` 的重复声明（被忽略），然后赋值操作会直接把外面的 `a` 改成 `'我是里面的新值'`。此时外部打印的也会是新值。

### 总结图示

在 `'use strict'` 下执行 `eval('var b = 2; console.log(a)')`：

```text
[ 全局作用域 ]
      ^
      |
[ 函数作用域 (var a = 1) ]  <-- 外部作用域
      ^
      | (作用域链查找方向)
      |
[ Eval 作用域 (var b = 2) ] <-- 私有词法环境
    - 声明了 b (只在这里有效)
    - 访问 a (这里没有，向上找到函数作用域的 a)
```

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-template)