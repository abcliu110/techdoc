<div id="chap-property"></div>

[⬆️ 返回目录](#catalog)


## 面向对象-属性

在 JavaScript（特别是基于 V8 引擎的环境，如 Chrome 和 Node.js）中，对象的属性在底层被分为两种主要类型，这决定了它们在遍历时的**顺序**和**存储方式**。

你提到的“常规属性”和“排序属性”通常指的是：

1.  **排序属性 (Sorting Properties / Elements)**：指**整数索引**属性。
2.  **常规属性 (Ordinary Properties / Named Properties)**：指**非整数的字符串**属性。

以下是它们的详细区别、遍历规则以及底层原理。

---

### 1. 核心区别与遍历规则

自 ES6 (ECMAScript 2015) 规范开始，JS 对象的键（Key）在遍历（如 `Object.keys`, `for...in`, `Reflect.ownKeys`）时遵循明确的顺序规则：

**规则优先级：**
1.  **先遍历“排序属性”**：按照数字大小升序排列（0, 1, 2...）。
2.  **再遍历“常规属性”**：按照属性被**创建的时间顺序**排列（先添加的先遍历）。
3.  **最后遍历 Symbol 属性**：按照创建时间顺序。

#### 代码演示

```javascript
const obj = {};

// 添加常规属性（字符串）- 乱序添加
obj.c = "c";
obj.b = "b";
obj.a = "a";

// 添加排序属性（整数索引）- 乱序添加
obj[2] = "Integer 2";
obj[1] = "Integer 1";
obj[100] = "Integer 100";

// 添加一个看起来像数字但其实是常规属性的键（浮点数或负数）
obj[2.5] = "Float 2.5";
obj[-1] = "Negative -1";

// 打印键的顺序
// 注意：Object.keys 返回的是字符串数组
console.log(Object.keys(obj));

/* 
输出结果顺序：
[
  "1", "2", "100",    <-- 排序属性（升序）
  "c", "b", "a",      <-- 常规属性（插入顺序）
  "2.5", "-1"         <-- 也是常规属性（插入顺序，因为它们不是合法的数组索引）
] 
*/
```

---

### 2. 详细解析

#### 什么是“排序属性” (Integer Indices)
*   **定义**：属性名是一个字符串，但它看起来像一个非负整数（例如 `"0"`, `"10"`, `"999"`）。注意：`"1.2"` 或 `"-5"` 不算。
*   **特点**：无论你什么时候插入，它们总是**排在最前面**，并且按照**数字大小升序**排列。
*   **V8 内部叫法**：`elements`。
*   **目的**：这是为了优化数组操作。JS 的数组本质上也是对象，数组下标就是这类属性。引擎将它们存储在连续的内存空间中，访问速度非常快（类似 C++ 的数组）。

#### 什么是“常规属性” (Ordinary Properties)
*   **定义**：所有不属于整数索引的字符串属性（包括字母、浮点数字符串、负数字符串）。
*   **特点**：排在排序属性之后，严格遵守**先进先出（FIFO）**的插入顺序。
*   **V8 内部叫法**：`properties`。
*   **目的**：用于存储对象的命名属性（如 `name`, `age`）。

---

### 3. 底层原理（V8 引擎视角）

为了提高性能，V8 引擎在对象内部使用了两个不同的数据结构来存储这两类属性：

1.  **elements（存储排序属性）**：
    *   存储所有整数索引属性。
    *   通常主要用于数组。
    *   结构通常是线性的，支持快速随机访问。

2.  **properties（存储常规属性）**：
    *   存储其他命名属性。
    *   根据属性数量的不同，V8 会在三种模式间切换（对象内属性、快属性、慢属性/字典模式），以平衡内存和速度。

### 4. 为什么要了解这个？

1.  **预测循环顺序**：在面试或实际开发中，如果你依赖 `for (let key in obj)` 的顺序，必须知道数字键会被提权置顶。
2.  **性能优化**：
    *   如果你把对象当作数组用（全是整数键），引擎会优化为线性存储，速度极快。
    *   如果你把对象当作哈希表（Map）用，且键是混乱的字符串，引擎会走字典模式。
3.  **JSON 序列化**：`JSON.stringify(obj)` 也会遵循这个顺序规则，这在某些需要对签名进行校验（Key 顺序敏感）的后端接口调试中很重要。

### 总结

| 属性类型 | 定义示例 | 遍历顺序 | 存储位置 (V8) |
| :--- | :--- | :--- | :--- |
| **排序属性** | `"0"`, `"10"`, `"5"` | **最优先**，按数字**升序** | `elements` |
| **常规属性** | `"name"`, `"age"`, `"1.5"` | 次之，按**插入时间** | `properties` |

**一句话口诀：先数（数字升序），后串（字符串插入序）。**

当然可以。为了让你更直观地理解“排序属性”和“常规属性”的区别，我们可以写两段代码：

1.  **现象验证代码**：直接运行查看 JS 引擎真实的输出顺序。
2.  **逻辑模拟代码**：用 JavaScript 写一个简单的“模拟引擎”，复现 V8 底层是如何分类和存储这两种属性的。

---

### 1. 现象验证代码（真实运行）

你可以直接把这段代码复制到浏览器的控制台（F12 -> Console）或 Node.js 中运行。

```javascript
// 创建一个空对象
const obj = {};

console.log("--- 步骤 1: 添加常规属性（字符串） ---");
// 我们先添加字符串属性，按 A -> C -> B 的顺序
obj["A_first"] = "我是第一个加的";
obj["C_third"] = "我是第三个加的";
obj["B_second"] = "我是第二个加的";

console.log("--- 步骤 2: 添加排序属性（整数索引） ---");
// 我们后添加整数属性，且顺序是乱的：100 -> 1 -> 50
obj[100] = "索引 100";
obj[1]   = "索引 1";
obj[50]  = "索引 50";

console.log("--- 步骤 3: 添加'伪'数字属性 ---");
// 小数和负数，虽然是数字，但被视为“常规属性”
obj[2.5] = "小数 2.5";
obj[-5]  = "负数 -5";

// --- 见证奇迹的时刻 ---
const keys = Object.keys(obj);

console.log("最终遍历顺序：");
console.log(keys);

// 验证逻辑：
// 1. 所有的整数索引（1, 50, 100）跑到了最前面，且自动排序了。
// 2. 常规属性（A, C, B, 2.5, -5）排在后面，且严格遵守了“先来后到”的插入顺序。
```

**预期输出结果：**
```js
[
  "1", "50", "100",           // 排序属性（升序）
  "A_first", "C_third", "B_second", // 常规属性（按插入顺序）
  "2.5", "-5"                 // 小数和负数也是常规属性（按插入顺序）
]
```

---

### 2. 逻辑模拟代码（模拟 V8 内部处理）

这段代码并非 V8 的 C++ 源码，而是用 JS **模拟** V8 引擎在拿到一个属性时的决策过程。这能帮你建立心理模型。

```javascript
class V8ObjectSimulator {
    constructor() {
        this.elements = [];   // 模拟排序属性存储区 (数组结构)
        this.properties = []; // 模拟常规属性存储区 (链表/队列结构)
    }

    // 模拟设置属性的方法
    setProperty(key, value) {
        // 判断是否为“排序属性”（即有效的数组索引）
        if (this.isSortingProperty(key)) {
            console.log(`[引擎日志] 识别到排序属性: ${key} -> 存入 elements`);
            this.elements.push({ key: String(key), value });
            // 关键点：elements 总是保持排序状态
            this.elements.sort((a, b) => Number(a.key) - Number(b.key));
        } else {
            console.log(`[引擎日志] 识别到常规属性: ${key} -> 存入 properties`);
            // 关键点：properties 只是简单的追加（FIFO）
            this.properties.push({ key: String(key), value });
        }
    }

    // 核心判断逻辑：是否为 0 ~ 2^32-2 之间的整数
    isSortingProperty(key) {
        const num = Number(key);
        // 1. 是数字 2. 是整数 3. 在有效范围内
        return !isNaN(num) && Number.isInteger(num) && num >= 0 && num < 4294967295;
    }

    // 模拟遍历方法
    getKeys() {
        // 规则：先输出 elements，再输出 properties
        const sortedKeys = this.elements.map(item => item.key);
        const namedKeys = this.properties.map(item => item.key);
        return [...sortedKeys, ...namedKeys];
    }
}

// --- 运行模拟 ---
const simObj = new V8ObjectSimulator();

simObj.setProperty("name", "Alice"); // 常规
simObj.setProperty("10", "Ten");     // 排序
simObj.setProperty("age", 18);       // 常规
simObj.setProperty("2", "Two");      // 排序
simObj.setProperty("-1", "Negative");// 常规（负数）

console.log("\n--- 模拟引擎输出的顺序 ---");
console.log(simObj.getKeys()); 
// 结果应该也是：["2", "10", "name", "age", "-1"]
```

### 总结关键点

通过上面的代码模拟，你可以清晰地看到：

1.  **抢占式排序**：无论你什么时候插入整数 Key（如 `obj[2]`），它在底层会被立刻归类到 `elements` 桶里并排序，所以在遍历时它总是出现在最前面。
2.  **严格的队列**：非整数 Key（如 `name`, `-1`, `2.5`）会被归类到 `properties` 桶里，谁先来谁就排在前面，不会被重新排序。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-property)