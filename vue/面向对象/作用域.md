<div id="chap-scope"></div>

[⬆️ 返回目录](#catalog)


## 作用域

这是一个非常经典且重要的编程语言概念。弄清楚这个，你就能彻底理解为什么 JavaScript 里的 `this` 总是那么让人头疼。

直接给结论：**JavaScript 只有静态作用域（词法作用域），没有动态作用域。**

但是，JS 中的 `this` 关键字的表现，**非常像**动态作用域。这通常是混乱的根源。

---

### 1. 静态作用域 (Static / Lexical Scope)
**口诀：看“出生地”（写代码的位置），不看“调用地”。**

JavaScript 采用的就是这种。

*   **定义**：函数的作用域在函数**定义的时候**就决定了。
*   **规则**：当函数需要查找一个变量时，它会去**写这个函数的地方**向外层查找，而不管这个函数是在哪里被调用的。

**经典面试题代码：**

```javascript
var value = 1;

function foo() {
  console.log(value); // 查找 value
}

function bar() {
  var value = 2; // 局部变量
  foo(); // 在这里调用 foo
}

bar();
```

**解析（JS 的行为）：**
1.  `bar()` 被调用，内部定义了 `value = 2`。
2.  `bar` 内部调用了 `foo()`。
3.  `foo` 开始执行，想要打印 `value`。
4.  **关键点**：`foo` 是在全局定义的（出生在全局）。
5.  所以 `foo` 往自己的**出生地**外层找，找到了全局的 `value = 1`。
6.  **结果**：输出 `1`。

---

### 2. 动态作用域 (Dynamic Scope)
**口诀：看“调用地”，不看“出生地”。**

Bash (Shell 脚本) 和 Perl 等语言采用这种模式。**JS 没有这个机制**，但我们需要假装它有，来对比理解。

**如果 JS 是动态作用域，上面的代码会发生什么？**

1.  `bar()` 被调用，内部定义了 `value = 2`。
2.  `bar` 内部调用了 `foo()`。
3.  `foo` 开始执行，想要打印 `value`。
4.  **关键点**：`foo` 是被 `bar` 调用的。
5.  所以 `foo` 会顺着**调用栈**往回找，发现 `bar` 里有个 `value = 2`。
6.  **结果**：会输出 `2`。

> **总结区别**：静态作用域像**“户籍制度”**（生在哪里就是哪里人）；动态作用域像**“传家宝”**（谁喊我干活，我就用谁兜里的钱）。

---

### 3. JavaScript 唯一的“叛徒”：`this`

虽然 JS 的变量查找是严格的静态作用域，但 **`this` 关键字是动态绑定的**。

**`this` 的指向完全取决于函数“怎么被调用”，而不是“在哪里定义”。**

#### 例子 A：普通函数的动态性
```javascript
const obj = {
  name: "余天山",
  sayName: function() {
    console.log(this.name);
  }
};

const fn = obj.sayName;

obj.sayName(); // 输出 "余天山" (this 指向 obj，因为是 obj 调用的)
fn();          // 输出 undefined (this 指向全局/window，因为是直接调用的)
```
看，同一个函数，调用方式不同，`this` 就变了。这就是**动态作用域**的特征。

#### 例子 B：箭头函数的静态性 (修复叛徒)
ES6 引入箭头函数 (`=>`)，最大的作用就是**强行把 `this` 变成静态作用域（词法作用域）**。

```javascript
const obj = {
  name: "余天山",
  sayName: () => {
    // 箭头函数没有自己的 this
    // 它会像查找变量一样，去“出生地”的外层找 this
    console.log(this.name);
  }
};

obj.sayName(); 
// 输出 undefined。
// 因为箭头函数定义在 obj 对象里，obj 在全局作用域。
// 所以它在定义时就捕获了全局的 this (window/global)，而不是 obj。
```

---

### 4. 总结

1.  **变量作用域**：JavaScript 是**静态作用域**（Lexical Scope）。函数能访问哪些变量，在代码写好的那一刻就定死了。
2.  **`this` 上下文**：普通函数的 `this` 表现得像**动态作用域**（取决于调用者）。
3.  **箭头函数**：让 `this` 回归**静态作用域**（取决于定义位置）。

理解了这一点，你就明白了为什么 React 或 NestJS 里经常要用 `() => this.method()` 或者 `.bind(this)` —— 这本质上是在与 `this` 的动态性做斗争，试图把它“钉”在静态的词法环境里。

这是一个非常深刻且容易混淆的问题！你问到了 JavaScript 语言设计的核心规则。

直接回答你：**在 JavaScript 中，对象字面量（Object Literal）的大括号 `{ ... }` 确实不算作一个“作用域（Scope）”。**

这看起来很不直观，因为 `if` 语句的大括号是作用域，`for` 循环的大括号也是作用域，为什么偏偏对象的 `{}` 就不是？

我们要从**“作用域的定义”**和**“大括号的二义性”**两个角度来拆解。

---

### 1. 核心误区：大括号的双重身份

在 JavaScript 中，`{ ... }` 这一对符号有两种完全不同的含义，取决于它出现在哪里：

*   **含义 A：代码块（Block）—— 这是一个作用域**
    出现在 `if`、`for`、`while` 或者单独使用时。
    ```javascript
    if (true) {
      let a = 1; // 这里的 {} 是一堵墙，外面访问不到 a
    }
    ```

*   **含义 B：对象字面量（Object）—— 这只是一个“值”**
    出现在赋值符号 `=` 右边，或者作为参数传递时。
    ```javascript
    const obj = {
      name: "余天山"
    };
    ```
    **关键点：** 这里的 `{}` 仅仅是一种**数据格式**的写法（就像字符串用引号 `""` 一样）。它只是把一堆键值对包起来，**并没有创造一个新的代码执行环境（作用域）**。

---

### 2. 怎么证明“对象不是作用域”？

如果 `obj` 的大括号是一个作用域，那么我们在里面定义的属性，应该能像变量一样被直接访问。但实际上是不行的。

**反证法：**

```javascript
const obj = {
  a: 1,
  b: () => {
    // 如果 obj 是一个作用域，那么 a 应该就在这个作用域里
    // 我们应该可以直接打印 a，不需要加 this.
    console.log(a); 
  }
};

obj.b(); // ❌ 报错：ReferenceError: a is not defined
```
**解析：**
*   如果是作用域，`console.log(a)` 应该能找到头顶上的 `a: 1`。
*   但报错说明，`b` 函数往外看的时候，**直接看穿了 `obj` 的大括号**，看到了全局作用域，而全局作用域里没有 `a`。

---

### 3. 形象的比喻：房间 vs 书包

为了理解箭头函数的 `this` 穿透，我们可以打个比方：

*   **作用域（Scope）** 是一个**房间**。
*   **对象（Object）** 是一个放在房间地上的**透明书包**。
*   **箭头函数** 是书包里的一个**摄像头**。

现在情况是这样的：
1.  你（代码）在一个大房间里（全局作用域 `Global Scope`）。
2.  你在地上放了一个书包 `obj`。
3.  书包里放了一个摄像头（箭头函数）。

**箭头函数的特性是：** 它没有自己的视角，它**死板地继承**它被定义时所在的**房间**的视角。

当你问摄像头（箭头函数）：“`this` 是哪里？”
*   它不会说：“我在书包里”。（因为书包不是房间）
*   它会说：“我在**大房间**里”。（因为它透过透明书包，看到自己是在大房间里被定义的）。

所以 `this` 指向的是 `window`（大房间），而不是 `obj`（书包）。

---

### 4. 那普通函数为什么可以？

你可能会问，那为什么改成 `function` 就可以指向 `obj` 呢？

```javascript
const obj = {
  name: "余天山",
  sayName: function() {
    console.log(this.name); // ✅ 输出 "余天山"
  }
};
obj.sayName();
```

因为**普通函数**的 `this` 是**动态绑定**的，它是个“变色龙”。
它根本不在乎自己定义在哪里（不在乎作用域）。它只在乎**谁在调用它**。
*   因为是 `obj.sayName()` 调用的。
*   所以 `this` 就变成了 `obj`。

**区别总结：**
*   **箭头函数**：看户口本（静态作用域）。它发现 `obj` 不是一个户口管辖区（作用域），所以直接往上找全局户口。
*   **普通函数**：看老板（调用者）。谁喊我，我就指向谁。

### 总结

*   `obj` 的 `{}` 仅仅是**定义数据的语法**，**不是代码执行的作用域**。
*   在 JS 中，能创造作用域的只有：**函数**、**全局**、**代码块（if/for等）**。
*   因为 `obj` 不是作用域，所以定义在里面的箭头函数会**无视** `obj`，直接捕获外层的 `this`（通常是 Window 或 Undefined）。

这是一个非常经典的作用域陷阱！你被 JavaScript 的“隐式全局变量”机制给骗了。

这里能访问到 `a`，**并不是因为作用域没生效**，而是因为你定义变量的**方式**不对。

我们把代码拆解来看，问题出在第一行：

### 1. 罪魁祸首：`a = 1;`

```javascript
{
    a = 1; // ❌ 注意：这里没有 var, let, 或 const
}
```

在 JavaScript（非严格模式）中，当你直接给一个**未声明**的变量赋值时，JS 引擎会做一件非常“流氓”的事情：

1.  它先在当前块级作用域找，没找到 `a` 的声明。
2.  它往外层找，也没找到。
3.  一直找到全局作用域（Global Scope），还是没找到。
4.  **引擎决定：** “既然你没声明，那我就好心帮你把 `a` 挂在**全局对象（window）** 上吧。”

所以，虽然 `{ ... }` 确实是一个块级作用域，但 `a = 1` 这行代码直接**穿透**了这个墙壁，在全局创建了一个 `window.a = 1`。

### 2. 对比：如果加了 `let` 会怎样？

如果你在代码里加上 `let` 或 `const`，你的逻辑就完全正确了：

```javascript
{
    let a = 1; // ✅ 声明了块级变量
} // ⬅️ 出了这个花括号，a 就死了（被销毁了）

const obj = {
    b: function () {
        console.log(a);
    }
};

obj.b(); // ❌ 报错：ReferenceError: a is not defined
```

在这种情况下，`{}` 确实成功地把 `a` 关在了里面。因为 `let` 声明让 `a` 变成了块级作用域变量。

### 3. 还有一个误解：`obj` 里的 `a: 1`

```javascript
const obj = {
    a: 1, // 这是属性，叫 obj.a
    b: function () {
        console.log(a); // 这是变量查找，找的是 a
    }
};
```

一定要分清：
*   `obj` 里的 `a: 1` 是对象的**属性**。
*   `console.log(a)` 里的是**变量**。

当 `b` 函数执行时，它找 `a` 的路径是：
1.  函数 `b` 内部有局部变量 `a` 吗？ -> 没有。
2.  外层有变量 `a` 吗？ -> **找到了！**（就是第一步里那个漏到全局的 `a = 1`）。

**它绝对不会去读 `obj.a`**。如果你想读 `obj` 里的那个 `a`，你必须写 `this.a` 或者 `obj.a`。

### 总结

你的代码之所以能运行，是因为：

1.  **`{}` 是块级作用域** —— 这点你理解是对的。
2.  **但是 `a = 1`（无声明赋值）不仅无视作用域，还直接创建了全局变量** —— 这是导致能访问的根本原因。

*建议：永远使用 `let` 或 `const` 声明变量，并开启 `"use strict"` 模式，这样 `a = 1` 这种写法会直接报错，避免这种隐式全局变量的坑。*

这是一个非常经典的作用域陷阱！你被 JavaScript 的“隐式全局变量”机制给骗了。

这里能访问到 `a`，**并不是因为作用域没生效**，而是因为你定义变量的**方式**不对。

我们把代码拆解来看，问题出在第一行：

### 1. 罪魁祸首：`a = 1;`

```javascript
{
    a = 1; // ❌ 注意：这里没有 var, let, 或 const
}
```

在 JavaScript（非严格模式）中，当你直接给一个**未声明**的变量赋值时，JS 引擎会做一件非常“流氓”的事情：

1.  它先在当前块级作用域找，没找到 `a` 的声明。
2.  它往外层找，也没找到。
3.  一直找到全局作用域（Global Scope），还是没找到。
4.  **引擎决定：** “既然你没声明，那我就好心帮你把 `a` 挂在**全局对象（window）** 上吧。”

所以，虽然 `{ ... }` 确实是一个块级作用域，但 `a = 1` 这行代码直接**穿透**了这个墙壁，在全局创建了一个 `window.a = 1`。

### 2. 对比：如果加了 `let` 会怎样？

如果你在代码里加上 `let` 或 `const`，你的逻辑就完全正确了：

```javascript
{
    let a = 1; // ✅ 声明了块级变量
} // ⬅️ 出了这个花括号，a 就死了（被销毁了）

const obj = {
    b: function () {
        console.log(a);
    }
};

obj.b(); // ❌ 报错：ReferenceError: a is not defined
```

在这种情况下，`{}` 确实成功地把 `a` 关在了里面。因为 `let` 声明让 `a` 变成了块级作用域变量。

### 3. 还有一个误解：`obj` 里的 `a: 1`

```javascript
const obj = {
    a: 1, // 这是属性，叫 obj.a
    b: function () {
        console.log(a); // 这是变量查找，找的是 a
    }
};
```

一定要分清：
*   `obj` 里的 `a: 1` 是对象的**属性**。
*   `console.log(a)` 里的是**变量**。

当 `b` 函数执行时，它找 `a` 的路径是：
1.  函数 `b` 内部有局部变量 `a` 吗？ -> 没有。
2.  外层有变量 `a` 吗？ -> **找到了！**（就是第一步里那个漏到全局的 `a = 1`）。

**它绝对不会去读 `obj.a`**。如果你想读 `obj` 里的那个 `a`，你必须写 `this.a` 或者 `obj.a`。

### 总结

你的代码之所以能运行，是因为：

1.  **`{}` 是块级作用域** —— 这点你理解是对的。
2.  **但是 `a = 1`（无声明赋值）不仅无视作用域，还直接创建了全局变量** —— 这是导致能访问的根本原因。

*建议：永远使用 `let` 或 `const` 声明变量，并开启 `"use strict"` 模式，这样 `a = 1` 这种写法会直接报错，避免这种隐式全局变量的坑。*


这是一个非常经典的作用域误解。你产生这个疑问，是因为你把 **“块级作用域（Block Scope）”** 的规则，强行套用在了 **`var`** 身上。

直接回答你：
**对 `var` 来说，单独的大括号 `{ ... }` 根本就不是一个作用域，它就像空气一样透明。**

---

### 1. 核心原因：`var` 的“穿墙术”

在 JavaScript 中：
*   **`let` 和 `const`**：非常听话。它们认为 **任何** `{ ... }`（包括 `if`, `for`, 或者裸写的 `{}`）都是墙，出不去。
*   **`var`**：非常霸道。它**只承认** **函数 `function() { ... }`** 是墙。除了函数，其他的 `{ ... }` 对它来说都不存在。

**你的代码：**
```javascript
{
    var a = 1; 
}
```

**JS 引擎眼里的代码（变量提升）：**
因为 `{}` 挡不住 `var`，JS 引擎在编译阶段，会把 `a` **提**到当前作用域的顶端（通常是全局，或者外层函数顶部）。

实际上，JS 执行的是这样的代码：

```javascript
var a; // 1. 声明被提到了外面（顶层）

{
    a = 1; // 2. 赋值还在原地
}

// ... 后面 obj.b() 访问的就是这个顶层的 a
```

所以，`a` 并没有被困在 `{}` 里，它泄露到了全局（或者外层函数作用域）。这就是为什么 `obj.b()` 能访问到它。

---

### 2. 对比：如果换成 `let`

如果你把 `var` 换成 `let`，你的预期就会成真了：

```javascript
{
    let a = 1; // ✅ let 承认 {} 是墙
} // ⬅️ a 在这里就被销毁了

const obj = {
    b: function () {
        console.log(a); 
    }
};

obj.b(); // ❌ 报错：ReferenceError: a is not defined
```

**解析**：
*   `let` 是块级作用域。
*   它被 `{}` 牢牢锁在里面。
*   当 `obj.b()` 试图找 `a` 时，发现全局没有 `a`（因为里面的 `a` 没漏出来），于是报错。

---

### 3. 为什么 ES6 之前我们要用“立即执行函数 (IIFE)”？

在 `let` 出现之前的年代（2015年以前），因为普通的 `{}` 关不住 `var`，程序员为了造出一个“封闭的空间”来隐藏变量，被迫使用**函数**来模拟块级作用域。

你可能见过这种古老的写法：

```javascript
// 古代的块级作用域写法
(function() {
    var a = 1; // 被函数包起来了，出不去了
})();

// 下面访问不到 a
```

这侧面证明了：**想要关住 `var`，必须用函数；普通的 `{}` 是没用的。**

### 总结

*   **`{ var a = 1 }`**：**没有**创建独立作用域。`a` 会“穿墙”而出，变成全局变量（或外层函数变量）。
*   **`{ let a = 1 }`**：**创建了**独立作用域。`a` 被关在里面。
*   **`{ a = 1 }`** (你上一个问题)：更糟糕，这是**隐式全局变量**，连变量提升都不需要，直接挂在 window 上。

所以，现在的开发准则就是：**彻底抛弃 `var`，只用 `let` 和 `const`**，这样你的大括号 `{}` 才是真正安全的防火墙。

这是一个非常深刻且触及 JS 引擎底层设计的问题！能问出这个问题，说明你对作用域的思考已经非常深入了。

**你的直觉是对的：** 这里确实存在“逻辑矛盾”。
如果 `i` 在每次循环里都是一个新的变量（新的作用域），那它怎么知道上一次循环结束时 `i` 是多少？谁把 `0` 变成 `1` 的？

答案是：**这是 JavaScript 引擎为 `for` 循环中的 `let` 专门设计的“特殊魔法”机制。**

我们可以把这个机制拆解为三个阶段来理解：**父子作用域**、**值传递**、**变量复制**。

---

### 1. 并没有那么简单：其实有两个“i”

在 `for (let i = 0; ...)` 这种语法中，JS 引擎实际上创建了**两层**作用域：

1.  **循环头作用域（父作用域）**：这里的 `let i` 负责驱动循环的进行（比如判断 `i < 3`，执行 `i++`）。
2.  **循环体作用域（子作用域）**：每次循环体 `{ ... }` 执行时，都会创建一个全新的环境，并且**里面也有一个 `i`**。

### 2. 引擎在后台做了什么？（伪代码模拟）

为了实现“每次循环都是独立作用域”且“还能自增”，JS 引擎在底层把你的代码“重写”成了类似这样（便于理解的伪代码）：

**你的代码：**
```javascript
for (let i = 0; i < 3; i++) {
    console.log(i);
}
```

**引擎实际执行的逻辑（魔法拆解）：**

```javascript
{
    // 【阶段 1：父作用域】
    // 这是真正负责计数的 i
    let _parent_i = 0; 

    while (_parent_i < 3) {
        // 【阶段 2：魔法时刻 —— 值的接力】
        // 每次进入循环体，引擎都会创建一个【全新的变量 k】
        // 并把父作用域当前的 _parent_i 的值【复制】给它
        let i = _parent_i; 
        
        // 【阶段 3：子作用域】
        // 这里的代码块也就是你的循环体
        {
            // 你在循环里用的 i，其实是这个局部的 i
            // 因为 let i 是块级作用域，所以它被锁死在这个 {} 里了
            setTimeout(() => { console.log(i); }, 100);
        }

        // 【阶段 4：迭代更新】
        // 父作用域的 i 继续自增，准备下一轮
        _parent_i++;
    }
}
```

### 3. 回答你的核心疑问

> **问题 1：for循环是会有多个作用域？**

**是的。**
每一次进入 `{ ... }` 都会生成一个**全新的**词法环境（Lexical Environment）。
*   第一次循环，生成了 **Scope_1**，里面锁着 `i = 0`。
*   第二次循环，生成了 **Scope_2**，里面锁着 `i = 1`。
*   `setTimeout` 因为闭包原理，各自抓住了自己那个作用域里的 `i`。

> **问题 2：如果有多个作用域的话，为什么会自增？**

**关键在于“复制”而非“共享”。**
它们并不是都在操作同一个 `i`。
1.  循环的**驱动层**（父作用域）有一个母版 `i`，它一直在自增（0 -> 1 -> 2）。
2.  每次进入下一次循环前，JS 引擎会把**母版 `i` 当前的值**，“拷贝”一份给**新的子作用域**里的 `i`。

就像是**接力赛**：
*   第一棒跑完（`i=0`），把棒子里的信息（值）复制一份给第二棒。
*   第二棒拿着新的棒子（全新的变量），但上面的数字是接着上一棒的（`i=1`）。
*   它们是**不同的人**（不同的作用域/变量），但传递了**信息**（值）。

### 4. 铁证：证明变量是“复制”出来的

如果 `for` 循环里的 `i` 只是同一个变量在自增，那我们用 `const` 应该会报错，对吧？

**来看这个有趣的例子：**

```javascript
// 注意：这里用 const，通常 for 循环里用 const 会报错，但我们看 for-of
for (const i of [1, 2, 3]) {
    setTimeout(() => {
        console.log(i); // 输出 1, 2, 3
    }, 100);
}
```

这里为什么 `const` 不报错？
因为每次循环的 `i` **都是一个全新的变量**！如果是同一个变量在修改值，`const` 早就报错了。

而在普通的 `for (let i = 0; i < 3; i++)` 中：
*   `i++` 修改的是**父作用域**里的那个 `i`。
*   循环体里的 `i` 只是被初始化为当前值，之后并没有被修改。

### 总结

`for` 循环配合 `let` 之所以能实现你看到的效果，是因为 JS 引擎做了一个**“作弊”**操作：

它**不是**让同一个 `i` 在不同的作用域里穿梭。
而是**每一轮都生出一个新的 `i`**，并把**上一轮算好的值**赋给这个新 `i`。

这就是为什么：
1.  **能自增**：因为父作用域在控制计数。
2.  **能独立**：因为子作用域拿到的是全新的变量（虽然值是拷贝过来的）。

这个问题问得非常到位！

`for...of` 循环的底层机制与普通的 `for(let i=0;...)` 循环是完全不同的。

`for (let i = 0; i < 3; i++)` 是基于**数值索引**和**自增**的。
而 `for (const i of [1, 2, 3])` 是基于 **迭代器 (Iterator)** 的。

我们可以把这段代码“翻译”（Desugar / 去糖化）成底层的 `while` 循环，你就明白为什么它能用 `const` 且拥有独立作用域了。

---

### 底层转换（伪代码模拟）

JS 引擎在执行 `for...of` 时，实际上做了这几步操作：

1.  **获取迭代器**：调用数组的 `Symbol.iterator` 方法。
2.  **开启循环**：不断调用迭代器的 `next()` 方法。
3.  **创建独立作用域**：在**每次**循环的内部，声明一个**全新**的 `const i`，并赋值。

**它大概被转换成了这样：**

```javascript
// 1. 获取数组的迭代器
const iterator = [1, 2, 3][Symbol.iterator]();
let result = iterator.next();

// 2. 开始循环
while (!result.done) {
    // 3. 【关键点】：作用域在这里开始
    { 
        // 引擎在每一次循环里，都重新声明了一个 const 变量！
        // 这里的 result.value 分别是 1, 2, 3
        const i = result.value; 

        // 你的业务代码
        setTimeout(() => {
            console.log(i); 
        }, 100);
    } 
    // 【关键点】：作用域在这里结束，变量 i 被销毁（但被闭包引用了）

    // 准备下一轮
    result = iterator.next();
}
```

---

### 核心疑问解答

#### 1. 为什么这里能用 `const`？
在普通的 `for (const i = 0; i < 3; i++)` 里，`i++` 试图修改 `i` 的值，而 `const` 禁止修改，所以会报错。

但在 `for...of` 的转换代码中，你看不到 `i++` 这样的操作。
*   `i` 只是在每次循环里**被初始化（赋值）了一次**。
*   下一次循环时，那是**另一个全新的作用域**里的**另一个全新的 `const i`**。
*   同一个作用域内的 `const i` 没有被修改过，所以完全合法。

#### 2. 为什么 `setTimeout` 能打印出 1, 2, 3？
这还是归功于**块级作用域**。
因为在底层的 `while` 循环里，我们人为地（或者说引擎自动地）为每一次迭代包裹了一个 `{ ... }`。

*   **第 1 轮**：
    *   创建一个盒子（Scope 1）。
    *   里面放个 `const i = 1`。
    *   `setTimeout` 拍照留念，拍到了 `1`。
*   **第 2 轮**：
    *   创建一个新盒子（Scope 2）。
    *   里面放个 `const i = 2`。
    *   `setTimeout` 拍照留念，拍到了 `2`。

这就解释了为什么 `for...of` 是现代 JS 开发中最推荐的遍历方式：**它既安全（支持 const），又直观（没有索引烦恼），而且天生自带闭包保护（不用担心作用域坑）。**

这是一个非常经典的作用域误解。你产生这个疑问，是因为你把 **“块级作用域（Block Scope）”** 的规则，强行套用在了 **`var`** 身上。

直接回答你：
**对 `var` 来说，单独的大括号 `{ ... }` 根本就不是一个作用域，它就像空气一样透明。**

---

### 1. 核心原因：`var` 的“穿墙术”

在 JavaScript 中：
*   **`let` 和 `const`**：非常听话。它们认为 **任何** `{ ... }`（包括 `if`, `for`, 或者裸写的 `{}`）都是墙，出不去。
*   **`var`**：非常霸道。它**只承认** **函数 `function() { ... }`** 是墙。除了函数，其他的 `{ ... }` 对它来说都不存在。

**你的代码：**
```javascript
{
    var a = 1; 
}
```

**JS 引擎眼里的代码（变量提升）：**
因为 `{}` 挡不住 `var`，JS 引擎在编译阶段，会把 `a` **提**到当前作用域的顶端（通常是全局，或者外层函数顶部）。

实际上，JS 执行的是这样的代码：

```javascript
var a; // 1. 声明被提到了外面（顶层）

{
    a = 1; // 2. 赋值还在原地
}

// ... 后面 obj.b() 访问的就是这个顶层的 a
```

所以，`a` 并没有被困在 `{}` 里，它泄露到了全局（或者外层函数作用域）。这就是为什么 `obj.b()` 能访问到它。

---

### 2. 对比：如果换成 `let`

如果你把 `var` 换成 `let`，你的预期就会成真了：

```javascript
{
    let a = 1; // ✅ let 承认 {} 是墙
} // ⬅️ a 在这里就被销毁了

const obj = {
    b: function () {
        console.log(a); 
    }
};

obj.b(); // ❌ 报错：ReferenceError: a is not defined
```

**解析**：
*   `let` 是块级作用域。
*   它被 `{}` 牢牢锁在里面。
*   当 `obj.b()` 试图找 `a` 时，发现全局没有 `a`（因为里面的 `a` 没漏出来），于是报错。

---

### 3. 为什么 ES6 之前我们要用“立即执行函数 (IIFE)”？

在 `let` 出现之前的年代（2015年以前），因为普通的 `{}` 关不住 `var`，程序员为了造出一个“封闭的空间”来隐藏变量，被迫使用**函数**来模拟块级作用域。

你可能见过这种古老的写法：

```javascript
// 古代的块级作用域写法
(function() {
    var a = 1; // 被函数包起来了，出不去了
})();

// 下面访问不到 a
```

这侧面证明了：**想要关住 `var`，必须用函数；普通的 `{}` 是没用的。**

### 总结

*   **`{ var a = 1 }`**：**没有**创建独立作用域。`a` 会“穿墙”而出，变成全局变量（或外层函数变量）。
*   **`{ let a = 1 }`**：**创建了**独立作用域。`a` 被关在里面。
*   **`{ a = 1 }`** (你上一个问题)：更糟糕，这是**隐式全局变量**，连变量提升都不需要，直接挂在 window 上。

所以，现在的开发准则就是：**彻底抛弃 `var`，只用 `let` 和 `const`**，这样你的大括号 `{}` 才是真正安全的防火墙。

**变量提升（Hoisting）** 是 JavaScript 中最容易让人“见鬼”的特性之一。

简单一句话概括：**在代码执行之前，JS 引擎会把所有的变量声明和函数声明，“移动”到当前作用域的最顶端。**

但请注意，这只是**声明**被移动了，**赋值**并没有移动。

为了彻底搞懂它，我们需要把这一过程拆解为 **JS 引擎的两个阶段**：**编译阶段（预解析）** 和 **执行阶段**。

---

### 1. `var` 的提升：只提升名字，不提升值

这是最经典的场景。

**你写的代码：**
```javascript
console.log(a); // 输出 undefined（不报错，但也没值）
var a = 10;
```

**JS 引擎“编译”后的代码（实际执行顺序）：**
```javascript
// 【阶段 1：编译/预解析】
var a; // 1. 发现 var a，先在内存里占个坑，默认给它填个 undefined

// 【阶段 2：执行】
console.log(a); // 2. 此时 a 只是占了坑，值是 undefined
a = 10;         // 3. 终于执行到赋值语句，把 10 填进去
```

*   **结论**：使用 `var`，你可以在声明之前访问它，但拿到的永远是 `undefined`。

---

### 2. 函数声明的提升：整体提升（一等公民）

函数声明（Function Declaration）享有最高特权。**它的名字和函数体都会被提升。**

**你写的代码：**
```javascript
sayHi(); // ✅ 输出 "Hello!" (居然能先调用再定义)

function sayHi() {
    console.log("Hello!");
}
```

**JS 引擎“编译”后的代码：**
```javascript
// 【阶段 1：编译】
function sayHi() {      // 整个函数都被提到了最顶端
    console.log("Hello!");
}

// 【阶段 2：执行】
sayHi(); // 此时内存里已经有这个函数了，所以能执行
```

*   **结论**：你可以在代码的任何位置调用函数声明。

---

### 3. 函数表达式的陷阱：变成了变量提升

这是一个巨大的坑。如果你用 `var` 定义函数，它就退化成了“变量提升”。

**你写的代码：**
```javascript
sayHi(); // ❌ 报错：TypeError: sayHi is not a function

var sayHi = function() {
    console.log("Hello!");
}
```

**JS 引擎“编译”后的代码：**
```javascript
// 【阶段 1：编译】
var sayHi; // 只提升了变量名，此时 sayHi 是 undefined

// 【阶段 2：执行】
sayHi(); // undefined() ??? -> 报错！你不能把 undefined 当函数运行

sayHi = function() { ... }; // 赋值要在后面才发生
```

---

### 4. `let` 和 `const` 的提升：暂时性死区 (TDZ)

这回到了我们之前讨论的话题。`let` 和 `const` **也有提升**，但是它们非常傲娇。

**规则**：虽然引擎知道它们在上面，但在执行到声明语句之前，**禁止访问**。

**你写的代码：**
```javascript
console.log(b); // ❌ 报错：ReferenceError
let b = 10;
```

**JS 引擎的处理：**
1.  **编译阶段**：引擎发现了 `let b`，把它提升到作用域顶端。**但是！** 引擎给它打了个标签：“未初始化（Uninitialized）”。
2.  **执行阶段**：
    *   第一行 `console.log(b)`：引擎看了一眼 `b`，发现标签是“未初始化”，于是直接抛出 ReferenceError，把你拦在**暂时性死区 (TDZ)** 里。
    *   第二行 `let b = 10`：撕掉标签，把值填进去。

---

### 5. 谁的优先级更高？（函数 vs 变量）

如果一个名字既被 `var` 声明了，又被 `function` 声明了，谁赢？

**结论：函数是老大。**

```javascript
console.log(a); // 输出：Function (函数本体)

var a = 10;
function a() {}

console.log(a); // 输出：10
```

**解析过程：**
1.  **编译阶段**：
    *   发现 `function a`：提升！此时 `a` 是函数。
    *   发现 `var a`：本来要声明一个 `undefined` 的变量，但引擎发现 `a` 已经是函数了，**于是忽略 `var a` 的声明**。
2.  **执行阶段**：
    *   第一行 log：打印出函数。
    *   `a = 10`：执行赋值，`a` 变成了 10。
    *   第二行 log：打印出 10。

---

### 总结

1.  **代码并没有真的移动**：这只是 JS 引擎在“内存准备阶段”做的事情。
2.  **`var`**：提升名字，初始化为 `undefined`。
3.  **`function`**：提升名字和函数体，可以提前调用。
4.  **`let/const`**：提升名字，但不初始化（锁进死区 TDZ），提前访问会报错。
5.  **最佳实践**：
    *   **忘掉 `var`**，它全是坑。
    *   **函数声明**放后面没问题（很多人喜欢把 helper 函数放文件底部）。
    *   **变量声明**永远写在作用域最开头（使用 `let/const` 自然就养成了这个习惯）。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-scope)