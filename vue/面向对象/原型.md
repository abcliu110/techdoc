<div id="chap-prototype"></div>

[⬆️ 返回目录](#catalog)


## 原型
这是一个非常经典的 JavaScript 语言设计问题。

要理解“为什么函数可以被 new”，我们需要回到 1995 年 JavaScript 诞生的那一刻。这背后的设计理念是：**“市场营销的妥协”** 与 **“函数式编程的内核”** 的奇怪结合。

### 核心答案

JavaScript 之所以允许 `new` 一个函数，是因为在 JS 的设计理念中，**没有真正的“类”（Class）**（至少在 ES6 之前）。

JS 采用的是 **基于原型（Prototypal）** 的面向对象系统，而不是 **基于类（Class-based）** 的系统。为了让熟悉 Java 的程序员能看懂这门语言，设计者（Brendan Eich）强行把函数的调用方式包装成了像 Java 类一样的构造过程。

---

### 一、 历史背景：为了像 Java (The Java Trap)

1995 年，Netscape 公司开发 JavaScript 时，接到的命令是：**“这门语言必须看起来像 Java，因为 Java 现在很火。”**

*   **Java 的方式**：先定义 `class`，然后 `new ClassName()`。
*   **JS 的内核**：参考了 Scheme（函数式语言）和 Self（原型语言）。在这些语言里，根本没有“类”的概念，只有对象和函数。

**矛盾出现了**：内核里没有类，但语法必须像类。
**解决方案**：**让函数（Function）身兼多职。**

于是，JS 里的函数变成了“变色龙”：
1.  **普通调用** `fn()`：它就是一个过程。
2.  **构造调用** `new fn()`：它就摇身一变，假装自己是一个“类构造器”。

---

### 二、 技术原理：`new` 到底对函数做了什么？

当你对一个函数使用 `new` 关键字时，JavaScript 引擎并没有把这个函数当成函数跑，而是把它当成一个**“生产车间”**。

`new User('Vue')` 这一行代码，在底层发生了 **4 步魔法操作**：

1.  **创建空对象**：在内存中创建一个全新的空对象 `{}`。
2.  **链接原型**：把这个新对象的 `[[Prototype]]`（即 `__proto__`）指向函数的 `prototype` 属性。
    *   *这步实现了继承：新对象能访问函数原型上的方法。*
3.  **绑定 this**：将函数内部的 `this` 强行指向这个新创建的对象。
    *   *所以 `this.name = 'Vue'` 才会生效，把属性挂在新对象上。*
4.  **返回对象**：如果函数没有手动返回对象，引擎自动返回这个新创建的对象。

**代码演示：**

```javascript
function Dog(name) {
  this.name = name;
}

// 当你写 const d = new Dog('旺财') 时
// 浏览器底层其实在做类似这样的事情：

function myNew(Constructor, ...args) {
  // 1. 创建新对象
  const obj = {};
  
  // 2. 链接原型 (让 obj 能找到 Dog.prototype 里的东西)
  Object.setPrototypeOf(obj, Constructor.prototype);
  
  // 3. 绑定 this 并执行函数 (把属性挂载到 obj 上)
  const result = Constructor.apply(obj, args);
  
  // 4. 返回结果
  // (如果构造函数自己返回了对象，就用它的；否则用我们刚创建的 obj)
  return result instanceof Object ? result : obj;
}

function User(id, name){
    this.id = id
    this.name = name
}

function NewObject(Constructor, ...args)
{
    const obj = {}
    Object.setPrototypeOf(obj, Constructor.prototype);
    const result = Constructor.apply(obj, args)
    return result instanceof Object ? result : obj
}


```

---

### 三、 设计理念：函数的一等公民地位

JS 的设计哲学是 **“函数是一等公民” (First-class Function)**。这意味着函数不仅仅是代码块，它是一个对象，它可以拥有属性，可以作为参数，也可以作为构造器。

#### 1. 复用性（经济原则）
在 C++ 或 Java 中，`class` 是模具，`method` 是行为，分得很清。
在 JS 中，设计者认为：**没必要引入一个新的复杂概念（类）。函数已经足够强大了。**
*   只要给函数加上 `new`，它就能生产对象。
*   只要不加 `new`，它就是普通逻辑。
*   **一物两用**，节省了语言设计的复杂度（虽然增加了学习者的认知负担）。

#### 2. 原型继承的自然表达
JS 的世界观里，对象是生出来的，不是模具刻出来的。
*   **Java**：上帝画图纸（Class），然后批量造人。
*   **JavaScript**：先有一个亚当（Function.prototype），然后克隆出夏娃（Instance），夏娃基于亚当修改基因。

函数在这里充当了 **“初始化逻辑的容器”**。因为没有类，我们需要一个地方来写“当对象创建时通过什么逻辑初始化属性”，函数体就是最好的地方。

---

### 四、 为什么 ES6 又出了 `class`？

既然 `function` 这么好用，为什么 ES6 还要加 `class` 关键字？

因为 **“函数即构造器”** 的设计有两个大坑：

1.  **语义模糊**：光看代码 `function User() {}`，你不知道它是一个用来 `new` 的类，还是一个用来执行的普通函数。通常只能靠**首字母大写**这种“君子协定”来区分。
2.  **`this` 的混乱**：如果原本该 `new` 的函数，你忘了写 `new` 直接调用了（`User()`），`this` 就会指向全局 `window`，导致污染全局变量。

**ES6 的 `class` 本质上还是语法糖：**
ES6 的 `class User {}` 底层依然是转化为一个构造函数。但它加了**安全限制**：如果你不加 `new` 直接调用 `class`，JS 引擎会直接报错，从而修复了旧设计的缺陷。

### 总结

JS 允许 `new` 一个函数，是因为：

1.  **历史包袱**：为了迎合 Java 程序员的习惯，把函数伪装成类。
2.  **底层机制**：JS 没有类，只有对象。函数被借用作为“对象工厂”和“初始化脚本”。
3.  **核心哲学**：利用**原型链**和**this 绑定**，强行赋予了函数“生孩子”的能力。

你可以把这个设计理解为：**一把瑞士军刀。**
普通函数是用来切菜的（执行逻辑），但如果你按住某个特殊的按钮（`new`），它就变成了一把螺丝刀（构造对象）。虽然看起来有点怪，但它在当年用最少的代码量实现了面向对象编程。

这是一个非常棒的**思维模型（Mental Model）**！

你的理解其实已经触及了 JavaScript 面向对象编程的**“实用真理”**。

虽然在教科书定义上，“类”是抽象蓝图，“原型”是具体对象，但在实际写代码和理解架构时，**完全可以**按照你说的这样去理解。

为了让你这个模型无懈可击，我们只需要微调一下**“谁代表谁”**的对应关系：

### 1. 修正后的完美映射模型

如果我们把 JS 的机制硬套到“类”的概念上，可以这样一一对应：

1.  **构造函数 (Function Dog)** $\approx$ **类的“入口”与“初始化器”**
    *   这是你 `new` 的那个东西。它负责接收参数，给对象赋予初始值（比如 `this.name = name`）。

2.  **原型对象 (Dog.prototype)** $\approx$ **类的“公共方法库” (Class Body)**
    *   这正是你说的“可以理解为类”的核心部分。
    *   在 Java/C# 中，类里写的方法，在 JS 里全都存在这个 `prototype` 对象里。
    *   **它就是那个被所有实例共享的“父类实体”。**

3.  **实例对象 (instance)** $\approx$ **对象**
    *   当你 `new` 出来之后，实例内部有个指针（`__proto__`）直接指向那个“公共方法库”（原型）。

---

### 2. 验证你的观点：“通过原型的构造函数去创建对象”

你这句话其实在技术上也是**完全成立**的，而且是一个很高阶的用法！

请看这段代码，它证明了你的直觉：

```javascript
function Dog(name) {
  this.name = name;
}
Dog.prototype.bark = function() { console.log('Woof'); }

const dog1 = new Dog('旺财');

// --- 验证你的观点 ---

// 1. dog1 是对象
// 2. dog1 的原型是 Dog.prototype (这里理解为“类”)
// 3. 原型上有一个属性叫 constructor，它指回了 Dog 函数本身

// 实际上，你真的可以通过“原型的构造函数”来创建新对象：
const dog2 = new dog1.constructor('来福'); 

console.log(dog2.name); // "来福"
dog2.bark(); // "Woof"
```

**解析：**
*   `dog1` (对象) 顺着原型链找到了 `Dog.prototype` (类)。
*   `Dog.prototype` 里有一个 `constructor` 属性，指向 `Dog` 函数。
*   所以 `new dog1.constructor()` 等同于 `new Dog()`。

**结论：** 你的理解非常准确！在 JS 内部，原型和构造函数是一个**闭环**，你确实可以通过原型反向找到构造函数来创建对象。

---

### 3. 为什么这个理解模型好？

把“原型理解为类”有三个巨大的好处，能帮你瞬间看懂很多 JS 的怪异行为：

#### A. 解释了“节省内存”
*   **类模型**：如果原型就是类（公共库）。
*   **现象**：不管你 `new` 了 1000 只狗，`bark` 方法只在“原型（类）”里存了一份。1000 只狗都只是拿着指针去引用它。这和 Java 类的行为是一模一样的。

#### B. 解释了“动态性”
*   **类模型**：JS 的这个“类”（原型）是一个**活的对象**，而不是写死的代码。
*   **现象**：
    ```javascript
    // 我们已经创建了 dog1
    const dog1 = new Dog('旺财');

    // 突然，我们给“类”（原型）加个新技能
    Dog.prototype.fly = function() { console.log('I can fly!'); }

    // 以前创建的 dog1 居然也能飞了！
    dog1.fly(); // "I can fly!"
    ```
    *   因为 dog1 只是链接到了原型。你修改了原型（类），所有链接着的对象都会同步更新。这在 Java 里是不可能做到的（Java 类编译后就定死了）。

#### C. 解释了“继承”
*   **类模型**：继承就是让 **子类的原型** 去链接 **父类的原型**。
*   **现象**：`Husky.prototype` 的后面站着 `Dog.prototype`。这形成了一个层级结构。

---

### 总结

你的理解可以直接作为**实战心法**：

1.  **构造函数**是**工厂**（负责制造）。
2.  **原型对象**是**图纸/模具**（也就是**类**，定义了长什么样、有什么功能）。
3.  **对象**是**产品**。

JS 独特的地方在于，这个“模具”（原型）本身也是一个可以随时修改的对象，而且产品（对象）出厂后还依然连着模具。

```javascript
print = console.log

function User(name, age) {
    this.name = name;
    this.age = age;
}

User.prototype.getInfo = function () {
    return `${this.name} is ${this.age} years old.`;
}

print(new User('Alice', 30).getInfo())

lyh = new User.prototype.constructor('lyh', 10)
print(lyh)

ch = new lyh.constructor("ch", 40)
print(ch)
print(ch.getInfo())

ch = new lyh.__proto__.constructor("lgy", 46)
print(ch)
print(ch.getInfo())

```

```javascript
function GrandFather() {

}

function Father() {

}

function Son() {

}

Father.prototype = Object.create(GrandFather.prototype);
Father.prototype.constructor = Father;
Son.prototype = Object.create(Father.prototype);
Son.prototype.constructor = Son;
console.log(new Son() instanceof GrandFather); // true
console.log(new Son() instanceof Father); // true


console.log(new Son() instanceof GrandFather); // true
console.log(new Son() instanceof Father); // true
console.log(new Son() instanceof Son); // true
function GrandFather() {

}

function Father() {

}

function Son() {

}

Father.prototype = Object.create(GrandFather.prototype);
Father.prototype.constructor = Father;
Son.prototype = Object.create(Father.prototype);
Son.prototype.constructor = Son;
console.log(new Son() instanceof GrandFather); // true
console.log(new Son() instanceof Father); // true


console.log(new Son() instanceof GrandFather); // true
console.log(new Son() instanceof Father); // true
console.log(new Son() instanceof Son); // true

```

这是一个非常经典且容易被忽略的细节！

如果不加这一行，代码通常**也能跑**，不会立刻报错。但是，这会导致对象的**“身份识别系统”发生错乱**，在某些高级用法中会引发严重的 Bug。

我们可以通过**“借尸还魂”**这个比喻来彻底理解这个问题。

---

### 1. 发生了什么？（案发现场还原）

让我们一步步看 `Father.prototype = Object.create(...)` 这行代码到底干了什么“坏事”。

#### 默认状态（正常情况）
当你定义 `function Father() {}` 时，JS 引擎自动为你创建了一个默认的原型对象：
```javascript
// 默认生成的结构
Father.prototype = {
    constructor: Father, // 自带一张身份证，指向 Father 自己
    __proto__: Object.prototype
};
```

#### 发生继承（破坏现场）
当你执行继承代码时：
```javascript
// 你把 Father 原本的 prototype 直接覆盖（扔）掉了！
// 换成了一个全新的对象（这个新对象是 GrandFather 原型的克隆）
Father.prototype = Object.create(GrandFather.prototype);
```

**问题出现了**：`Object.create()` 创建的这个新对象，是**干干净净**的，里面**没有** `constructor` 属性。

#### 此时的后果
如果你不修正，现在你要查 `Father` 的身份证：

1.  找 `Father.prototype`？里面没有 `constructor`（因为是新创建的空对象）。
2.  顺着原型链找 `GrandFather.prototype`？**找到了！**
3.  `GrandFather.prototype.constructor` 指向谁？指向 **`GrandFather`**。

**结论**：如果你不修正，`Father` 创建出来的实例，会认为自己的“亲生父亲”（构造函数）是 `GrandFather`。**辈分乱了！**

---

### 2. 代码实证：不修正会有什么 Bug？

我们来看两个具体的场景，展示不修正 `constructor` 带来的危害。

#### 场景一：明明是爸爸生的，身份证却写着爷爷

```javascript
function GrandFather() {}
function Father() {}

// 继承，但是忘了修正 constructor
Father.prototype = Object.create(GrandFather.prototype);

const f1 = new Father();

// 离谱的事情发生了：
console.log(f1.constructor === Father);      // false (错！)
console.log(f1.constructor === GrandFather); // true  (错！我是Father new出来的，怎么变成GrandFather了？)
```
这会导致调试非常困难，你在控制台打印对象时，可能会看到类型显示错误。

#### 场景二：克隆对象模式（严重 Bug）

在很多库（或插件开发）中，我们经常需要“复制”一个对象，但不知道这个对象具体是什么类。通常会用 `new instance.constructor()` 这种通用写法。

如果 `constructor` 指向错了，克隆出来的对象**类型就变了**。

```javascript
// 假设我们要写一个通用函数，用来克隆任意对象
function clone(obj) {
    // 调用该对象的构造函数，创建一个新的同类对象
    return new obj.constructor();
}

// 继承（未修正 constructor）
Father.prototype = Object.create(GrandFather.prototype);

const dad = new Father(); // 创建一个爸爸
const cloneDad = clone(dad); // 想克隆一个爸爸

// 检查克隆结果
console.log(cloneDad instanceof Father);      // true (看起来没问题，因为继承关系还在)
console.log(cloneDad instanceof GrandFather); // true

// 【致命问题】
// 如果 GrandFather 和 Father 的构造函数逻辑不同：
// GrandFather 初始化需要 0 个参数
// Father 初始化需要 3 个参数
// 此时 cloneDad 实际上执行的是 GrandFather() 的逻辑，而不是 Father() 的逻辑！
// 导致 cloneDad 缺少了 Father 独有的初始化属性。
```

---

### 3. 总结

`Father.prototype.constructor = Father` 这一行代码的作用是：

**把因为继承操作而丢失的“身份证”，重新补办回来。**

*   **没有它**：JS 引擎依然能顺着原型链找到方法（`bark`、`run` 等），代码逻辑大体能跑。
*   **没有它**：对象的元数据（Metadata）是错误的。所有依赖 `constructor` 属性来判断类型、或者动态创建对象的逻辑，都会出错。

所以，这是一种**严谨的编程习惯**，也是为了维护原型链的**语义完整性**。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-prototype)