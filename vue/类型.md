<div id="chap-type"></div>

[⬆️ 返回目录](#catalog)


## 类型

这个函数 `function toNumber(v) { return +v }` 的核心实现原理依赖于 JavaScript 中的 **一元加运算符 (`Unary + operator`)**。

虽然代码非常短，但其背后触发了 ECMAScript 规范中定义的复杂类型转换流程。以下是详细的深度解析：

### 1. 核心机制：`ToNumber` 抽象操作

当你在 JavaScript 中在一个变量 `v` 前面加上 `+` 号时（即 `+v`），JS 引擎会执行以下步骤：
1.  **计算表达式 `v` 的值**。
2.  **调用 `ToNumber(v)`**。这是一个 ECMAScript 规范内部定义的抽象操作（Abstract Operation），我们无法直接在代码里调用它，但 `Number(v)` 函数和一元 `+` 运算符都使用这个算法。

### 2. 不同类型的转换规则

根据 `v` 的数据类型，`+v` 的表现如下：

#### A. 基本数据类型 (Primitives)

| 输入类型 (Type) | 输入值 (Example) | 结果 (Result) | 原理解析 |
| :--- | :--- | :--- | :--- |
| **Undefined** | `undefined` | `NaN` | 无法转换为数字。 |
| **Null** | `null` | `0` | **注意**：规范特意定义 null 转换为 0。 |
| **Boolean** | `true` | `1` | |
| | `false` | `0` | |
| **Number** | `123` | `123` | 直接返回，不做改变。 |
| **String** | `"123"` | `123` | 尝试解析字符串。 |
| | `"12.3"` | `12.3` | 支持浮点数。 |
| | `""` (空串) | `0` | **注意**：空字符串或全为空格的字符串会被转换为 0。 |
| | `"abc"` | `NaN` | 如果包含非数字字符（且不符合数字格式），返回 NaN。 |
| | `"0xFF"` | `255` | 支持十六进制格式。 |
| **BigInt** | `10n` | **报错** | 抛出 `TypeError`。JS 禁止混合 BigInt 和 Number 隐式转换以防止精度丢失。 |
| **Symbol** | `Symbol()` | **报错** | 抛出 `TypeError`。 |

#### B. 对象类型 (Objects/Arrays/Functions)

当 `v` 是一个对象时（包括数组、日期等），转换过程要复杂得多，分为两步：

1.  **ToPrimitive (转换为原始值)**：
    JS 首先尝试将对象转换为一个原始值。它会按照以下优先级调用对象内部的方法：
    *   **步骤 1**: 检查对象是否有 `[Symbol.toPrimitive]` 方法。如果有，调用它并传递 hint 为 `"number"`。
    *   **步骤 2**: 如果没有，调用 `valueOf()` 方法。如果返回原始值，则使用该值。
    *   **步骤 3**: 如果 `valueOf` 返回的还是对象，则调用 `toString()` 方法。如果返回原始值，则使用该值。
    *   **步骤 4**: 如果 `toString` 返回的还是对象，抛出 `TypeError`。

2.  **ToNumber (转换为数字)**：
    对第一步得到的原始值，再次应用上面 **A** 部分的规则。

**常见对象转换示例：**

*   **数组 `[]`**:
    1.  `[].valueOf()` 返回数组本身（不是原始值）。
    2.  `[].toString()` 返回 `""` (空字符串)。
    3.  `+""` 变成了 `0`。
    *   **结论**: `toNumber([])` 返回 `0`。

*   **数组 `[10]`**:
    1.  `toString()` 返回 `"10"`。
    2.  `+"10"` 变成了 `10`。

*   **数组 `[1, 2]`**:
    1.  `toString()` 返回 `"1,2"`。
    2.  `+"1,2"` 无法解析为数字，变成 `NaN`。

*   **日期 `new Date()`**:
    *   Date 对象重写了 `[Symbol.toPrimitive]` 或 `valueOf`，直接返回时间戳（毫秒数）。
    *   所以 `+new Date()` 等同于 `Date.now()`。

*   **普通对象 `{}`**:
    1.  `toString()` 返回 `"[object Object]"`。
    2.  转换为数字变成 `NaN`。

### 3. 代码对比与优缺点

你的函数：
```javascript
function toNumber(v) {
    return +v;
}
```

它等价于显式转换：
```javascript
function toNumber(v) {
    return Number(v);
}
```

**区别在于：**
*   **`+v` (一元加)**：
    *   **优点**：代码极其简洁，执行效率通常极高（引擎优化得很好）。
    *   **缺点**：可读性稍差，对新手不直观；BigInt 会报错。
*   **`parseFloat(v)` / `parseInt(v)`**：
    *   **原理不同**：这些是“解析”而非“转换”。例如 `parseInt("10px")` 会得到 `10`，而 `+"10px"` 会得到 `NaN`。
    *   `+v` (你的函数) 更严格，只要字符串包含非法字符（除了首尾空格），它就会认为是 `NaN`。

### 4. 总结

`function toNumber(v) { return +v }` 的实现原理就是利用 JavaScript 引擎内置的 **`ToNumber` 算法**，通过 **一元加运算符** 触发。

它是一种**严格的隐式类型转换**：
1.  对于**空字符串**、**null**、**false**、**[]**，它会变成 `0`。
2.  对于**undefined**、**普通对象**、**非纯数字字符串**，它会变成 `NaN`。
3.  它会触发对象的 `valueOf` -> `toString` 链条。
4.  

这是一个非常敏锐且极具价值的观察！你发现了 JavaScript 中 **`Number()` 函数调用** 与 **一元加运算符 (`+`)** 之间一个极其微妙但在规范层面完全不同的处理逻辑。

虽然我在上一条回答中提到 `+v` 和 `Number(v)` 背后 **通常** 都是基于 `ToNumber`，但在 **BigInt** 这个后来引入的类型上，ECMAScript 规范做了特殊的**分叉处理**。

以下是深度解析：

### 1. 根本原因：规范定义的路径不同

#### 路径 A：一元加运算符 (`+v`)
根据 ECMAScript 规范，一元加运算符（Unary +）的执行步骤非常“死板”：
1.  计算表达式 `v`。
2.  直接调用 **`ToNumber(v)`** 抽象操作。

**关键点来了**：
在 `ToNumber` 的定义中，针对 **BigInt** 类型，规范明确写道：
> **BigInt**: Throw a **TypeError** exception.

这就是为什么 `toNumber(10n)` (即 `+10n`) 会直接报错。JS 引擎认为隐式地将高精度整数转换为可能丢失精度的浮点数是危险的。

#### 路径 B：`Number(v)` 函数调用
当你显式调用全局构造函数 `Number(v)`（作为函数调用，而不是 `new Number`）时，它的逻辑比较“宽容”：

1.  它**不完全**照搬 `ToNumber` 的流程。
2.  它的内部逻辑大致如下（简化版）：
    *   如果 `v` 是 **BigInt** 类型：返回 `v` 的数值（将 BigInt 转换为 IEEE 754 双精度浮点数，可能会丢失精度）。
    *   如果 `v` 是其他类型：才去调用 `ToNumber(v)`。

**结论**：`Number()` 函数被设计为一个“强制类型转换工具”，它允许你显式地进行 BigInt 到 Number 的转换，即便这可能导致精度丢失。

---

### 2. 为什么设计成这样？（为了防止“精度灾难”）

JavaScript 的 `Number` 类型是双精度浮点数，最大安全整数是 `2^53 - 1`。而 `BigInt` 可以无限大。

如果允许 `+BigInt` 这种隐式转换，开发者可能会在无意中写出这种代码：

```javascript
const bigId = 9007199254740993n; // 比 Number 最大安全整数大 1
const result = +bigId; 

// 如果允许隐式转换，result 就会变成 9007199254740992
// 你的 ID 变了！这会导致严重的逻辑 Bug。
```

为了防止这种“静默的错误”，TC39（JS 标准委员会）决定：
1.  **禁止** `+bigInt`（隐式/简写转换），直接抛出 `TypeError` 让你警觉。
2.  **允许** `Number(bigInt)`，因为这代表你**明确知道**自己在做什么，并且愿意承担精度丢失的风险。

### 3. 如何安全地在你的 `toNumber` 函数中修复这个问题？

如果你希望你的 `toNumber` 函数能够兼容 BigInt（并接受精度丢失），你必须显式调用 `Number()` 或者先判断类型：

**方案一：改用 Number()（推荐）**
```javascript
function toNumber(v) {
    return Number(v); // 这样 10n 就能变成 10
}
```

**方案二：如果你坚持用 `+v` 但想兼容 BigInt**
```javascript
function toNumber(v) {
    if (typeof v === 'bigint') {
        return Number(v);
    }
    return +v;
}
```

### 总结

*   **`+v` (ToNumber)**：严格模式。遇到 `BigInt` 认为是不安全操作，**报错**。
*   **`Number(v)`**：工具模式。遇到 `BigInt` 认为是用户的显式意图，**执行转换**（尽管可能丢精度）。

所以，你的观察非常正确：在处理 `BigInt` 时，`+v` 和 `Number(v)` 是不等价的。

这句话涉及到 JavaScript 中内置对象（如 `Number`, `String`, `Boolean`）的双重身份：它们既可以当做**普通函数**用，也可以当做**构造器（Constructor）**用。

简单来说：
*   **`Number(v)`**：是**类型转换**，返回的是一个**数字（原始值 primitive）**。
*   **`new Number(v)`**：是**创建对象**，返回的是一个**对象（Object）**。

下面详细举例说明两者的区别：

### 1. `Number(v)`：作为函数调用（推荐）

这是你通常想要的做法。它仅仅是把输入的值“算”成一个数字，然后扔给你。

```javascript
// 显式调用 Number 函数
let a = Number("123"); 
let b = Number(10n);   // BigInt 转数字

console.log(a);        // 123
console.log(typeof a); // "number"  <-- 注意这里，它是原始类型
console.log(a === 123); // true
```

**特点：**
*   返回的是纯粹的数字（或者 `NaN`）。
*   没有额外的对象包装，性能好，符合逻辑。
*   正如之前的讨论，它包含了处理 BigInt 的特殊逻辑。

---

### 2. `new Number(v)`：作为构造器调用（通常不推荐）

当你使用 `new` 关键字时，JavaScript 引擎会创建一个全新的**对象实例**。这个对象“包裹”着那个数字。

```javascript
// 使用 new 关键字
let o = new Number("123");

console.log(o);        // [Number: 123]  <-- 注意，打印出来是个对象结构
console.log(typeof o); // "object"       <-- 这是一个对象！不是数字！

// 坑点来了：
console.log(o === 123); // false  <-- 对象不等于原始数字（除非用 == 进行隐式转换）
console.log(o + 1);     // 124    <-- 参与运算时，对象会自动拆包取值
```

**特点：**
*   返回的是一个对象（Wrapper Object）。
*   它占用的内存比原始数字大。
*   **极易导致 Bug**（见下文）。

---

### 3. 最可怕的陷阱：布尔值判断

这是区分它们最重要的原因。在 JavaScript 中，**所有的对象都是 `true`**（Truthy），即使它包裹的是数字 `0`。

请看这个经典的 Bug 演示：

```javascript
// 情况 A: 作为函数调用 (正确)
let num1 = Number(0); // 结果是原始值 0
if (num1) {
    console.log("A: 这行不会打印"); // 0 是 false，逻辑正确
}

// 情况 B: 作为构造器调用 (错误)
let num2 = new Number(0); // 结果是一个对象 { 0 }
if (num2) {
    console.log("B: 这行会被打印！！！"); // 对象永远是 true，逻辑崩坏
}
```

### 总结

当你看到文档说“**显式调用全局构造函数 Number(v)（作为函数调用）**”时，它的意思是：

请写：
```javascript
const x = Number(val); // ✅ 对的，我要转类型
```

不要写：
```javascript
const x = new Number(val); // ❌ 错的，我不要创建一个对象
```

在处理 BigInt 转换时，你需要的就是第一种方式（函数调用），因为它只是单纯地把 BigInt 的数学值取出来变成 Number 类型，而不涉及创建对象包裹它的过程。

```javascript
print = console.log
function toNumber(v) {
    return +v
}

// Number = toNumber

v = [1, 2]
print(`${JSON.stringify(v)}, valueOf=${v.valueOf()}`)
print(`${JSON.stringify(v)}, toString=${v.toString()}`)
print(`${JSON.stringify(v)}, Number=${Number(v)}`)
print('---')


v = []
print(`${JSON.stringify(v)}, valueOf=${v.valueOf()}`)
print(`${JSON.stringify(v)}, toString=${v.toString()}`)
print(`${JSON.stringify(v)}, Number=${Number(v)}`)
print('---')


v = {}
print(`${JSON.stringify(v)}, valueOf=${v.valueOf()}`)
print(`${JSON.stringify(v)}, toString=${v.toString()}`)
print(`${JSON.stringify(v)}, Number=${Number(v)}`)
print('---')

v = null
print(`${JSON.stringify(v)}, Number=${Number(v)}`)
print('---')

v = false
print(`${JSON.stringify(v)}, valueOf=${v.valueOf()}`)
print(`${JSON.stringify(v)}, toString=${v.toString()}`)
print(`${JSON.stringify(v)}, Number=${Number(v)}`)
print('---')

v = false
print(`${JSON.stringify(v)}, valueOf=${v.valueOf()}`)
print(`${JSON.stringify(v)}, toString=${v.toString()}`)
print(`${JSON.stringify(v)}, Number=${Number(v)}`)
print('---')

v = true
print(`${JSON.stringify(v)}, valueOf=${v.valueOf()}`)
print(`${JSON.stringify(v)}, toString=${v.toString()}`)
print(`${JSON.stringify(v)}, Number=${Number(v)}`)
print('---')

v = undefined
print(`${JSON.stringify(v)}, Number=${Number(v)}`)
print('---')

v = ""
print(`${JSON.stringify(v)}, valueOf=${v.valueOf()}`)
print(`${JSON.stringify(v)}, toString=${v.toString()}`)
print(`${JSON.stringify(v)}, Number=${Number(v)}`)
print('---')

v = "123"
print(`${JSON.stringify(v)}, valueOf=${v.valueOf()}`)
print(`${JSON.stringify(v)}, toString=${v.toString()}`)
print(`${JSON.stringify(v)}, Number=${Number(v)}`)
print('---')

v = "123abc"
print(`${JSON.stringify(v)}, valueOf=${v.valueOf()}`)
print(`${JSON.stringify(v)}, toString=${v.toString()}`)
print(`${JSON.stringify(v)}, Number=${Number(v)}`)
print('---')

v = "0xFF"
print(`${JSON.stringify(v)}, valueOf=${v.valueOf()}`)
print(`${JSON.stringify(v)}, toString=${v.toString()}`)
print(`${JSON.stringify(v)}, Number=${Number(v)}`)
print('---')

v = 10n
print(`Number=${Number(v)}`)
print('---')

v = new Number(10n)
print(`Number=${Number(v)}`)
print('---')


v = Symbol("sym")
print(`${JSON.stringify(v)}, Number=${Number(v)}`)
print('---')
```

这篇回答将从 ECMAScript (JS) 规范的底层算法角度，深度解析这些运算符的技术原理。

---

### 一、 严格相等 `===` (Strict Equality)
**对应规范算法**：`IsStrictlyEqual(x, y)`

这是 JS 中最高效的比较，因为它**不进行类型转换**。

#### 实现原理步骤：
1.  **检查类型**：如果 `typeof x` 不等于 `typeof y`，直接返回 **`false`**。
2.  **如果类型相同**：
    *   **Undefined / Null**：返回 `true`。
    *   **Number**：
        *   如果任一是 `NaN`，返回 **`false`**（注意：`NaN === NaN` 为假）。
        *   如果一个是 `+0` 另一个是 `-0`，返回 **`true`**。
        *   否则比较数值大小。
    *   **String**：长度相同且每个位置的字符编码（Code Unit）完全一致才返回 `true`。
    *   **Boolean**：同为 true 或同为 false 返回 `true`。
    *   **Symbol**：引用同一个 Symbol 值才返回 `true`。
    *   **Object (含数组、函数)**：**比较内存地址（引用）**。只有当两个变量指向堆内存中的**同一个对象**时，才返回 `true`。

> **`!==` 的原理**：
> 简单地执行 `IsStrictlyEqual(x, y)`，然后对结果取反 (`!`)。

```javascript
print = console.log

let a = null
let b = null
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a === b
if (a === b) {
    print('a === b')
} else {
    print('a !=== b')
}

a = undefined
b = undefined
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 'a === b'
if (a === b) {
    print('a === b')
} else {
    print('a !=== b')
}


a = null
b = undefined
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a === b
if (a === b) {
    print('a === b')
} else {
    print('a !=== b')
}

a = false
b = new Boolean(false)
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a !=== b
if (a === b) {
    print('a === b')
} else {
    print('a !=== b')
}

a = false
b = false
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a !=== b
if (a === b) {
    print('a === b')
} else {
    print('a !=== b')
}

a = "1"
b = "1"
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a !=== b
if (a === b) {
    print('a === b')
} else {
    print('a !=== b')
}

a = +0
b = -0
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a !=== b
if (a === b) {
    print('a === b')
} else {
    print('a !=== b')
}

a = [1]
b = [1]
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a !=== b
if (a === b) {
    print('a === b')
} else {
    print('a !=== b')
}

a = {}
b = {}
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a !=== b
if (a === b) {
    print('a === b')
} else {
    print('a !=== b')
}
```

---

### 二、 宽松相等 `==` (Abstract Equality)
**对应规范算法**：`IsLooselyEqual(x, y)`

这是最复杂的部分，核心机制是**隐式类型转换（Coercion）**。它试图将两边的值拉到同一个维度（通常是数字）再比较。

#### 实现原理步骤（递归逻辑）：
1.  **类型相同**：直接调用 `===` 的逻辑。
2.  **Null 和 Undefined**：
    *   `null == undefined` -> **`true`**。
    *   它们和其他任何值比较都为 `false`。
3.  **Number vs String**：
    *   将 String 转为 Number（`ToNumber()`），然后递归比较。
    *   例如 `1 == "1"` 变成 `1 == 1`。
4.  **Boolean vs 任何值**：
    *   **非常重要**：先将 Boolean 转为 Number！
    *   `true` 变成 `1`，`false` 变成 `0`。
    *   例如 `true == "1"` -> `1 == "1"` -> `1 == 1` -> `true`。
    *   例如 `true == "2"` -> `1 == "2"` -> `1 == 2` -> `false`。
5.  **Object vs 非 Object (String/Number/Symbol/BigInt)**：
    *   将 Object 转为原始值（`ToPrimitive`，通常先调 `valueOf` 后调 `toString`）。
    *   例如 `[10] == 10` -> `"10" == 10` -> `10 == 10`。
6.  **BigInt vs Number**：
    *   比较它们的数学值是否相等。
    *   `10n == 10` -> **`true`**。

> **`!=` 的原理**：
> 执行 `IsLooselyEqual(x, y)`，然后对结果取反。

```javascript
print = console.log

let a = null
let b = null
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a == b
if (a == b) {
    print('a == b')
} else {
    print('a != b')
}

a = undefined
b = undefined
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 'a == b'
if (a == b) {
    print('a == b')
} else {
    print('a != b')
}


a = null
b = undefined
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a == b
if (a == b) {
    print('a == b')
} else {
    print('a != b')
}

a = false
b = new Boolean(false)
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a != b
if (a == b) {
    print('a == b')
} else {
    print('a != b')
}

a = false
b = false
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a != b
if (a == b) {
    print('a == b')
} else {
    print('a != b')
}

a = "1"
b = "1"
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a != b
if (a == b) {
    print('a == b')
} else {
    print('a != b')
}

a = +0
b = -0
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a != b
if (a == b) {
    print('a == b')
} else {
    print('a != b')
}

a = [1]
b = [1]
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a != b
if (a == b) {
    print('a == b')
} else {
    print('a != b')
}

a = {}
b = {}
print(`a=${JSON.stringify(a)} typeof = ${typeof (a)}, b=${JSON.stringify(b)} typeof = ${typeof (b)}`)
// 输出a != b
if (a == b) {
    print('a == b')
} else {
    print('a != b')
}
```

---

### 三、 还有其他类似的运算符吗？

除了 `==` 和 `===`，JavaScript 内部其实还有**另外两种**判断相等的算法，它们暴露在不同的 API 中：

#### 1. `Object.is(x, y)` (SameValue 算法)
这是 JS 中**最严格**的相等判断，主要是修复了 `===` 的两个“历史遗留问题”。

*   **区别 1 (NaN)**：
    *   `NaN === NaN` 结果是 `false`。
    *   `Object.is(NaN, NaN)` 结果是 **`true`**。
*   **区别 2 (0 的符号)**：
    *   `+0 === -0` 结果是 `true`。
    *   `Object.is(+0, -0)` 结果是 **`false`**（在处理底层二进制或图形学时很重要）。

#### 2. `SameValueZero` (内部算法)
这个算法没有直接对应的运算符或函数，但它被用于 **`Set`**、**`Map`** 和数组的 **`includes`** 方法中。

*   **原理**：它像 `Object.is` 一样认为 `NaN` 等于 `NaN`，但像 `===` 一样认为 `+0` 等于 `-0`。
*   **使用场景**：
    ```javascript
    const list = [NaN, 0];
    
    // 使用 === (indexOf 内部)
    list.indexOf(NaN); // -1 (找不到)
    
    // 使用 SameValueZero (includes 内部)
    list.includes(NaN); // true (找到了！)
    ```

---

### 四、 总结对比表

| 比较方式 | 运算符/API | 对 `NaN` vs `NaN` | 对 `+0` vs `-0` | 是否类型转换 | 主要用途 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **严格相等** | `===` | `false` | `true` | **否** | 绝大多数日常逻辑判断 |
| **宽松相等** | `==` | `false` | `true` | **是** | 仅用于 `x == null` (判空) |
| **同值相等** | `Object.is()` | **`true`** | **`false`** | **否** | 需要区分 0 的正负或检测 NaN |
| **零值相等** | `Set`/`Map`/`includes` | **`true`** | `true` | **否** | 集合去重、数组查找 |

### 技术建议
*   **永远优先使用 `===`**。
*   **永远不要使用 `==`**，除非你非常明确地是在写 `if (x == null)`（这行代码同时检查了 `null` 和 `undefined`）。
*   如果你需要判断两个值是否“完全一样”（包括 NaN），使用 `Object.is()`。

这是一个非常好的补充问题。如果不彻底理解 `!=` 和 `!==`，在代码逻辑判断中非常容易埋下 Bug。

**核心结论先行**：
这两个运算符本质上就是 **`==`** 和 **`===`** 的**逻辑取反（NOT）**。
*   `x !== y` 等价于 `!(x === y)`
*   `x != y` 等价于 `!(x == y)`

下面是全面的技术原理解析：

---

### 一、 `!==` (Strict Inequality, 严格不相等)

这是 JavaScript 中**最推荐**使用的不相等运算符。它的逻辑非常清晰，**不涉及隐式类型转换**。

#### 1. 技术原理（算法流程）
JS 引擎执行 `x !== y` 时，实际上是先执行 `IsStrictlyEqual(x, y)`（也就是 `===` 的逻辑），然后把结果**反转**。

**判断步骤（口语化版）：**
1.  **先看类型**：如果 `x` 和 `y` 的类型**不一样**，直接返回 **`true`**（不相等）。
    *   *例子*：`1 !== '1'` -> 类型不同 -> **`true`**。
2.  **若类型一样，再看值**：
    *   如果值不同，返回 **`true`**。
    *   如果值相同，返回 **`false`**。
3.  **特殊对象引用**：
    *   如果是两个对象（包括数组），只有当它们指向内存中**不同的地址**时，才返回 **`true`**。

#### 2. 典型案例
```javascript
1 !== 1        // false (类型相同，值相同)
1 !== "1"      // true  (类型不同，直接不相等)
1 !== true     // true  (类型不同)
null !== undefined // true (类型不同)

const obj = {};
obj !== {}     // true  (虽然长得一样，但内存地址不同)
obj !== obj    // false (同一个引用)
```

---

### 二、 `!=` (Loose Inequality, 宽松/抽象不相等)

这是 JavaScript 中**历史包袱最重、最容易出错**的运算符。它的核心是**先转换，再比较**。

#### 1. 技术原理（算法流程）
JS 引擎执行 `x != y` 时，实际上是先执行 `IsLooselyEqual(x, y)`（也就是 `==` 的逻辑），然后把结果**反转**。

**判断步骤（口语化版）：**
1.  **尝试类型转换**：如果类型不同，JS 引擎会拼命把两边转换成同一种类型（通常转为数字，或者把对象转为原始值）。
2.  **比较转换后的值**：
    *   如果转换后相等（即 `==` 为 true），则 `!=` 返回 **`false`**。
    *   如果转换后不相等，则 `!=` 返回 **`true`**。

#### 2. “恐怖”的转换案例
理解 `!=` 的关键在于：**它会把看似不相等的东西变成相等的，导致 `!=` 返回 false。**

| 表达式 | 结果 | 转换/原理分析 |
| :--- | :--- | :--- |
| `"1" != 1` | **`false`** | `"1"` 转成数字 `1`，`1 == 1` 为真，取反为假。 |
| `true != 1` | **`false`** | `true` 转成数字 `1`，相等。 |
| `[0] != 0` | **`false`** | 数组 `[0]` 变成字符串 `"0"` 再变成数字 `0`，相等。 |
| `[] != 0` | **`false`** | 空数组 `[]` 变成 `""` 再变成 `0`，相等。 |
| `null != undefined` | **`false`** | **最特殊**：规范定义它俩互等。 |
| `false != "0"` | **`false`** | `false`->`0`, `"0"`->`0`。相等。 |
| `"\n \t" != 0` | **`false`** | 空白字符串会转成 `0`。 |

---

### 三、 全面对比总结表

为了方便记忆，我们从**“它们什么时候返回 True（认为不相等）”**的角度来对比：

| 场景 | `!==` (严格) | `!=` (宽松) | 解释 |
| :--- | :--- | :--- | :--- |
| **类型不同** (如 `1` vs `'1'`) | **`true`** | `false` | `!=` 会转换类型后发现它们其实“相等”。 |
| **Null vs Undefined** | **`true`** | `false` | `!==` 认为类型不同；`!=` 认为它俩是一伙的。 |
| **Object vs Primitive** (如 `[1]` vs `1`) | **`true`** | `false` | `!=` 会拆箱对象。 |
| **BigInt vs Number** (如 `10n` vs `10`) | **`true`** | `false` | `!=` 会比较数学值。 |
| **不同对象** (如 `{}` vs `{}`) | `true` | `true` | 无论哪种方式，引用地址不同就是不相等。 |
| **NaN vs NaN** | `true` | `true` | 无论哪种方式，NaN 永远不等于 NaN。 |

### 四、 唯一的例外：什么时候可以用 `!=` ？

在现代 JavaScript 开发标准（如 ESLint 规则）中，**99% 的情况都要求使用 `!==`**。

只有**一种情况**，也就是所谓的 **"Null Check"** 模式，被部分开发者接受使用 `!=`：

```javascript
// 你的意图：想判断 value 既不是 null 也不是 undefined

// 写法 A (使用 strict inequality):
if (value !== null && value !== undefined) { 
    // ...
}

// 写法 B (使用 loose inequality，利用了 null == undefined 的特性):
if (value != null) {
    // ...
}
```

*   **原理**：因为 `null == undefined` 是 `true`，所以 `null != undefined` 是 `false`。
*   `value != null` 这行代码能同时拦截住 `null` 和 `undefined`，代码更短。
*   **注意**：除了这个特定场景，**严禁使用 `!=`**。

### 五、 总结图谱

如果要用一句话概括它们的区别：

*   **`!==`** 问的是：**“这两个东西的内存、类型或值，有任何一样不一样吗？”** (No conversion)
*   **`!=`** 问的是：**“如果我努力把它们转化成同类，它们最后还不相等吗？”** (Coercion involved)

**最佳实践**：为了代码的可维护性和避免奇怪的 Bug（比如 `[] != 0` 竟然是 false），请**永远默认使用 `!==`**。

```javascript
'use strict'; // 开启严格模式，避免隐式全局变量

const result = {};
const obj = { name: '' }; // 示例 obj

if (obj && 'name' in obj) {
    result.name = obj.name;
}

if (obj && Object.hasOwnProperty.call(obj, 'name')) {
    result.name = obj.name;
}


console.log(result); // { name: '' }（符合预期）
```

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-)