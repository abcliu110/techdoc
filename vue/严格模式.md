<div id="chap-strict"></div>

[⬆️ 返回目录](#catalog)


## 严格模式


在严格模式下，要让这个函数正常工作，你必须通过 **`new` 关键字** 来调用它。

这涉及到了 `this` 绑定的第四种规则：**new 绑定 (Constructor Call)**。

### 1. 正确的写法

```javascript
'use strict';

function User(name) {
    // 当使用 new 调用时，这里的 this 指向一个新创建的对象
    this.name = name; 
}

// ✅ 正确：使用 new 关键字
const u = new User("张三"); 

console.log(u.name); // 输出 "张三"
```

### 2. 为什么加了 `new` 就不报错了？

当你使用 `new User("张三")` 调用时，JavaScript 引擎会在内部做以下 4 步操作（俗称“构造函数四步曲”）：

1.  **创建对象**：在内存中创建一个全新的空对象（例如 `{}`）。
2.  **原型链接**：把这个新对象的原型链（`[[Prototype]]`）指向 `User.prototype`。
3.  **绑定 `this`**：**最关键的一步**。引擎把函数体内的 `this` **强制绑定**到刚才创建的那个新对象上。（此时 `this` 不再是 `undefined`，而是一个鲜活的对象）。
4.  **返回对象**：如果函数没有手动返回其他对象，引擎会自动返回这个新对象。

**对比一下：**

*   **`User("张三")` (裸奔调用)**：
    *   规则：默认绑定。
    *   严格模式下：`this` 是 `undefined`。
    *   结果：**报错**（无法给 undefined 设置属性）。

*   **`new User("张三")` (构造调用)**：
    *   规则：new 绑定。
    *   严格模式下：`this` 是 **新对象**。
    *   结果：**成功**（新对象有了 name 属性）。

---

### 3. 进阶：现代写法 (ES6 Class)

为了防止你经常忘记写 `new`，ES6 引入了 `class` 语法。这是现在更推荐的写法。如果你试图不加 `new` 直接调用 `class`，JavaScript 会直接抛出更清晰的错误，而不是等到运行内部逻辑时才报 `this` 错误。

```javascript
'use strict';

class User {
    constructor(name) {
        this.name = name;
    }
}

// ✅ 正确
const u = new User("张三");

// ❌ 错误：不加 new 调用
const u2 = User("李四"); 
// 报错：Class constructor User cannot be invoked without 'new'
// (类构造函数 User 不能在没有 new 的情况下被调用)
```

### 总结
严格模式报错是因为它发现你在试图**把普通函数当构造函数用，却忘了加 `new`**。
*   解决方法：加上 **`new`**。
*   最佳实践：使用 **`class`** 语法，它能从语法层面强制你使用 `new`。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-strict)