<div id="chap-convert"></div>

[⬆️ 返回目录](#catalog)


## 类型转换

### 为什么 `money * 2` 会触发 `hint: 'number'`？
`money * 2` 中 `*` 运算符强制触发 `hint: 'number'`，核心原因是 **JS 乘法运算符的语法规则要求操作数必须是原始数值类型**，引擎会主动向对象索要「数字类型的原始值」，具体拆解如下：

#### 一、乘法运算符（`*`）的底层规则
JS 规范中，`*` 属于「算术运算符」，其执行逻辑是：
1. 对左右两个操作数依次执行「ToNumber 抽象操作」（强制转为数字）；
2. 若操作数是对象，ToNumber 会优先调用对象的 `[Symbol.toPrimitive](hint: 'number')` 方法获取数字原始值；
3. 若未定义 `Symbol.toPrimitive`，则按 `valueOf()` → `toString()` 顺序尝试转换，最终转数字。

简单说：`*` 运算的核心是“做数值计算”，引擎明确知道需要「数字」，因此会精准传入 `hint: 'number'`，要求对象返回数字类型的原始值。

#### 二、对比不同运算符的触发逻辑（为什么 `+` 是 default，`*` 是 number）
| 运算符 | 类型       | 引擎诉求                          | 传入 hint  | 核心原因                     |
|--------|------------|-----------------------------------|------------|------------------------------|
| `*`    | 算术运算符 | 必须是数字，否则无法计算          | `number`   | 乘法是纯数值运算，无歧义     |
| `/`/`-`| 算术运算符 | 同 `*`，依赖数值计算              | `number`   | 减法/除法也只能对数字生效    |
| `+`    | 混合运算符 | 可加法（数字）/可拼接（字符串）| `default`  | 引擎无法确定你要哪种类型     |
| `String()` | 显式转换 | 明确要求字符串形式                | `string`   | 显式指定转换目标为字符串     |

#### 三、代码验证：去掉 `Symbol.toPrimitive` 看默认行为
如果注释掉 `[Symbol.toPrimitive]` 方法，引擎会走默认的 `valueOf()`/`toString()` 逻辑，更能体现 `*` 对数字的强制要求：
```javascript
const money = { value: 100 };

// 无 Symbol.toPrimitive 时，* 运算触发 ToNumber：
// 1. 调用 money.valueOf() → 返回对象本身（非原始值）；
// 2. 继续调用 money.toString() → 返回 "[object Object]"；
// 3. 将 "[object Object]" 转数字 → NaN；
console.log(money * 2); // NaN

// 手动定义 valueOf 后：
money.valueOf = () => this.value;
console.log(money * 2); // 200（valueOf 返回数字，满足 * 运算的数值要求）
```

JavaScript 的隐式类型转换（Implicit Coercion）是前端面试和深层理解 JS 的核心难点。它的本质遵循 ECMAScript 规范中的一套严格算法。

隐式转换主要分为三大类：**转布尔值**、**转数字**、**转字符串**。其中最复杂的是**对象转原始值（Object to Primitive）**的过程。

以下是底层的原理细节：

---

### 一、 核心机制：`ToPrimitive` 算法

当对象（如 `{}`、`[]`、`Date`）参与原始值运算（如 `+`, `==`, `*`）时，引擎内部会调用一个叫 `ToPrimitive(input, PreferredType)` 的抽象操作。

这个操作的目标是将对象“拆箱”为原始值。它有三个关键步骤，**优先级从高到低**：

1.  **`Symbol.toPrimitive` 方法**
    *   如果对象存在 `[Symbol.toPrimitive](hint)` 方法，直接调用它。
    *   `hint` 参数的值会是 `'number'`、`'string'` 或 `'default'`。

2.  **`valueOf()` 和 `toString()`**
    *   如果没有定义 `Symbol.toPrimitive`，则根据 **PreferredType（期望类型）** 决定调用顺序。

    *   **如果是期望 Number（数值上下文）：**
        1.  调用 `valueOf()`。如果返回原始值，结束。
        2.  否则，调用 `toString()`。如果返回原始值，结束。
        3.  如果两个都返回对象，报错 `TypeError`。

    *   **如果是期望 String（字符串上下文）：**
        1.  调用 `toString()`。如果返回原始值，结束。
        2.  否则，调用 `valueOf()`。如果返回原始值，结束。
        3.  如果两个都返回对象，报错 `TypeError`。

    *   **如果是期望 Default（无偏好）：**
        *   大多数对象（普通对象、数组）默认按 **Number** 逻辑处理（先 `valueOf` 后 `toString`）。
        *   **例外**：`Date` 对象默认按 **String** 逻辑处理。

---

### 二、 三大转换场景详解

#### 1. 转换为 Boolean (ToBoolean)
这是最简单的。只有以下 **7 种** 值会转为 `false`（Falsy 值），其他所有值（包括所有对象、数组）都会转为 `true`。

*   `false`
*   `0`, `-0`
*   `NaN`
*   `""` (空字符串)
*   `null`
*   `undefined`
*   `0n` (BigInt)

**触发场景：** `if (obj)`, `obj ? a : b`, `!!obj`, `&&`, `||`。

---

#### 2. 转换为 String (ToString)
**触发场景：**
*   字符串连接：`"hello " + 123`
*   对象作为属性键：`obj[key] = 1` (key 会被转字符串)
*   `String(obj)`

**转换规则：**
*   **原始值**：直接转字符（`null` -> `"null"`, `undefined` -> `"undefined"`, `true` -> `"true"`）。
*   **对象**：调用 `ToPrimitive(obj, 'string')`。
    *   通常优先调用 `toString()`。
    *   普通对象 `{}` 的 `toString` 返回 `"[object Object]"`。
    *   数组 `[1, 2]` 的 `toString` 相当于 `join(',')`，返回 `"1,2"`。

---

#### 3. 转换为 Number (ToNumber)
**触发场景：**
*   数学运算：`*`, `/`, `-`, `%`
*   一元加号：`+money`
*   比较大小：`>`, `<`
*   **宽松相等**：`==` (部分情况)

**转换规则：**
*   `undefined` -> `NaN` (**注意**：不是 0)
*   `null` -> `0`
*   `true` -> `1`, `false` -> `0`
*   `String` -> 解析为数字，失败则 `NaN`（空字符串 `""` -> `0`）。
*   **对象**：调用 `ToPrimitive(obj, 'number')`。
    *   优先 `valueOf()`，如果没拿到原始值，再 `toString()`。

---

### 三、 两个特殊运算符的陷阱

#### 1. 加号运算符 (`+`) 的双重人格
`+` 既可以是**数字相加**，也可以是**字符串拼接**。

**规范流程：**
1.  如果两边有对象，先两边都调用 `ToPrimitive(val, 'default')` 转为原始值。
2.  **判断**：如果转换后的原始值中**只要有一个是字符串**，则进行**字符串拼接**。
3.  否则，进行**数字相加**。

**案例分析：**
```javascript
const money = { value: 100 };
// 默认对象没有 toString/valueOf 重写

console.log(money + 1); // "[object Object]1"
```
*   **过程**：
    1. `money` 转原始值（Default 提示 -> Number 逻辑）。
    2. `money.valueOf()` 返回对象本身 -> 失败。
    3. `money.toString()` 返回 string `"[object Object]"` -> 成功。
    4. 此时表达式变成 `"[object Object]" + 1`。
    5. 发现有一方是字符串，执行拼接。

#### 2. 宽松相等 (`==`)
规则极其复杂，核心是**“如果不匹配，就往数字转”**。

1.  `null == undefined` -> **true** (这是铁律，它俩和其他谁都不等)。
2.  如果一个是 String，一个是 Number -> 把 String 转 Number 再比。
3.  如果一个是 Boolean -> 把 Boolean 转 Number 再比。
4.  如果一个是 Object，一个是原始值 -> 把 Object 转原始值 (`ToPrimitive`) 再比。

**经典面试题解析：**
```javascript
[] == ![] // true
```
**解析步骤：**
1.  右边 `![]`：`[]` 是对象（Truthy），取反变成 `false`。
    *   表达式变成：`[] == false`
2.  遇到 Boolean，转数字：`false` -> `0`。
    *   表达式变成：`[] == 0`
3.  遇到 Object vs Number，对象转原始值：
    *   `[].valueOf()` -> `[]` (不是原始值)
    *   `[].toString()` -> `""` (空字符串)
    *   表达式变成：`"" == 0`
4.  遇到 String vs Number，字符串转数字：
    *   `Number("")` -> `0`
5.  最终：`0 == 0` -> **true**

---

### 四、 总结流程图（对象参与运算时）

当看到 `obj * 2` 或 `obj + "a"` 时，按此顺序思考：

1.  **有没有 `Symbol.toPrimitive`？**
    *   有 -> 用它返回的值。
2.  **上下文想要什么？**
    *   想要字符串（如 `alert(obj)`, `${obj}`） -> 优先 `toString`，后 `valueOf`。
    *   想要数字（如 `*`, `-`, `+u`） -> 优先 `valueOf`，后 `toString`。
    *   不确定（如 `+`, `==`） -> 默认当做数字处理（优先 `valueOf`），**除非是 Date 对象**。
3.  **拿到的结果能不能转成目标类型？**
    *   比如 `toString` 拿到了 `"[object Object]"`，如果是在 `*` 运算中，这个字符串会被强制 `Number()` 变成 `NaN`。

这就是为什么你最开始的代码中，`money * 2` 会是 `NaN`：
`valueOf` (本身) -> `toString` ("[object Object]") -> `Number` (NaN) -> `NaN * 2` -> `NaN`。


**不是，不止 `number` 和 `string` 这两种。**

这里的“原始值”（Primitive Value）指的是 JavaScript 语言规范中定义的 **7 种** 基础数据类型中的任意一种。

只要 `valueOf()` 或 `toString()` 返回的是以下列表中的**任何一个**，流程就会“结束”（即成功拿到了原始值），然后再进行后续的类型转换。

### JavaScript 的 7 种原始值：
1.  **Number** (数字)
2.  **String** (字符串)
3.  **Boolean** (布尔值) —— *这也是很常见的返回值*
4.  **Null** (空)
5.  **Undefined** (未定义)
6.  **BigInt** (大整数)
7.  **Symbol** (符号)

---

### 举例说明

`valueOf` 可以返回 `null` 或 `boolean`，JS 引擎会先接受这个“原始值”，然后根据上下文把它转成数字或字符串。

#### 例子 1：valueOf 返回 Boolean
```javascript
const user = {
  money: 100,
  valueOf() {
    return true; // 【注意】这里返回的是 Boolean，它是原始值，所以查找结束
  }
};

// 过程解析：
// 1. user * 2 需要转数字
// 2. 调用 user.valueOf() 得到 true (原始值) -> 停止查找
// 3. 将 true 转为数字 1
// 4. 计算 1 * 2
console.log(user * 2); // 2
```

#### 例子 2：valueOf 返回 Null
```javascript
const emptyObj = {
  valueOf() {
    return null; // Null 也是原始值，查找结束
  }
};

// 过程解析：
// 1. emptyObj + 5
// 2. valueOf() 返回 null
// 3. null 转数字是 0
// 4. 计算 0 + 5
console.log(emptyObj + 5); // 5
```

#### 例子 3：valueOf 返回 Object (继续查找) vs 报错
```javascript
const badObj = {
  valueOf() {
    return {}; // 返回的是对象，不是原始值 -> 引擎忽略它，继续去找 toString
  },
  toString() {
    return {}; // toString 也返回对象 -> 都没有原始值
  }
};

// 报错：TypeError: Cannot convert object to primitive value
console.log(badObj * 2); 
```

### 总结
规则中的“返回原始值”，意思是：**只要返回的不是对象（Object）就行**。

*   如果你返回 `true`，引擎收到后会把它进一步转为数字 `1` 去计算。
*   如果你返回 `null`，引擎收到后会把它进一步转为数字 `0` 去计算。
*   当然，如果你直接返回 `100` (Number) 或 `"100"` (String)，那是最高效的。

**你说得非常对！** 这正是很多开发者容易混淆的地方。

对象参与运算，实际上是分**两步走**的：

1.  **第一步（拆箱）：** 对象 -> **任意原始值**
    *   通过 `Symbol.toPrimitive` / `valueOf` / `toString` 变成 7 种原始值之一（Number, String, Boolean, Null, Undefined, Symbol, BigInt）。
    *   *目的：脱离“对象”这个外壳。*

2.  **第二步（类型适配）：** 任意原始值 -> **运算符需要的类型**
    *   根据具体的运算符（`*`, `+`, `==`, `&&`），将上一步得到的原始值强制转换为最终所需的类型（通常是 Number 或 String）。
    *   *目的：让数据能进行数学计算或字符串拼接。*

---

### 举个极端的例子帮你彻底打通

假设我们有一个“怪异”的对象，它的 `valueOf` 返回 `null`。

```javascript
const weirdObj = {
  valueOf() {
    console.log("1. 第一步：拆箱变成原始值 null");
    return null; // 返回原始值 null，拆箱成功
  }
};

// 场景 A：乘法运算
console.log(weirdObj * 10); 
```

#### 详细执行流程：

**第一步：拆箱 (ToPrimitive)**
*   引擎发现 `weirdObj` 是对象，调用 `valueOf`。
*   得到结果 `null`。
*   因为 `null` 是原始值，第一步结束。

**第二步：类型适配 (ToNumber)**
*   乘法 `*` 运算符强制要求两边都是 **Number**。
*   引擎必须把 `null` 转换为数字。
*   查表：`Number(null)` 的结果是 `0`。
*   最终计算：`0 * 10`。

**结果：** `0`

---

### 再看一个例子：返回字符串，但参与乘法

```javascript
const stringObj = {
  valueOf() {
    return "5"; // 第一步：返回原始值字符串 "5"
  }
};

console.log(stringObj * 2);
```

#### 详细执行流程：

1.  **拆箱**：调用 `valueOf` 得到原始值 `"5"` (String)。
2.  **适配**：乘法 `*` 需要 Number。引擎自动调用 `Number("5")`，得到数字 `5`。
3.  **计算**：`5 * 2 = 10`。

**结果：** `10`

---

### 如果第二步转换失败怎么办？

如果第一步拿到的原始值，无法在第二步转换为合法的数字（且上下文需要数字），就会得到 `NaN`。

```javascript
const badObj = {
  valueOf() {
    return "hello"; // 第一步：得到原始值 "hello"
  }
};

console.log(badObj * 2);
```

1.  **拆箱**：得到 `"hello"`。
2.  **适配**：`*` 需要 Number。调用 `Number("hello")`。
    *   字符串转数字失败，结果是 `NaN`。
3.  **计算**：`NaN * 2`。

**结果：** `NaN`

---

### 总结对照表

为了让你看清**第二步**发生了什么，这里有一张常见的**中间原始值**到**最终运算类型**的映射表：

| 第一步得到的原始值 | 若运算需要 Number (如 `*`, `-`) | 若运算需要 String (如 `alert`, 模板字符串) |
| :--- | :--- | :--- |
| **Boolean: `true`** | 转换为 `1` | 转换为 `"true"` |
| **Boolean: `false`** | 转换为 `0` | 转换为 `"false"` |
| **Null** | 转换为 `0` | 转换为 `"null"` |
| **Undefined** | 转换为 `NaN` | 转换为 `"undefined"` |
| **String: `"10"`** | 转换为 `10` | (保持原样) |
| **String: `"abc"`** | 转换为 `NaN` | (保持原样) |

所以你的理解非常准确：**valueOf/toString 只是为了把对象“杀掉”变成原始值，至于这个原始值最后能不能用，还要看它能不能通过“类型适配”这一关。**

在 JavaScript 中，`null` 和 `undefined` 都代表“没有值”或“空”，但它们在**语义**、**类型**和**使用场景**上有明显的区别。

以下是详细的对比总结：

### 1. 核心语义区别 (Semantics)

*   **`undefined` (未定义/未赋值)**
    *   代表**“缺少值”**。
    *   表示变量已经被声明了，但是**还没有被赋值**。
    *   这是 JavaScript 引擎的默认行为（被动产生）。
*   **`null` (空值)**
    *   代表**“空对象指针”**或**“特意设置为空”**。
    *   表示变量已经赋值了，其值就是“空”。
    *   这通常是开发者**显式**赋值的，用来表示“这里应该有一个对象，但现在还没有”或“重置该变量”（主动产生）。

---

### 2. 数据类型检查 (`typeof`)

这是面试中常见的一个考点：

```javascript
typeof undefined // "undefined"
typeof null      // "object"
```

*   **注意**：`typeof null` 返回 `"object"` 是 JavaScript 早期的一个**设计错误**（历史遗留 Bug），但为了兼容旧代码，这个错误一直保留至今。从逻辑上讲，它应该是 `null` 类型。

---

### 3. 相等性比较

*   **宽松相等 (`==`)**：
    两者在逻辑上都代表“空”，所以相等。
    ```javascript
    null == undefined // true
    ```

*   **严格相等 (`===`)**：
    由于数据类型不同，所以不相等。
    ```javascript
    null === undefined // false
    ```

---

### 4. 数值转换 (Number Conversion)

当它们被转换为数字时（例如在数学运算中），表现完全不同：

*   **`null`** 转为 **`0`**。
*   **`undefined`** 转为 **`NaN`** (Not a Number)。

```javascript
Number(null);      // 0
5 + null;          // 5

Number(undefined); // NaN
5 + undefined;     // NaN
```

---

### 5. 常见出现场景

#### 什么时候会出现 `undefined`？
通常由 JS 引擎自动产生：
1.  声明了变量但未赋值：`let a; console.log(a); // undefined`
2.  访问对象不存在的属性：`let obj = {}; console.log(obj.b); // undefined`
3.  函数定义了形参但调用时没传实参：`function fn(x){console.log(x)}; fn(); // undefined`
4.  函数没有显式返回值（或 `return;`）：`let res = fn(); // res is undefined`

#### 什么时候会出现 `null`？
通常由开发者手动赋值，或某些特定 API 返回：
1.  初始化一个变量，打算稍后赋值为对象：`let user = null;`
2.  函数试图获取一个不存在的对象（DOM 操作常见）：
    `document.getElementById('not-exist-id'); // null`
3.  原型链的顶端：`Object.prototype.__proto__; // null`
4.  释放对象引用（垃圾回收）：`user = null;`

---

### 6. JSON 序列化中的区别

在使用 `JSON.stringify` 时，两者的处理方式不同：

*   **`undefined`**：会被忽略（作为对象属性时）或转为 `null`（作为数组元素时）。
*   **`null`**：保留为 `null`。

```javascript
const obj = {
  name: 'Test',
  prop1: undefined, // 会被丢弃
  prop2: null       // 会被保留
};

JSON.stringify(obj);
// 输出: '{"name":"Test","prop2":null}'
```

---

### 总结对照表

| 特性 | `undefined` | `null` |
| :--- | :--- | :--- |
| **含义** | 变量已声明但未赋值 (被动) | 意为空值，通常指代对象 (主动) |
| **Typeof** | `"undefined"` | `"object"` (历史Bug) |
| **转数字** | `NaN` | `0` |
| **JSON处理** | 通常被忽略 | 保留为 `null` |
| **推荐用法** | 永远不要手动赋值 `undefined` | 用来初始化或清空变量 |

**一句话总结：**
**`undefined` 是代表“还没想好给什么值”，而 `null` 是代表“我特意让它是空的”。**

```javascript
console.log([].toString())
//""
console.log("------------")
console.log([].valueOf())
//(0) []
console.log("------------")
console.log({}.toString())
// [object Object]
console.log("------------")
console.log({}.valueOf())
//{}
console.log("------------")

console.log(Boolean([]))  
// true
console.log(Boolean({}))
// true
console.log(Boolean(Date()))
// true

```


<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-convert)