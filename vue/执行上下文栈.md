<div id="chap-execution-context-stack"></div>

[⬆️ 返回目录](#catalog)


## 执行上下文栈

这是一个非常棒的要求。为了彻底讲清楚这四个概念的交互，我们将采用 **“代码 + 内存快照 + 动画分解”** 的方式。

首先，我们要纠正一个术语：JS 引擎中存储变量的地方叫 **Environment Record (环境记录)**，而不是“环境变量”（后者通常指操作系统层面的 PATH 等）。

我们将通过一段包含 **全局、函数、块级作用域、var/let 混合** 的代码，像放电影一样，一帧一帧地看 JS 引擎内部发生了什么。

---

### 0. 核心角色介绍 (剧本设定)

1.  **ECS (执行上下文栈)**：一个容器，用来管理代码运行的层级（谁调用了谁）。
2.  **EC (执行上下文)**：栈里的每一个单位（帧）。它包含两个核心指针：
    *   **LE (LexicalEnvironment)**：**“当前视野”指针**。代码执行到哪，它就指向哪里的环境记录。用于**查找变量**。
    *   **VE (VariableEnvironment)**：**“根据地”指针**。无论代码钻到哪个块里，它始终指向当前函数的顶层环境记录。用于**存放 var 声明**。
3.  **ER (Environment Record)**：**真实的存储仓库**（堆内存中的对象）。它是 LE 和 VE 指向的目标。

---

### 1. 示例代码

请盯着这段代码，我们将分析它从出生到结束的全过程。

```javascript
// 全局代码
var globalVar = "G";

function foo() {
    var funcVar = "F1";
    let funcLet = "F2";

    // 块级作用域 Start
    {
        let blockLet = "B1";
        var blockVar = "B2"; // 注意：var 写在块里！
        console.log(blockLet, funcVar);
    }
    // 块级作用域 End
    
    console.log(funcLet);
}

foo();
```

---

### 2. 全流程深度解析

#### 🎬 第一幕：全局初始化 (Global Creation)
浏览器加载脚本，代码还没执行。

1.  **创建堆内存 (ER)**：
    *   创建 **[Global-ER]**。
    *   扫描 `var globalVar` -> 存入，值为 `undefined` (提升)。
    *   扫描 `function foo` -> 存入，值为函数对象 (提升)。
2.  **创建栈帧 (EC)**：
    *   创建 **Global-EC** 并压入 ECS 栈底。
3.  **连接指针**：
    *   `Global-EC.LE` -> 指向 **[Global-ER]**。
    *   `Global-EC.VE` -> 指向 **[Global-ER]**。

**此时状态：** `LE === VE`。

---

#### 🎬 第二幕：foo 函数被调用，准备执行 (Foo Creation)
执行完全局赋值后，调用 `foo()`。引擎为 `foo` 做准备（预编译阶段）。

1.  **创建堆内存 (ER)**：
    *   创建 **[Foo-ER]** (函数环境记录)。
    *   **VAR 扫描** (关键)：
        *   扫描 `var funcVar` -> 存入，值为 `undefined`。
        *   扫描 `var blockVar` (虽然它在 `{}` 块里)：**因为它由于是 var，被强行提到了 [Foo-ER] 中！** 值为 `undefined`。
    *   **LET 扫描**：
        *   扫描 `let funcLet` -> 存入，标记为 `<uninitialized>` (TDZ)。
        *   `let blockLet`？**不扫描**，因为它是块级变量，不属于函数顶层。
    *   **设置父级**：`[Foo-ER].Outer = [Global-ER]`。

2.  **创建栈帧 (EC)**：
    *   创建 **Foo-EC** 并压入 ECS 栈顶。

3.  **连接指针**：
    *   `Foo-EC.LE` -> 指向 **[Foo-ER]**。
    *   `Foo-EC.VE` -> 指向 **[Foo-ER]**。

**此时状态：** `LE === VE`。

**内存快照：**
```javascript
FooEC = {
  LE: -> [Foo-ER],
  VE: -> [Foo-ER] // var blockVar 就在这里面
}
```

---

#### 🎬 第三幕：进入块级作用域 (Block Entry) —— **分裂时刻**
函数内部代码执行，`funcVar` 和 `funcLet` 赋值完成。此时代码执行到了 `{`。

1.  **创建堆内存 (ER)**：
    *   创建 **[Block-ER]** (声明式环境记录)。
    *   **LET 扫描**：扫描 `let blockLet` -> 存入 **[Block-ER]**。
    *   **VAR 扫描**：**忽略！** (因为 var 属于 VE 管，已经在第二幕处理过了)。
    *   **设置父级**：`[Block-ER].Outer = [Foo-ER]`。

2.  **调整 EC 指针 (最重要的一步)**：
    *   **LE (当前视野)**：断开与 [Foo-ER] 的连接，**改为指向 [Block-ER]**。
    *   **VE (根据地)**：**不动！** 依然死死指向 **[Foo-ER]**。

**为什么 VE 不动？**
因为如果在块里遇到了 `var` 赋值，或者 `eval("var x = 1")`，引擎必须知道把这些 var 扔到哪里去（必须扔到函数级作用域）。VE 就是那个锚点。

**此时状态：** `LE !== VE`。

**内存快照：**
```javascript
FooEC = {
  LE: -> [Block-ER], // 此时查找变量从这里开始
  VE: -> [Foo-ER]    // var 依然挂在这里
}

// 链条关系：
// [Block-ER] -> (Outer) -> [Foo-ER] -> (Outer) -> [Global-ER]
```

---

#### 🎬 第四幕：块内执行 (Execution inside Block)
代码：`console.log(blockLet, funcVar)`

**查找过程（只看 LE）：**

1.  **找 `blockLet`**：
    *   看 `FooEC.LE` (即 [Block-ER]) -> 找到了！
2.  **找 `funcVar`**：
    *   看 `FooEC.LE` (即 [Block-ER]) -> 没找到。
    *   顺着 `Outer` 找 -> 进入 [Foo-ER] -> 找到了！

**赋值 `var blockVar = "B2"`**：
虽然代码写在块里，但赋值操作是查找变量名。
*   LE 找 `blockVar` -> [Block-ER] 没有。
*   Outer 找 -> [Foo-ER] 有 (第二幕初始化的) -> 赋值成功。

---

#### 🎬 第五幕：离开块级作用域 (Block Exit) —— **复原时刻**
代码执行到 `}`。

1.  **销毁/脱离**：
    *   **[Block-ER]** 没什么用了（除非有闭包引用它，否则稍后GC）。
2.  **恢复指针**：
    *   `FooEC.LE` = `[Block-ER].Outer`。
    *   也就是说，`LE` 重新指回了 **[Foo-ER]**。

**此时状态：** `LE === VE` (又重合了)。

---

#### 🎬 第六幕：函数执行结束 (Function Return)
代码执行完 `console.log(funcLet)`。

1.  **ECS 动作**：
    *   **Foo-EC** 从栈顶弹出。
2.  **GC 动作**：
    *   如果全局没有变量引用 `foo` 内部的东西，**[Foo-ER]** 及其父级链断开，内存释放。

---

### 3. 终极总结图表

为了清晰展示这四个概念的区别，请看下表：

| 概念 | 本质 | 在示例中的表现 | 作用 |
| :--- | :--- | :--- | :--- |
| **ECS (栈)** | 数组 (LIFO) | `[GlobalEC, FooEC]` | 记录我们现在处于 `foo` 函数里，且是被 Global 调用的。 |
| **ER (环境记录)** | **对象 (仓库)** | **[Foo-ER]**<br>**[Block-ER]** | 真实存数据的地方。<br>`var` 存在 [Foo-ER]；<br>`let` (块内) 存在 [Block-ER]。 |
| **LE (词法环境)** | **指针 (动态)** | 进块前：指向 [Foo-ER]<br>进块后：指向 [Block-ER]<br>出块后：指向 [Foo-ER] | **用于查找 (Lookup)**。<br>`console.log(a)` 时，总是从 LE 指向的那个 ER 开始找。 |
| **VE (变量环境)** | **指针 (静态)** | 始终指向 [Foo-ER]<br>(即使进了块也不动) | **用于 Var 定义**。<br>告诉引擎：如果你现在遇到 `var` 声明，请把它扔到这个 ER 里去。 |

### 4. 一句话概括

*   **ECS** 是调用路径。
*   **ER** 是存变量的物理仓库。
*   **LE** 是你当前的**近视眼镜**（只能看当下的块，看不到去父级找）。
*   **VE** 是你的**户口本**（不管你在哪流浪，你的 `var` 永远落户在函数级作用域）。


**执行上下文栈 (Execution Context Stack)**，通常也被称为 **调用栈 (Call Stack)**，是 JavaScript 引擎（如 V8）用来管理代码执行顺序的核心机制。

如果把 JavaScript 代码比作一场**舞台剧**，那么：
*   **执行上下文 (Execution Context)** 就是**场景**（当前的变量、环境、this）。
*   **执行上下文栈** 就是**剧本的场次安排表**（记录当前演到了哪一场，演完这场该回哪一场）。

JavaScript 是**单线程**的，这意味着它同一时间只能做一件事。为了不乱套，它必须用这个“栈”来记录当前的执行位置。

---

这是一个非常敏锐的问题！

你发现了一个核心矛盾：如果 `var a` 和 `let b` 在函数作用域中都住在同一个 **[Foo-ER]** 里，JS 引擎凭什么在访问 `a` 时返回 `undefined`，而在访问 `b` 时却抛出 `ReferenceError` (报错)？

答案是：**环境记录 (ER) 里的“变量”不仅仅是一个键值对，它还带有一个“状态标签” (Internal Flag)。**

我们可以把 ER 想象成一个**带状态的表格**，而不是简单的 JSON 对象。

---

### 一、 ER 的真实结构：不仅仅是 Value

在 ECMAScript 规范中，环境记录里的每一个变量绑定（Binding）都有 distinct 的属性。

对于 **[Foo-ER]** 来说，它的内部存储结构更像下面这样：

| 变量名 (Name) | 当前值 (Value) | **初始化状态 (InitializedFlag)** | 是否可删除 (Deletable) |
| :--- | :--- | :--- | :--- |
| `funcVar` (var) | `undefined` | **true (已初始化)** | false |
| `funcLet` (let) | `<empty>` | **false (未初始化)** | false |

**核心区别就在于这个“初始化状态”：**

1.  **var 变量**：在创建时，引擎会自动把它的状态设为 **true**，并强行塞一个 `undefined` 给它。
2.  **let/const 变量**：在创建时，引擎只登记了名字，但把它的状态设为 **false**。

---

### 二、 结合代码的微观演示

让我们回到之前的例子，看引擎是如何利用这个标签来处理访问请求的。

```javascript
function foo() {
    // line 1: 访问 var
    console.log(funcVar); 
    
    // line 2: 访问 let
    console.log(funcLet); 

    // line 3: 声明与赋值
    var funcVar = "F1";
    let funcLet = "F2";
}
foo();
```

#### 1. 创建阶段 (预编译) —— 贴标签
当进入 `foo` 函数，但还没执行第一行代码时，**[Foo-ER]** 被填充满了：

*   **处理 `var funcVar`**：
    *   调用 `CreateMutableBinding("funcVar")`。
    *   **立即调用** `InitializeBinding("funcVar", undefined)`。
    *   **结果**：`{ Name: "funcVar", Value: undefined, Initialized: true }`
*   **处理 `let funcLet`**：
    *   调用 `CreateMutableBinding("funcLet")`。
    *   **停止！不赋值！**
    *   **结果**：`{ Name: "funcLet", Value: empty, Initialized: false }`

#### 2. 执行阶段 —— 查标签

**执行 Line 1: `console.log(funcVar)`**
引擎发出指令：`GetBindingValue("funcVar")`。
*   引擎检查 ER 表格：`funcVar` 的 **Initialized** 是 true 吗？
*   **是**。
*   **动作**：返回它的值 `undefined`。
*   **结果**：控制台打印 `undefined`。

**执行 Line 2: `console.log(funcLet)`**
引擎发出指令：`GetBindingValue("funcLet")`。
*   引擎检查 ER 表格：`funcLet` 的 **Initialized** 是 true 吗？
*   **否** (false)。
*   **动作**：**直接抛出 ReferenceError**。
*   *(这就是传说中的“暂时性死区” TDZ 的底层原理 —— 并不是一个特殊的区域，而是一个 false 的标签)*

**执行 Line 3: `var funcVar = "F1"`**
*   引擎执行赋值操作。
*   **结果**：更新表格，`funcVar` 的值变为 `"F1"`。

**执行 Line 3: `let funcLet = "F2"`**
*   引擎执行赋值操作。
*   **关键动作**：
    1.  把值设为 `"F2"`。
    2.  **把 Initialized 标签改为 true**。
*   *(从此以后，访问 funcLet 就不会报错了)*

---

### 三、 为什么 Global EC 比较特殊？

上面的逻辑适用于**函数环境记录 (Function ER)** 和 **声明式环境记录 (Block ER)**。

但在 **全局环境记录 (Global ER)** 中，区分 var 和 let 的方式稍微有点不同，因为全局 ER 是个“复合体”。

它内部有两个分开的存储区：

1.  **ObjectRecord (对象记录)**：
    *   绑定到 `window` 对象。
    *   **专门存 `var` 和 `function`**。
    *   这里面的变量没有“未初始化”状态，因为 `window` 的属性一旦存在就是可访问的。

2.  **DeclarativeRecord (声明式记录)**：
    *   一个内部的 Map（不对外暴露）。
    *   **专门存 `let` 和 `const`**。
    *   这里面的变量依然使用上面的 **InitializedFlag** 机制来管理 TDZ。

**所以，在全局中：**
*   引擎找 `var` -> 去查 `window` 属性。
*   引擎找 `let` -> 去查那个内部的 Map (并检查初始化标签)。
*   这就是为什么 `window.a` 能访问到 `var a`，但 `window.b` 访问不到 `let b` 的原因。

### 四、 总结

`var` 和 `let` 虽然都住在同一个 ER 里（在函数作用域中），但待遇完全不同：

1.  **ER 结构**：是一个表，包含 `{ Name, Value, Status }`。
2.  **Var**：进门就发“身份证”（Status = Initialized），初始值是 undefined。
3.  **Let**：进门只登记名字，不发“身份证”（Status = Uninitialized）。
4.  **访问规则**：引擎读取变量前，必须先看有没有“身份证”。有就给值，没有就报错。

这是一个非常深刻的架构设计问题。

简单来说，全局环境之所以设计得这么“分裂”和“怪异”，完全是因为 **历史包袱** 和 **向后兼容**。

如果 JS 是今天从零开始设计的，全局环境肯定会和函数环境一样，只有一个单纯的记录表。但 JS 已经存在几十年了，为了不让旧网站崩溃，同时又要引入新特性，TC39（JS 标准委员会）被迫采用了一种**“缝合怪”**的设计方案。

以下是三个核心原因：

### 1. 历史包袱：`var` 必须挂在 `window` 上

在 ES6（2015年）出现之前的 20 年里，JavaScript 只有一个铁律：
> **在全局作用域声明的变量 (`var`)，自动成为全局对象 (`window`) 的属性。**

```javascript
// 老代码 (ES5)
var a = 100;
console.log(window.a); // 100
```

全世界成千上万的旧网站都依赖这个特性。如果 ES6 为了“整洁”，规定所有的变量都存储在内部记录里，不再挂到 `window` 上，那么这些旧网站一夜之间全都会报错。

**结论：** 为了兼容旧代码，全局的 `Object Record` (对象记录) 必须保留，用来专门处理 `var` 和 `function`，并让它们继续映射到 `window` 上。

### 2. 新特性需求：`let` 不能挂在 `window` 上

当设计 `let` 和 `const` 时，标准委员会希望能纠正 JS 的设计缺陷。他们认为：**全局变量不应该污染全局对象。**

如果你在全局写了 `let name = 'jack'`，而不小心覆盖了 `window.name`，可能会导致难以排查的 Bug。

因此，ES6 规定：**`let` 和 `const` 声明的全局变量，必须是“纯粹”的变量，不能变成 `window` 的属性。**

```javascript
// 新代码 (ES6)
let b = 200;
console.log(window.b); // undefined (太好了，没有污染 window)
```

**结论：** 既然不能放在 `Object Record` (window) 里，那就必须给全局环境新增一个 **`Declarative Record` (声明式记录)**，专门用来存放这些“清高”的新变量。

### 3. 最终方案：复合型结构 (Composite Environment Record)

为了同时满足上面两个看起来矛盾的需求，JS 引擎被迫将全局环境设计成一个**组合体**。

我们可以把它想象成一个**“双层钱包”**：

*   **外层口袋 (Object Record)**：
    *   **绑定对象**：直接绑定到 `window`。
    *   **存放内容**：`var`、`function`。
    *   **行为**：这里面的东西，既是变量，也是 `window` 的属性。
    
*   **内层口袋 (Declarative Record)**：
    *   **绑定对象**：无（纯内部存储）。
    *   **存放内容**：`let`、`const`、`class`。
    *   **行为**：这里面的东西，仅仅是变量，**对外不可见**。

---

### 对比：为什么函数环境不需要这样做？

**函数环境 (Function Environment)** 没有历史包袱！

1.  **没有映射对象**：函数执行时，并没有一个像 `window` 那样对外暴露的“函数对象”来让用户访问内部变量。
2.  **纯粹性**：函数内部的变量（无论是 `var` 还是 `let`）都只是局部变量，不需要考虑“污染”谁的问题。

所以，函数环境不需要搞“双层结构”，直接用一个高效的 **Declarative Record** 把 `var` 和 `let` 放在一起管理（通过标签区分状态）是性能最好的选择。

### 总结

*   **函数环境**是**“精装房”**：从零设计，布局合理，`var` 和 `let` 住在一起（同一个 Record），井水不犯河水。
*   **全局环境**是**“老房改造”**：
    *   为了照顾老租客 (`var`)，必须保留旧房间 (`window/ObjectRecord`)。
    *   为了迎接新租客 (`let`)，不得不在旁边盖了一间新房 (`DeclarativeRecord`)。
    *   JS 引擎在查找变量时，必须先翻翻新房，再翻翻旧房，这就是全局环境特殊的根本原因。


这是一个非常关键的细节问题。参数（Parameters）的处理是函数执行上下文初始化中最先发生、也最复杂的步骤之一。

特别是 ES6 引入 **默认参数 (Default Parameters)** 后，JS 引擎在处理参数时，可能会创建**两个分离的环境记录**（参数环境和函数体环境）。

我们需要分两种情况讨论：**全局执行上下文** 和 **函数执行上下文**。

---

### 一、 全局执行上下文 (Global EC)

首先直接给结论：**全局执行上下文（Global EC）没有参数生成的过程。**

#### 为什么？
因为全局代码（Script Code）是作为程序的入口直接执行的，它不是一个被调用的函数，因此不存在“传递参数”给它的概念。

*   **ER 生成**：如前所述，Global EC 初始化时，ER 只有内置的全局属性、`var` 和 `let/const`。
*   **arguments**：全局没有 `arguments` 对象。
*   **形参**：全局没有形参。

*(注：在 Node.js 中，你写的代码其实被包裹在一个 wrapper 函数里 `(function(exports, require, module...){ ... })`，那种情况下它本质上是一个**函数执行上下文**，遵循下面的规则。但在纯浏览器环境的 `<script>` 标签下，Global EC 没有参数。)*

---

### 二、 函数执行上下文 (Function EC) —— 核心重头戏

当函数被调用时，在执行代码前，引擎会运行 **FunctionDeclarationInstantiation (FDI)** 算法。

这里分为 **“简单模式”**（ES5 / 无默认参数）和 **“复杂模式”**（ES6 带默认参数）。

#### 1. 简单模式：没有默认参数 (Simple Parameters)

这是最常见的情况。此时，参数、`var`、`function`、`let` 全部住在一个 **唯一的 Environment Record (Function ER)** 里。

**代码示例：**
```javascript
function foo(name, age) {
    console.log(name);
    var age = 99; 
    function name() {} 
}
foo("Jack", 18);
```

**ER 生成步骤 (按顺序发生)：**

1.  **创建 ER**：创建一个 Function Environment Record。
2.  **处理 `arguments` 对象**：
    *   如果不是箭头函数，创建一个 `arguments` 对象。
    *   在 ER 中绑定名字 `"arguments"`，并指向这个对象。
    *   *严格模式下，arguments 和形参是断开的；非严格模式下，它们有“映射机制”。*
3.  **处理形参 (Formal Parameters)**：
    *   扫描形参列表 `(name, age)`。
    *   **步骤**：
        1.  在 ER 中调用 `CreateMutableBinding("name")`。
        2.  调用 `InitializeBinding("name", "Jack")` (赋值为实参)。
        3.  对 `age` 重复此步骤，赋值为 `18`。
    *   *冲突处理*：如果形参名重复（非严格模式），后一个覆盖前一个。
4.  **处理函数声明 (Function Hoisting)**：
    *   扫描函数体，发现 `function name() {}`。
    *   **关键冲突**：ER 里已经有形参 `"name"`（值为 "Jack"）。
    *   **规则**：**函数声明 覆盖 参数**。
    *   ER 中的 `"name"` 被更新为函数对象引用。
5.  **处理 `var` 声明 (Var Hoisting)**：
    *   扫描函数体，发现 `var age`。
    *   **关键冲突**：ER 里已经有形参 `"age"`（值为 18）。
    *   **规则**：**Var 声明 遇到 参数，不做任何事**（忽略声明，不重置为 undefined）。
    *   ER 中的 `"age"` 依然是 18。

**最终执行前的 ER 快照：**
```javascript
FunctionER = {
    arguments: { 0: "Jack", 1: 18, length: 2 },
    name: <func object>, // 函数覆盖了参数
    age: 18              // var 忽略了，保留参数值
}
```

---

#### 2. 复杂模式：带有默认参数 (Default Parameters) —— 双重环境

这是面试的高阶考点。一旦函数使用了**默认参数**（如 `function foo(x = 1) {}`），JS 引擎为了保证参数表达式的作用域正确性，会创建 **两个 Environment Record**：
1.  **参数环境记录 (Parameter ER)**
2.  **函数体环境记录 (Body ER)**

**代码示例：**
```javascript
var x = "global";

function foo(x, y = function() { x = "modified"; }) { 
    // 参数 x 和 y 在这里初始化
    
    var x = "inner"; // 函数体内的 x
    y(); // 执行参数里的函数
    console.log(x); // ?
}

foo("outer");
```

**ER 生成与作用域链步骤：**

**第一步：创建参数环境 (Param ER)**
*   引擎首先创建一个 ER，专门用来放参数 `x` 和 `y`。
*   `ParamER.x` 初始化为 `"outer"`。
*   `ParamER.y` 初始化为那个匿名函数。
*   **注意**：匿名函数里的 `x` 引用的是 **ParamER** 里的 `x`。

**第二步：创建函数体环境 (Body ER)**
*   因为有默认参数，引擎决定把函数体单独隔离。
*   创建一个新的 ER (**BodyER**)。
*   **关键连接**：`BodyER.OuterEnv` = `ParamER`。
*   **复制参数**：如果函数体里没有同名变量声明，BodyER 甚至不需要存参数。但这里有 `var x`。
*   `var x` 声明在 **BodyER** 中。

**此时的内存结构：**
```text
BodyER (函数体)
   |-- x: "inner"
   |-- OuterEnv ----> ParamER (参数层)
                         |-- x: "outer" (后来被 y 修改为 "modified")
                         |-- y: function
                         |-- OuterEnv ----> GlobalER
```

**执行流程：**
1.  `foo` 调用。
2.  `ParamER` 初始化：`x="outer"`, `y=func`。
3.  `BodyER` 初始化：`var x` (hoisted to undefined)。
4.  代码 `var x = "inner"` 执行：
    *   **BodyER.x** 变为 `"inner"`。
5.  代码 `y()` 执行：
    *   `y` 函数是在 **ParamER** 里创建的，它的作用域链指向 **ParamER**。
    *   `y` 内部执行 `x = "modified"`。
    *   它找 `x`，在 ParamER 里找到了。
    *   **ParamER.x** 变为 `"modified"`。
    *   **注意**：它根本没碰 **BodyER.x** ("inner")。
6.  代码 `console.log(x)`：
    *   当前视野是 **BodyER**。
    *   打印 **BodyER.x** -> `"inner"`。

**结论**：如果只有参数，没有默认值，它们是一家人（同一个 ER）。如果有了默认值，为了防止参数初始化时的逻辑混乱，参数自己住一层，函数体住里面一层。

---

### 三、 总结：ER 生成的决策树

当 JS 引擎准备生成函数调用的 Environment Record 时，它的逻辑如下：

1.  **是 Global 上下文吗？**
    *   Yes -> 不处理参数（因为没有），直接处理全局 var/let。
    *   No -> 进入函数初始化流程。

2.  **函数初始化流程 (FDI)**：
    *   先处理 `arguments` 对象 -> 存入 ER。
    *   处理 **形参 (Formal Params)** -> 存入 ER，用实参赋值。
    *   **Check**：有默认参数吗？
        *   **Yes (复杂模式)**：
            *   当前的 ER 作为 **参数环境**。
            *   创建一个新的 ER 作为 **函数体环境**。
            *   函数体环境指向参数环境。
            *   把函数体内的 `var/let` 放到新的函数体环境中。
        *   **No (简单模式)**：
            *   继续在同一个 ER 里工作。
    *   处理 **Function Declaration** -> 覆盖同名参数。
    *   处理 **Var Declaration** -> 如果同名，忽略（保留参数值）；不同名则初始化 undefined。
    *   处理 **Let/Const** -> 存入，初始化为 TDZ。

### 四、 快速记忆口诀

*   **全局无参数**：Global 是入口，没参数这回事。
*   **函数先参数**：ER 刚建好，先把参数填进去。
*   **函数盖参数**：同名 `function` 声明会把参数值覆盖掉。
*   **Var 让参数**：同名 `var` 声明会让步，不敢覆盖参数的值。
*   **默认分两家**：一旦用了默认参数 `(a=1)`，参数住一楼，函数体住二楼（隔离作用域）。



### 1. 核心概念：什么是“栈”？

栈（Stack）是一种数据结构，原则是 **“后进先出” (LIFO - Last In, First Out)**。

*   **比喻**：就像洗盘子。
    *   你把第一个盘子放最底下。
    *   新的盘子一个个往上叠（压栈 Push）。
    *   洗的时候，必须先从最顶上拿盘子（出栈 Pop），最后才能洗到底下的盘子。

---

### 2. 执行上下文的三种类型

在 JS 中，主要有三种代码运行环境：

1.  **全局执行上下文 (Global Execution Context - GEC)**
    *   **也是栈底**。这是默认的、最基础的上下文。
    *   只要你的 JS 代码一开始运行，引擎就会创建它。
    *   它会创建全局对象（浏览器是 `window`，Node 是 `global`），并将 `this` 指向这个对象。
    *   **整个程序只有一个全局上下文。**

2.  **函数执行上下文 (Function Execution Context - FEC)**
    *   **每当一个函数被调用时**，都会为该函数创建一个全新的上下文。
    *   函数结束（return 或执行完），上下文会被销毁。

3.  **Eval 执行上下文**
    *   `eval()` 函数内部的代码（现在不推荐使用，略过）。

---

### 3. 全程演示：入栈与出栈

让我们看一段代码，模拟引擎是如何操作栈的。

```javascript
// 1. 代码开始运行
var a = 'Hello';

function first() {
    console.log('Inside First');
    second(); // 调用 second
    console.log('First Again');
}

function second() {
    console.log('Inside Second');
}

// 2. 调用 first
first(); 

// 3. 代码结束
console.log('The End');
```

**JS 引擎的心理活动（栈的变化）：**

#### 第一步：初始化
*   浏览器加载脚本。
*   **[压栈]** 创建 **全局执行上下文 (Global)**，推入栈底。

```text
|             |
|   Global    |  <-- 当前正在运行
|_____________|
```

#### 第二步：执行 `first()`
*   遇到 `first()` 调用。
*   **[压栈]** 创建 **first 的函数上下文**，推入栈顶。

```text
|   first()   |  <-- 当前正在运行
|   Global    |
|_____________|
```

#### 第三步：在 `first` 里调用 `second()`
*   `first` 执行了一半，遇到了 `second()`。
*   **[压栈]** 创建 **second 的函数上下文**，推入栈顶。

```text
|  second()   |  <-- 当前正在运行
|   first()   |  <-- 暂停等待
|   Global    |  <-- 暂停等待
|_____________|
```

#### 第四步：`second()` 执行完毕
*   `second` 函数体执行完了。
*   **[出栈]** `second` 的上下文被销毁（Popped）。控制权交还给下一层。

```text
|             |
|   first()   |  <-- 恢复运行（继续执行剩下的代码）
|   Global    |
|_____________|
```

#### 第五步：`first()` 执行完毕
*   `first` 里剩下的代码也执行完了。
*   **[出栈]** `first` 的上下文被销毁。

```text
|             |
|             |
|   Global    |  <-- 恢复运行
|_____________|
```

#### 第六步：页面关闭
*   用户关闭浏览器标签页。
*   **[出栈]** 全局上下文销毁，程序彻底结束。

---

### 4. 深度连接：上下文里有什么？

你之前问过 **变量提升** 和 **作用域**，它们其实就是在“创建上下文”这一步发生的。

每当一个上下文被放入栈中（但在代码执行前），引擎会进行**“创建阶段”**：

1.  **确定 `this` 的指向**。
2.  **创建词法环境 (Lexical Environment)**：
    *   这里记录了 `let`, `const` 变量。
    *   这里记录了 **外部环境引用 (Outer Reference)** —— 这就是 **作用域链** 的原理！(inner 可以访问 outer，就是通过这个引用找过去的)。
3.  **创建变量环境 (Variable Environment)**：
    *   这里处理 `var` 变量和 `function` 声明 —— 这就是 **变量提升** 的发生地！

**所以：执行上下文栈是“壳”，变量对象和作用域链是“核”。**

---

### 5. 栈溢出 (Stack Overflow)

因为栈的内存空间是有限的。如果你疯狂地往里塞盘子，不拿出来，盘子塔就会倒。

最典型的例子是 **死循环递归**：

```javascript
function foo() {
    foo(); // 我 调用 我自己
}

foo();
```

**过程：**
Push `foo` -> Push `foo` -> Push `foo` ...... 无穷无尽。

**结果：**
浏览器报错：`Uncaught RangeError: Maximum call stack size exceeded`。
这就是著名的“栈溢出”。

### 总结

1.  **JS 是单线程的**，通过 **执行上下文栈** 来记录代码执行到了哪里。
2.  **原则**：后进先出 (LIFO)。
3.  **流程**：调用函数 = 压栈 (Push)；函数返回 = 出栈 (Pop)。
4.  **意义**：理解了这个栈，你就理解了为什么 JS 能在函数嵌套调用时，准确地记住了每个函数里的变量状态和返回位置。


这是一次非常棒的知识整合！要把这三个概念（变量提升、作用域、执行上下文）串联起来，我们必须深入到 JS 引擎的**“两步走”策略**。

只要你理解了 **“执行上下文的生命周期”**，你就会发现：**变量提升和作用域链，实际上就是执行上下文在“初始化阶段”产出的两个副产品。**

我把这个过程比作**“剧组开拍前的准备工作”**。

---

### 核心原理：执行上下文的两个阶段

当一个函数被调用（入栈）时，JS 引擎并不是立即执行里面的代码，而是分两步走：

1.  **创建阶段 (Creation Phase)** —— *这里产生了“变量提升”和“作用域链”*
2.  **执行阶段 (Execution Phase)** —— *这里发生了“赋值”和“变量查找”*

---

#### 第一步：创建阶段（准备工作）

当函数被调用，但还没开始运行第一行代码时，引擎会创建一个**执行上下文对象 (AO/VO)**。这个对象大概长这样（伪代码）：

```javascript
ExecutionContext = {
    // 1. 确定作用域链 (Scope Chain)
    // 指向父级上下文，由函数【定义的位置】决定（静态作用域原理）
    OuterEnv: <Ref to Parent Context>,

    // 2. 变量环境 (Variable Environment) —— 处理 var
    // 这里就是【变量提升】发生的物理场所
    VariableEnvironment: {
        a: undefined,  // 发现了 var a，先占位，赋值 undefined
        foo: <ref to function> // 发现了 function foo，直接存整个函数
    },

    // 3. 词法环境 (Lexical Environment) —— 处理 let/const
    LexicalEnvironment: {
        b: <uninitialized>, // 发现了 let b，占位，但【不初始化】(TDZ 死区原理)
    }
}
```

**这一步解释了所有原理：**

1.  **为什么会有变量提升？**
    *   因为在代码执行前，引擎必须先扫描一遍，把 `var` 和 `function` 存进 `VariableEnvironment` 内存里。
    *   对于 `var`，引擎为了省事，默认填了个 `undefined`。所以你在代码第一行就能访问到它，只是没值。
    *   对于 `function`，引擎把整个函数体都存好了。

2.  **为什么会有作用域链？**
    *   引擎在创建这个上下文时，会根据函数的**“出生地”**，把 `OuterEnv` 指针指向父级上下文。
    *   这就是静态作用域的物理实现：**这个指针在代码跑起来之前就已经定死了。**

---

#### 第二步：执行阶段（正式开拍）

准备工作做完了，引擎开始一行一行执行代码。

1.  **赋值**：
    *   遇到 `var a = 10;`，引擎去内存里把 `a: undefined` 改成 `a: 10`。
    *   遇到 `let b = 20;`，引擎把 `b` 的“未初始化”状态撕掉，填入 `20`。

2.  **变量查找（作用域链查找）**：
    *   如果代码里写了 `console.log(x)`。
    *   引擎先看**当前**上下文的 `LexicalEnvironment` 或 `VariableEnvironment` 里有没有 `x`？
    *   如果没有，顺着 **`OuterEnv` (作用域链)** 指针往上找父级。
    *   一直找到全局，找不到就报错。

---

### 实战演示：把三个概念串起来

看这段代码，我们来模拟引擎的**上帝视角**：

```javascript
var globalName = "Global";

function outer() {
    console.log(myName); // ① 打印什么？
    var myName = "Outer";

    function inner() {
        console.log(globalName); // ② 怎么找到的？
    }
    
    inner();
}

outer();
```

#### 过程还原：

**1. 全局上下文创建**
*   **提升**：`globalName` 被设置为 `undefined`，`outer` 函数被完整存储。

**2. `outer()` 被调用 -> 创建 `outer` 上下文**
*   **OuterEnv (作用域)**：指向 Global（因为 `outer` 定义在全局）。
*   **提升 (Hoisting)**：扫描到 `var myName`。在内存里记录 `myName: undefined`。扫描到 `function inner`，存储引用。
*   **执行**：
    *   运行 `console.log(myName)`：此时还在第一行，查找内存，发现 `myName` 是 `undefined`。**（这就是变量提升的效果）**。
    *   运行 `var myName = "Outer"`：内存里的 `myName` 更新为 `"Outer"`。

**3. `inner()` 被调用 -> 创建 `inner` 上下文**
*   **OuterEnv (作用域)**：指向 `outer` 上下文（因为 `inner` **定义**在 `outer` 里面）。**（这就是静态作用域的效果）**。
*   **执行**：
    *   运行 `console.log(globalName)`。
    *   **查找链路**：
        1.  `inner` 自己有吗？没有。
        2.  顺着 OuterEnv 找 `outer` 上下文，有吗？没有。
        3.  再顺着 OuterEnv 找 Global 上下文，有吗？有！值为 `"Global"`。

---

### 总结：终极原理

你只要记住一句话：

**执行上下文是“容器”，变量提升是容器“初始化”时的预处理，作用域链是容器“初始化”时确定的父级指针。**

*   **变量提升**：是上下文**创建时**，引擎扫描变量声明并分配内存的副作用。
*   **作用域**：是上下文**创建时**，引擎根据函数定义位置确定的 `outer` 引用指针。
*   **栈**：是用来管理这些容器（上下文）生灭顺序的列表。

是的，**会替换**。

而且在这个例子中，替换的规则非常简单，就是最基础的 **“代码执行顺序”** 规则。

要彻底搞懂它，我们需要区分 **“函数表达式”**（你写的这种）和 **“函数声明”**（直接写 `function foo`）。它们的表现是完全不一样的。

---

### 1. 你的代码：函数表达式 (Function Expression)

你使用的是 `var foo = ...`。在 JS 引擎眼里，这**不是**在定义函数，而是在**给变量赋值**。

这就好比：
```javascript
var a = 1;
console.log(a); // 1
var a = 2;
console.log(a); // 2
```
函数在 JS 里只是一个**值**（对象），跟数字 `1` 和 `2` 没有任何区别。

#### 引擎执行过程还原：

还记得我们刚才讲的 **“两个阶段”** 吗？

**阶段一：编译/创建阶段（变量提升）**
引擎扫描代码，只看到了两个 `var foo`。
1.  发现 `var foo`，声明变量 `foo`，初始化为 `undefined`。
2.  又发现 `var foo`，引擎说：“哦，`foo` 已经声明过了，忽略这次声明。”
3.  **注意**：此时赋值还没发生！

**阶段二：执行阶段（按顺序跑）**
此时内存里的 `foo` 是 `undefined`。

1.  **执行第 1 行**：`foo = function () { ...foo1... }`。
    *   **动作**：把 `foo` 这个变量指向第一个函数的内存地址。
2.  **执行第 5 行**：`foo()`。
    *   **动作**：调用 `foo`，输出 `'foo1'`。
3.  **执行第 7 行**：`foo = function () { ...foo2... }`。
    *   **动作**：**重新赋值**。把 `foo` 的指针从第一个函数移开，指向第二个函数。
4.  **执行第 11 行**：`foo()`。
    *   **动作**：调用 `foo`，此时它指向的是第二个函数，输出 `'foo2'`。

**结论**：这是**运行时替换**。执行到哪一行，`foo` 就变成什么。

---

### 2. 对比：如果是“函数声明” (Function Declaration)

这是最容易混淆的地方！如果你的代码改成下面这样，结果会**大震荡**：

```javascript
// 写法 B：函数声明
function foo() {
    console.log('foo1');
}

foo(); // 猜猜是啥？ -> 'foo2' ！！！

function foo() {
    console.log('foo2');
}

foo(); // 'foo2'
```

**为什么全是 `foo2`？**
因为**函数声明的替换发生在“编译阶段”**。

**引擎执行过程还原（写法 B）：**

**阶段一：编译/创建阶段**
1.  引擎扫描到第一个 `function foo`：把 `foo` 指向函数体 1。
2.  引擎扫描到第二个 `function foo`：**发现同名函数！** 引擎会用**新的函数体覆盖旧的**。
3.  **结果**：在代码一行都没执行之前，内存里的 `foo` 就已经是 **第二个函数** (`foo2`) 了。

**阶段二：执行阶段**
1.  **执行第 5 行** `foo()`：查找 `foo`，得到的是 `foo2`，输出 `'foo2'`。
2.  **执行第 11 行** `foo()`：查找 `foo`，依然是 `foo2`，输出 `'foo2'`。

---

### 3. 总结替换规则

| 代码形式 | 例子 | 替换发生的时机 | 规则 |
| :--- | :--- | :--- | :--- |
| **函数表达式** | `var foo = function(){}` | **执行阶段** (Runtime) | **“后浪推前浪”**。代码执行到哪一行，变量就被赋值成什么。没执行到那行之前，它还是旧值。 |
| **函数声明** | `function foo(){}` | **编译阶段** (Compile time) | **“后来者居上”**。在代码运行前，最后定义的那个函数声明会覆盖前面所有的同名声明。 |

**回到你的代码**：
因为你用的是 `var` 赋值（函数表达式），所以它遵循的是 **“执行顺序”**。
*   第一次调用时，`foo` 是 `foo1`。
*   第二次赋值后，`foo` 变成了 `foo2`。
*   它是**“按部就班”**被替换的。

这是一个触及 ECMAScript 规范底层设计哲学的深层问题。

简单来说，把它们分开存放，是为了**解决“块级作用域”与“函数作用域”共存时的矛盾**。

**`VariableEnvironment` (变量环境，简称 VE)** 是为了照顾旧时代的 **`var`**（函数作用域）。
**`LexicalEnvironment` (词法环境，简称 LE)** 是为了迎合新时代的 **`let/const`**（块级作用域）。

我们可以从**“不动”**与**“变动”**的角度来彻底理解这个设计。

---

### 1. 根本冲突：`var` 是个“穿墙怪”

想象一下，如果只有一个环境（比如只有 LE），会发生什么问题？

```javascript
function demo() {
    var a = 1; // 函数级
    {
        let b = 2; // 块级
        var c = 3; // 还是函数级（穿墙）
    }
}
```

当代码执行到花括号 `{ ... }` 里面时：
*   **`b` (let)** 说：“我属于这个块，出了花括号我就得死。”
*   **`c` (var)** 说：“我不属于这个块，我是属于 `demo` 函数的，出了花括号我还要活着。”

**矛盾来了**：如果它们都存在同一个对象里，当花括号结束，销毁这个环境时，`b` 死了，但 `c` 也被误杀陪葬了！这不行。

所以，引擎必须维护两个指针：
1.  **VE 指针**：永远指向**函数的最顶层作用域**（大本营）。
2.  **LE 指针**：随着代码执行进入不同的块，**动态指向当前所在的块级作用域**（临时营地）。

---

### 2. 动态演示：LE 的“套娃” vs VE 的“钉子”

让我们看看 JS 引擎是如何利用这两个环境来处理代码的。

**代码：**
```javascript
function foo() {
    var a = 10;
    let b = 20;
    
    {
        let c = 30;
        var d = 40;
    }
}
```

#### 阶段 1：函数刚开始执行 (进入 `foo`)
此时，LE 和 VE 指向同一个地方（函数最顶层）。

*   **VE** -> `Scope(foo)` (存了 `var a`, `var d`)
*   **LE** -> `Scope(foo)` (存了 `let b`)

> 注意：`var d` 虽然写在后面，但因为是 `var`，它直接被丢进了 **VE** 指向的地方（也就是函数顶层）。这就是为什么 `var` 能无视块级作用域。

#### 阶段 2：进入花括号 `{` (块级作用域)
JS 引擎会**新建**一个词法环境（Block Scope），并把 **LE 指针** 移过去。
**但是，VE 指针原地不动！**

*   **VE** (不动) -> `Scope(foo)`
*   **LE** (变了) -> `Scope(Block)` -> `parent: Scope(foo)`

此时：
*   如果遇到 `let c = 30`：引擎看 **LE**。LE 现在指向 `Scope(Block)`，所以在块里创建 `c`。
*   如果遇到 `var d = 40`：引擎看 **VE**。VE 依然指向 `Scope(foo)`，所以在函数顶层创建 `d`。

**这就是原理！**
通过把 `var` 绑定在“不动的”VE 上，把 `let` 绑定在“随时变的”LE 上，JS 引擎完美实现了 `var` 的穿透效果。

#### 阶段 3：离开花括号 `}`
块级作用域结束。
*   **LE 指针** 退回上一层（恢复指向 `Scope(foo)`）。
*   刚才那个 `Scope(Block)` 因为没人引用了，带着 `let c` 一起销毁。
*   但是 **VE** 指向的 `Scope(foo)` 依然健在，里面的 `var d` 毫发无损。

---

### 3. 为什么不直接把 var 也放进 LE？

在 ES6 规范之前的旧版本里，确实只有 `VariableObject` (VO)。
但在 ES6 引入 `let/const` 后，为了**兼容**旧代码（Web 兼容性是 JS 的底线），不能修改 `var` 的行为。

*   **如果把 var 放进当前的 LE**：那 `var` 就会变成块级作用域，以前依赖 `var` 穿透特性的老代码全都会报错（比如在 `if` 里定义 `var`，在 `if` 外面用）。
*   **所以必须分开**：
    *   **LexicalEnvironment (LE)**：它是**栈顶**，处理所有新特性（`let`, `const`, `class`, `try-catch`），紧跟代码块的嵌套。
    *   **VariableEnvironment (VE)**：它是**栈底**（针对当前函数而言），处理旧特性（`var`, `function` 声明），死死咬住函数的根部不放。

### 总结

*   **LexicalEnvironment (词法环境)**：是**随波逐流**的。进入 `if/for` 块，它就创建一个新的环境套在外面。`let/const` 跟着它走，所以有块级作用域。
*   **VariableEnvironment (变量环境)**：是**初心不改**的。无论你嵌套了多少层 `{}`，它永远指向这个函数的**最外层**。`var` 跟着它走，所以 `var` 永远是函数作用域。

这就是 JS 引擎为了在一个函数里同时支持“块级”和“函数级”两种作用域，而设计出的**双指针策略**。

**你的直觉非常敏锐，答案是肯定的！**

但准确地说，在内存结构上，它们不是像俄罗斯套娃那样物理上的“层层包裹”，而是像**链表**一样通过**指针**连接起来的。

这种连接机制被称为 **“外部环境引用” (Outer Environment Reference)**。这就是作用域链（Scope Chain）的物理真身。

我们来一步步拆解 JS 引擎是如何执行你这段代码的：

---

### 1. LE 的内部结构：不仅仅是存变量

每个词法环境（LE）在内存里其实长这样：

```javascript
LexicalEnvironment = {
    // 1. 环境记录器：存变量的地方
    EnvironmentRecord: { 
        a: 1, 
        // ... 
    },
    
    // 2. 外部引用：指向父级 LE 的指针 (关键！)
    outer: <Reference to Parent LE> 
}
```

正是这个 **`outer`** 字段，把一个个独立的块级作用域串成了一条链。

---

### 2. 你的代码执行过程还原

我们把你这段代码放入一个假设的全局环境中运行：

```javascript
// Global Scope
{ // Block 1 (父)
    let a = 1;
    { // Block 2 (子)
        console.log(a);
    }
}
```

#### 第一步：进入 Block 1 (父块)

引擎遇到了第一个 `{`，并发现了 `let a`。
它创建了一个新的词法环境，我们叫它 **LE_Parent**。

```javascript
LE_Parent = {
    EnvironmentRecord: {
        a: 1   // 变量 a 存在这里
    },
    outer: GlobalEnv // 指向上一级（全局）
};
```

#### 第二步：进入 Block 2 (子块)

代码执行到里面的 `{`。引擎又创建了一个新的词法环境，叫 **LE_Child**。
**关键点来了：** 引擎会把当前正在运行的环境（即 `LE_Parent`）赋值给新环境的 `outer`。

```javascript
LE_Child = {
    EnvironmentRecord: {
        // 这里是空的，因为你在这个块里没写 let/const
    },
    outer: LE_Parent // 🔥 指向了父亲！
};
```

此时，JS 引擎把当前的 **LE 指针** 从 `LE_Parent` 移到了 `LE_Child`。

#### 第三步：执行 `console.log(a)`

现在引擎要查找变量 `a` 的值。查找过程如下（也就是**作用域链查找**）：

1.  **问自己**：引擎先问当前的 **LE_Child**：“你的 `EnvironmentRecord` 里有 `a` 吗？”
    *   **回答**：“没有。”
2.  **问父亲**：引擎顺着 **`outer`** 指针找到 **LE_Parent**，问：“你那里有 `a` 吗？”
    *   **回答**：“有！值是 1。”
3.  **结果**：取回 1，打印出来。

---

### 3. 形象的比喻：寻宝游戏

*   **LE_Child** 是你现在的房间。
*   **LE_Parent** 是外面的客厅。
*   **Global** 是整栋房子。

你手里拿有一根绳子（`outer` 指针），这根绳子的一头拴在你腰上，另一头拴在客厅的门把手上。

当你想要找一个东西（变量 `a`）时：
1.  你先看**房间**里有没有。
2.  如果没有，你顺着绳子摸到**客厅**去找。
3.  如果客厅还没有，你再顺着客厅的绳子摸到**房子外面**去找。

这就是**“词法环境嵌套”**与**“访问父作用域”**的底层实现原理。

### 总结

*   **是嵌套的吗？** 逻辑上是嵌套的，物理实现上是**链表结构**。
*   **怎么访问父作用域？** 依靠每个 LE 内部自带的 **`outer` 指针**。
*   **作用域链是什么？** 就是这一连串 `outer` 指针连起来形成的查找路径。
*   
这是一个非常深刻的问题，触及到了 JavaScript 引擎的核心机制。

**直接回答你：**
1.  **有极强的联系**。`this` 实际上是**执行上下文（Execution Context）** 的三个核心组成部分之一。
2.  **Lambda（箭头函数）没有 `this`**，是因为引擎在创建箭头函数的执行上下文时，**故意跳过了 `ThisBinding` 的初始化步骤**，导致它必须像查找普通变量一样，顺着作用域链（`outer` 指针）往外找。

下面为你深度拆解这两个层面。

---

### 第一部分：`this` 与 执行上下文 的血缘关系

在 V8 引擎的规范中，每一个执行上下文（EC）在创建时，在内存中大概是这样的结构：

```javascript
ExecutionContext = {
    // 1. 词法环境 (let/const/outer)
    LexicalEnvironment: { ... },

    // 2. 变量环境 (var)
    VariableEnvironment: { ... },

    // 3. This 绑定 (ThisBinding) —— 这里就是 this 的家！
    ThisBinding: <Reference to Object> 
}
```

#### 核心机制：
*   **`this` 不是变量**：它不存放在 `LexicalEnvironment` 的记录表里。
*   **`this` 是上下文的属性**：它和环境记录器是平级的。
*   **赋值时机**：
    *   对于**普通函数**，`ThisBinding` 的值是在**函数被调用的一瞬间**（执行上下文创建阶段）决定的。
    *   引擎会根据**调用方式**（是 `obj.fn()` 还是 `fn()` 还是 `new fn()`）来计算出 `ThisBinding` 应该指向谁。

这就是为什么说“`this` 是动态作用域”的表现——因为它取决于**上下文是如何被创建的**。

---

### 第二部分：深入解答 Lambda（箭头函数）没有指针的问题

你可能会疑惑：*“箭头函数也有执行上下文栈，也入栈，为什么偏偏它没有 `this`？”*

这需要从**引擎实现**和**编译原理**两个角度来看。

#### 1. 引擎视角的“偷懒” (The Missing Binding)

当 JS 引擎执行到一个**普通函数**时，它会做三件事：
1.  创建环境。
2.  初始化变量。
3.  **计算并绑定 `this`**。

但当引擎执行到一个**箭头函数**时，它采用了**简化的创建逻辑**：
1.  创建环境。
2.  初始化变量。
3.  **跳过 `this` 绑定！**（它根本不创建 `ThisBinding` 这个槽位，或者将其标记为“词法继承”）。

**结果就是：**
当你在箭头函数里写 `console.log(this)` 时，引擎在当前上下文的 `ThisBinding` 里找不到东西（或者根本没有这个属性）。

#### 2. 补救措施：把 `this` 当作普通变量查找

既然自己没有，引擎就会启用**兜底机制**：
**将 `this` 视为一个普通的变量名，启用作用域链查找机制。**

*   **步骤 A**：当前箭头函数上下文有 `this` 吗？ -> 没有。
*   **步骤 B**：顺着 `LexicalEnvironment.outer`（外部环境引用）去父级上下文找。
*   **步骤 C**：父级如果是普通函数，它有 `ThisBinding`，那就用它的。如果父级还是箭头函数，继续往上找，直到找到全局。

**这就是为什么我们说箭头函数的 `this` 是“词法作用域（Lexical Scoping）”的：因为它和查找 `let a = 1` 的逻辑一模一样，完全取决于它定义在哪里（外部环境是谁）。**

---

### 第三部分：最直观的证据（Babel 编译）

如果你还是觉得抽象，看看 TypeScript 或 Babel 是怎么把箭头函数“翻译”成 ES5 代码的，真相就大白了。

**你的源代码（ES6 箭头函数）：**
```javascript
const obj = {
    name: "余天山",
    run: function() {
        // 这里是箭头函数
        setTimeout(() => {
            console.log(this.name);
        }, 100);
    }
};
```

**编译器生成的代码（ES5）：**
```javascript
var obj = {
    name: "余天山",
    run: function() {
        // 1. 在父级作用域，把 this 存到一个普通变量 _this 里
        var _this = this; 

        setTimeout(function() {
            // 2. 这里的函数变成了普通函数
            // 3. 里面不再用 this，而是用闭包变量 _this
            console.log(_this.name);
        }, 100);
    }
};
```

**看懂了吗？**
*   箭头函数在底层本质上就是**闭包**。
*   它所谓的“没有 `this`”，在实现上就是**偷偷在外面存了个 `var _this = this`，然后在内部用 `_this` 替换了所有的 `this`**。
*   所以它不需要自己的 `this` 指针，它“偷”了父亲的 `this`。

---

### 总结

1.  **联系**：`this` 是执行上下文的一个**核心属性（ThisBinding）**，它的值在上下文创建阶段被动态计算。
2.  **箭头函数**：
    *   **上下文层面**：引擎在创建箭头函数的上下文时，**阉割**了 `ThisBinding` 的初始化过程。
    *   **查找层面**：因为自己没有，引擎被迫把它当成**普通变量**，沿着 `outer` 指针去父级词法环境里找。
    *   **结果**：它的 `this` 在定义时就确定了（因为父级是谁早就定死了），这就是所谓的“词法固定”。

这是一个非常好的指正。确实，刚才我们更多是在讨论原理（执行上下文、箭头函数），而忽略了 `this` 在**普通函数**中那些千变万化的绑定规则。

`this` 的绑定规则是 JavaScript 面试中的“必考题”，也是开发中最容易踩坑的地方。

要彻底掌握 `this`，你只需要记住一句话：**除了箭头函数，`this` 跟函数在哪里定义完全没关系，只跟函数“怎么被调用”有关系。**

我们将 `this` 的绑定规则划分为 **5 种场景**，优先级从低到高排列：

---

### 1. 默认绑定 (Default Binding) —— “无家可归”

这是最普通的函数调用，前面没有任何修饰符。

*   **场景**：独立函数调用 `foo()`。
*   **规则**：
    *   **非严格模式**：`this` 指向全局对象（浏览器是 `window`，Node 是 `global`）。
    *   **严格模式 (`'use strict'`)**：`this` 指向 `undefined`（这是为了防止你无意中修改全局变量）。

```javascript
function foo() {
    console.log(this.a);
}

var a = 2;

// 1. 裸奔调用
foo(); // 浏览器输出 2，严格模式报错
```

---

### 2. 隐式绑定 (Implicit Binding) —— “有主认主”

这是开发中最常见的场景。

*   **场景**：函数作为对象的方法被调用 `obj.foo()`。
*   **规则**：`this` 指向**调用位置**（Call Site）左侧紧邻的那个对象。

```javascript
function foo() {
    console.log(this.a);
}

const obj = {
    a: 2,
    foo: foo // 引用上面的函数
};

// 2. 有主调用
obj.foo(); // 输出 2，因为是 obj 叫的它
```

#### 🚨 经典大坑：隐式丢失 (Implicit Binding Loss)

这是面试官最爱问的。当你把一个对象的方法赋值给一个变量，或者作为参数传入回调函数时，**“主”就丢了**，退化成默认绑定。

```javascript
const obj = {
    a: 2,
    foo: function() {
        console.log(this.a);
    }
};

const bar = obj.foo; // 注意：这里只是引用了函数本身，没执行！

var a = "全局";

// 虽然 bar 引用的是 obj.foo，但调用时是“裸奔”的
bar(); // 输出 "全局" (非严格模式) 或 undefined
```
**原因**：`bar` 只是一个指向函数的指针，它和 `obj` 已经解绑了。

---

### 3. 显式绑定 (Explicit Binding) —— “强行认爹”

如果你不想让 `this` 乱跑，或者想复用其他对象的方法，可以使用 `call`、`apply`、`bind`。

*   **场景**：`foo.call(obj)`。
*   **规则**：强制把 `this` 绑定给你指定的对象。

```javascript
function foo() {
    console.log(this.a);
}

const obj = { a: 2 };

// 3. 强行指定
foo.call(obj); // 2
foo.apply(obj); // 2
```

#### 硬绑定 (`bind`)
`bind` 会返回一个新的函数，这个新函数的 `this` 被**永久锁死**了，哪怕你后面再 `call` 它也改不了。

```javascript
const bar = foo.bind(obj);
bar(); // 2
bar.call(window); // 还是 2！bind 优先级高于普通的 call
```

> **小贴士**：如果你把 `null` 或 `undefined` 传给 `call/apply`，比如 `foo.call(null)`，规则会退化成**默认绑定**（指向 window 或 undefined）。

---

### 4. `new` 绑定 (New Binding) —— “自立门户”

这是面向对象编程的核心。

*   **场景**：`new Foo()`。
*   **规则**：`this` 指向**新创建出来的那个实例对象**。

当执行 `new Foo()` 时，JS 引擎内部做了 4 件事：
1.  创建一个全新的空对象 `{}`。
2.  把这个对象的原型链 (`__proto__`) 链接到 `Foo.prototype`。
3.  **把函数里的 `this` 绑定给这个新对象，并执行函数**。
4.  如果函数没返回其他对象，就自动返回这个新对象。

```javascript
function Foo(a) {
    this.a = a;
}

const bar = new Foo(2);
console.log(bar.a); // 2
```

---

### 5. 箭头函数绑定 (Lexical Binding) —— “拼爹”

这是 ES6 新增的特例，我们在上一个问题里深入讨论过。

*   **场景**：`() => {}`。
*   **规则**：**彻底无视**上面前 4 种规则（除了 `new`，箭头函数不能 `new`）。它没有自己的 `this`，它完全继承**定义时**外层的 `this`。

```javascript
const obj = {
    a: 2,
    foo: function() { // 普通函数，this 是 obj
        setTimeout(() => {
            // 箭头函数，this 继承自外层的 foo，也就是 obj
            console.log(this.a); 
        }, 100);
    }
};

obj.foo(); // 2
```

---

### 👹 终极 Boss：优先级大乱斗

如果同一个函数调用里，同时出现了多种规则，谁说了算？

**优先级排行榜（从高到低）：**

1.  **`new` 绑定**（优先级最高！）
    *   如果你 `new` 了一个被 `bind` 过的函数，`new` 会覆盖 `bind`。
2.  **显式绑定** (`call`, `apply`, `bind`)
3.  **隐式绑定** (`obj.foo()`)
4.  **默认绑定** (`foo()`)

**证明 `new` > `bind` 的例子：**

```javascript
function foo(something) {
    this.a = something;
}

const obj1 = {};

// 1. 先用 bind 把 this 锁死在 obj1 上
const bar = foo.bind(obj1);
bar(2);
console.log(obj1.a); // 2

// 2. 然后用 new 去调用这个被锁死的函数
// 按照常理 bar 的 this 应该是 obj1，但 new 不答应
const baz = new bar(3);

console.log(obj1.a); // 2 (没变)
console.log(baz.a);  // 3 (new 把 this 抢过来给了新对象 baz)
```

### 总结一张表

看到 `this`，请按顺序问自己这 4 个问题：

1.  **是箭头函数吗？**
    *   是 -> `this` 是外层作用域的 `this`。（查看定义位置）
2.  **是 `new` 调用的吗？**
    *   是 -> `this` 是新创建的实例对象。
3.  **是谁 `call`、`apply` 或者 `bind` 的吗？**
    *   是 -> `this` 是被指定的那个对象。
4.  **是 `obj.method()` 这样调用的吗？**
    *   是 -> `this` 是那个 `obj`。
5.  **都不是？（裸奔调用）**
    *   -> `this` 是 `window` (严格模式下是 `undefined`)。*   

这是一个非常专业且切中肯綮的要求。之前的解释更多基于 ES3 的 VO/AO 模型（便于理解但已过时）。现在的 JS 引擎（V8, SpiderMonkey 等）是基于 **ES6+ 规范** 实现的。

在 ES6+ 规范中，**执行上下文 (Execution Context, EC)** 的结构发生了根本性的变化。不再有 VO/AO，取而代之的是 **词法环境 (Lexical Environment)** 和 **变量环境 (Variable Environment)**。

以下是基于 **ECMAScript 最新规范** 的深度解析。

---

### 一、 核心架构：执行上下文 (EC) 的内部结构

在 ES6+ 中，一个 **执行上下文 (EC)** 伪代码结构如下：

```javascript
ExecutionContext = {
  // 1. 确定 this 的指向
  ThisBinding: <Global Object | Object | undefined>,

  // 2. 词法环境：处理 let, const, function, try-catch, block
  LexicalEnvironment: {
      EnvironmentRecord: { ... },  // 存储变量的地方
      OuterEnvReference: <...>     // 指向父级环境（作用域链）
  },

  // 3. 变量环境：专门处理 var 声明
  VariableEnvironment: {
      EnvironmentRecord: { ... },
      OuterEnvReference: <...>
  }
}
```

#### 关键组件解析：

1.  **Environment Record (环境记录)**：
    *   相当于以前的 VO/AO，是实际存储变量和函数的地方。
    *   **对象环境记录 (Object ER)**：绑定到对象（如全局的 `window`）。
    *   **声明式环境记录 (Declarative ER)**：存储 `var`, `let`, `const`, `function` 等。

2.  **Outer Reference (外部引用)**：
    *   这就是 **作用域链** 的物理实现。它指向**词法层面**的父级环境。

3.  **Variable vs Lexical Environment**：
    *   **VE (变量环境)**：主要用于存储 `var` 声明和函数声明（Function Declaration）。
    *   **LE (词法环境)**：初始时与 VE 相同。但在进入块级作用域（`if`, `for`）时，会创建新的 LE 来存储块内部的 `let/const`，从而实现块级作用域。

---

### 二、 深度推演：从创建到执行的全过程

为了把这个讲透，我们用一段包含 **Global**, **Function**, **Block**, **Let/Var**, **This** 的复杂代码来手动模拟 JS 引擎的每一步。

#### 示例代码

```javascript
var g_var = "Global Var";
let g_let = "Global Let";

function foo(arg) {
    console.log(arg); 
    console.log(a); // undefined (var 提升)
    // console.log(b); // 报错 ReferenceError (TDZ)
    
    var a = "Var A";
    let b = "Let B";
    
    {
        let b = "Block B"; // 遮蔽了外面的 b
        const c = "Block C";
        console.log(b); 
        console.log(this); 
    }
    
    const arrow = () => {
        console.log(this.g_var);
    };
    arrow();
}

foo("Argument");
```

---

### 第一阶段：全局执行上下文 (Global EC) 的创建与执行

当浏览器加载脚本时，首先创建 **Global EC**。

#### 1. Global EC 创建阶段 (Creation Phase)

引擎扫描全局代码（此时代码未执行）：

*   **ThisBinding**: 指向 `window`。
*   **VariableEnvironment (处理 `var`)**:
    *   扫描到 `var g_var`。
    *   记录: `{ g_var: undefined }`。
*   **LexicalEnvironment (处理 `let/const/func`)**:
    *   扫描到 `let g_let`。
    *   记录: `{ g_let: <uninitialized> }`。**注意：** 这里就是 **TDZ (暂时性死区)** 的来源。虽然名字登记了，但不能访问。
    *   扫描到 `function foo`。
    *   记录: `{ foo: <func reference> }`。**函数声明被完整提升**。

**此时 Global EC 伪代码：**
```javascript
GlobalEC = {
  ThisBinding: window,
  LexicalEnvironment: {
    EnvironmentRecord: { 
      Type: "Declarative", // 或者是 ObjectRecord 混合
      g_let: <uninitialized>,
      foo: <func object>
    },
    OuterEnvReference: null
  },
  VariableEnvironment: {
    EnvironmentRecord: { 
      Type: "Object", // Global 指向 window
      g_var: undefined,
    },
    OuterEnvReference: null
  }
}
```

#### 2. Global EC 执行阶段 (Execution Phase)

开始逐行执行全局代码：
1.  `var g_var = "Global Var"`: VE 中的 `g_var` 变为 `"Global Var"`。
2.  `let g_let = "Global Let"`: LE 中的 `g_let` 初始化完成，TDZ 结束，赋值。
3.  调用 `foo("Argument")` -> **准备创建函数执行上下文**。

---

### 第二阶段：foo 函数执行上下文

当调用 `foo` 时，引擎创建 `foo` 的 EC 并压入栈顶。

#### 1. foo EC 创建阶段

*   **ThisBinding**:
    *   检查调用方式：`foo("Argument")` 是**独立调用**。
    *   非严格模式 -> `window`。
    *   严格模式 -> `undefined`。
*   **VariableEnvironment (VE)**:
    *   扫描 `arguments`: `{ 0: "Argument", length: 1 }`。
    *   扫描形参 `arg`: 赋值为 `"Argument"`。
    *   扫描 `var a`: 初始化为 `undefined` (提升)。
*   **LexicalEnvironment (LE)**:
    *   初始化与 VE 相同。
    *   扫描 `let b`: 记录为 `<uninitialized>` (TDZ)。
    *   扫描 `const arrow`: 记录为 `<uninitialized>` (TDZ)。
*   **OuterEnvReference**:
    *   指向 `foo` **定义时** 所在的环境 -> `GlobalEC.LexicalEnvironment`。

**此时 foo EC 伪代码：**
```javascript
FooEC = {
  ThisBinding: window, // 独立调用
  LexicalEnvironment: {
    EnvironmentRecord: {
      arg: "Argument",
      arguments: {0: "Argument", ...},
      b: <uninitialized>,
      arrow: <uninitialized>
    },
    OuterEnvReference: GlobalEC.LexicalEnvironment
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      a: undefined 
    },
    OuterEnvReference: GlobalEC.LexicalEnvironment
  }
}
```

#### 2. foo EC 执行阶段

1.  `console.log(arg)`: 在 LE 找到 `arg` -> 输出 `"Argument"`。
2.  `console.log(a)`: 在 VE 找到 `a` -> 输出 `undefined` (这就解释了 var 提升)。
3.  `var a = "Var A"`: VE 中 `a` 赋值。
4.  `let b = "Let B"`: LE 中 `b` 初始化并赋值。

---

### 第三阶段：进入块级作用域 (Block Scope)

当代码执行到 `{ ... }` 块时，JS 引擎**不会**创建新的 EC，而是创建**一个新的词法环境 (Lexical Environment)**。

1.  创建新的 Block LE。
2.  **OuterRef** 指向 `foo` 函数当前的 LE。
3.  将 `foo` EC 的 `LexicalEnvironment` 指针临时指向这个新的 Block LE。

**此时 foo EC 变成了这样（嵌套环境）：**

```javascript
// 此时的运行环境
BlockLE = {
  EnvironmentRecord: {
    b: <uninitialized>, // 块内的 b
    c: <uninitialized>
  },
  OuterEnvReference: FooEC.OriginalLE // 指回函数的环境
}

FooEC.LexicalEnvironment = BlockLE; // 指针切换
```

**块内执行过程：**
1.  `let b = "Block B"`: BlockLE 中的 `b` 赋值。**注意**：这里访问 `b` 时，直接在 BlockLE 找到了，不会去外面找。这就是**变量遮蔽 (Shadowing)**。
2.  `console.log(this)`:
    *   BlockLE 记录中没有 `this`。
    *   **只有函数和全局才有 `this` 处理机制**。
    *   沿着 Outer 找 -> 找到 `foo` 环境 -> 也没有记录 `this`（`this` 存储在 EC 层级，不在 ER 记录里，但逻辑上可以理解为继承上下文的）。
    *   实际上，块语句不改变 `ThisBinding`。引擎直接读取 `FooEC.ThisBinding` -> `window`。

3.  **退出块**：`FooEC.LexicalEnvironment` 指针恢复，指回原来的函数 LE。BlockLE 销毁（如果没有闭包引用）。

---

### 第四阶段：箭头函数的 This 绑定

代码继续执行到 `const arrow = () => { ... }`。

1.  **定义时**：
    *   箭头函数被创建。
    *   **关键点**：箭头函数**没有**自己的 `ThisBinding` 机制，也没有 `arguments`。
    *   它会捕获**定义时**所在的执行上下文的 `ThisBinding`。
    *   此时在 `foo` 中，`this` 是 `window`。所以箭头函数内部锁定了 `window`。

2.  **执行时 `arrow()`**：
    *   创建 ArrowEC。
    *   **ThisBinding**: 无。
    *   **查找变量 `this.g_var`**:
        *   代码请求 `this`。
        *   ArrowEC 发现自己是箭头函数，没有 `this`。
        *   去 Lexical Outer (即 `foo` 的环境) 找。
        *   `foo` 的 EC 中 `this` 是 `window`。
        *   最终访问 `window.g_var` -> 输出 `"Global Var"`。

---

### 三、 This 指针绑定的四种底层规则

在 EC 创建阶段，`ThisBinding` 的值是如何被决定的？这取决于函数调用位置的语法格式（Reference Type）。

#### 1. 默认绑定 (Function Invocation)
```javascript
function demo() { console.log(this); }
demo(); 
```
*   **原理**：`demo` 是一个引用，但没有基对象（Base Value is EnvironmentRecord）。
*   **结果**：非严格模式 `window`，严格模式 `undefined`。

#### 2. 隐式绑定 (Method Invocation)
```javascript
var obj = { 
    name: 'obj',
    demo: function() { console.log(this.name); }
};
obj.demo();
```
*   **原理**：调用表达式是 `obj.demo`。
*   **Reference Record**：
    *   Base Value: `obj`
    *   Referenced Name: `demo`
*   **规则**：当函数被调用时，如果 Base Value 是一个对象，`ThisBinding` 设置为 Base Value。
*   **结果**：`this` -> `obj`。

#### 3. 显式绑定 (Call/Apply/Bind)
```javascript
demo.call({name: 'new'});
```
*   **原理**：内置方法强制指定 `ThisBinding`。
*   **结果**：`this` -> `{name: 'new'}`。

#### 4. 关键字 new 绑定
```javascript
new demo();
```
*   **原理**：
    1.  创建一个继承 `demo.prototype` 的新对象。
    2.  将该新对象绑定到 EC 的 `ThisBinding`。
*   **结果**：`this` -> 新实例。

---

### 四、 复杂示例：闭包与环境链 (The Closure Chain)

这个例子展示闭包如何通过 OuterEnvReference 活着。

```javascript
function makeCounter() {
    let count = 0; // 存在 makeCounter 的 LE 中
    
    return function() {
        count++; // 引用上层的 LE
        console.log(count);
    };
}

const counter = makeCounter();
counter(); // 1
counter(); // 2
```

**底层原理：**

1.  `makeCounter` 执行完毕，正常情况下其 EC 会出栈，LE 会被垃圾回收。
2.  但是，返回值是一个**匿名函数**。
3.  该匿名函数创建时，其 `[[Environment]]` 内部属性（即 OuterRef）指向了 `makeCounter` 的 LE。
4.  因为 `counter` 变量持有该匿名函数，所以**匿名函数活着**。
5.  因为匿名函数活着，且引用了 `makeCounter` 的 LE，所以 **`makeCounter` 的 LE 也被迫活着**（无法被 GC）。
6.  这就是**闭包**的本质：**一个保留了父级词法环境引用的函数**。

---

### 总结：回答你的核心疑问

1.  **Global EC 如何生成？**
    *   浏览器启动 -> 创建单例 Global EC -> 初始化 Window 为 Global Object -> 扫描脚本填充 VE/LE。
2.  **变量环境 vs 词法环境？**
    *   VE 管 `var`/function（提升机制）。
    *   LE 管 `let`/`const`（块级作用域、TDZ）。
    *   运行时进入 Block 会创建新的 LE 链在前面，VE 保持不变。
3.  **This 如何绑定？**
    *   在 **创建阶段** 确定。
    *   普通函数：看调用点的 Base Value（谁点的）。
    *   箭头函数：不绑定，直接沿作用域链向上找最近的 `this`。

这套 ES6+ 的模型虽然复杂，但它完美解释了 TDZ、块级作用域、箭头函数和闭包的所有行为。


这是一个非常好的“为什么”的问题。要理解这一点，我们需要从**语言设计的目的**和**数据安全性**的角度来思考，而不仅仅是死记硬背规范。

根本原因可以总结为一句话：**为了保护传入的参数值不被“空值”覆盖。**

我们可以通过三个维度来深度解析这个设计逻辑：

### 1. 逻辑维度：`var` 的语义是“声明”而非“重置”

在 JavaScript 引擎的预编译阶段（创建 AO/ER），`var a` 的含义是：
> “我声明在这个作用域里有一个叫 `a` 的变量。”

引擎的处理逻辑是这样的：
1.  **检查**：当前环境记录（ER）里有没有叫 `a` 的变量？
2.  **如果没有**：创建一个新的，并初始化为 `undefined`。
3.  **如果有**：**什么都不做**。

**为什么“如果有”就什么都不做？**
因为参数（Parameters）的处理优先级高于 `var`。
*   参数处理在先，已经给 `age` 赋值为 `18` 了。
*   轮到处理 `var age` 时，引擎发现 `age` 已经存在了。
*   如果此时引擎强行把 `age` 重置为 `undefined`，那么**函数传参就失去了意义**。

**举个反例（如果 JS 设计得不合理）：**
```javascript
// 假设 JS 设计得很蠢：
function test(val) {
    // 假设预编译阶段 var 把 val 变成了 undefined
    var val; 
    
    // 那么用户还没开始写逻辑，参数就丢了！
    console.log(val); // 如果输出 undefined，这门语言就没法用了
}
test(100);
```
为了避免这种情况，规范明确规定：**`var` 声明永远不会覆盖已经存在的参数绑定。**

---

### 2. 对比维度：为什么 `function` 声明却可以覆盖？

你可能会问：*“那为什么 `function age() {}` 就可以覆盖参数 `age` 呢？这不也丢失了参数吗？”*

这是因为 **权重（Payload）** 不同。

*   **`var age` (变量声明)**：
    *   它在提升阶段携带的值是 **`undefined`**（空值）。
    *   用一个空值去覆盖一个有意义的实参（18），是**降级**，是数据丢失。
    *   **结论**：不覆盖。

*   **`function age() {}` (函数声明)**：
    *   它在提升阶段携带的值是 **具体的函数体对象**。
    *   开发者显式地写了一个函数叫 `age`，说明开发者**明确意图**要用这个函数来作为 `age` 的值，而不是用传入的参数。
    *   用一个具体的对象去覆盖实参，是**更新**，是开发者的明确指令。
    *   **结论**：覆盖。

---

### 3. 规范算法维度 (Spec Algorithm)

让我们看一眼 ECMA-262 规范中 `FunctionDeclarationInstantiation` (FDI) 算法的伪代码逻辑（简化版）：

```text
算法 FDI(func, argumentsList):

1. env = 创建环境记录()
2. // 第一步：处理参数
   For each parameter 'arg' in func:
       env.CreateBinding('arg')
       env.SetBindingValue('arg', argumentsList[i]) // age = 18

3. // 第二步：处理函数声明
   For each function declaration 'f':
       env.SetBindingValue('f', <function object>) // 这里的 Set 会强行覆盖！

4. // 第三步：处理 Var 声明
   For each var declaration 'v':
       If (env.HasBinding('v') === false) {
           // 只有在没绑定过的时候，才创建并初始化为 undefined
           env.CreateBinding('v')
           env.InitializeBinding('v', undefined)
       } 
       // Else {
       //    关键点：如果已经有了（比如参数），这里直接跳过！
       //    根本不执行 SetBindingValue('v', undefined)
       // }
```

### 总结

*   **参数 (Parameters)**：是**客人**，带着礼物（实参 18）先进门入座。
*   **Var 声明**：是**服务员**，拿着空盘子（undefined）进门。一看客人已经坐在那了，服务员就撤了，不会把客人的礼物扔了换成空盘子。
*   **Function 声明**：是**大老板**，带着更重要的文件（函数体）进门。老板来了，客人（参数）就得让位。

这个设计保证了**数据优先**：我们保留最有价值的数据（实参 > 函数体 > undefined）。
<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-execution-context-stack)