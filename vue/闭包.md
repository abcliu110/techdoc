<div id="chap-closure"></div>

[⬆️ 返回目录](#catalog)


## 闭包

要深入理解 JavaScript **闭包（Closure）的实现原理**，不能仅仅停留在“函数内部返回函数”这种表象上，必须深入到 **JS 引擎（如 V8）的内存管理**、**作用域链**和**执行上下文**层面。

以下是从底层原理到实际表现的深度解析。

---

### 一、 核心定义：什么是闭包？

从计算机科学的角度（根据 ECMA-262 规范）：
> **闭包 = 函数 + 该函数声明时所在的词法环境（Lexical Environment）。**

简单来说，当一个函数能够**记住并访问**它所在的词法作用域（Lexical Scope），即使该函数在当前作用域之外执行，这就产生了闭包。

---

### 二、 底层实现原理：三大支柱

闭包的实现依赖于 JS 引擎的三个核心机制：**词法作用域**、**作用域链** 和 **堆内存分配**。

#### 1. 词法作用域（Lexical Scoping）
*   **静态性**：JS 采用的是词法作用域。这意味着变量的作用域**在代码写好时就已经确定了**，而不是在代码执行时确定的。
*   **原理**：无论函数在哪里被调用，它查找变量的规则始终依据它**定义时**的位置。

#### 2. 内部属性 `[[Environment]]`
在 JS 引擎内部，每个函数在创建时，都会生成一个内部属性（通常称为 `[[Environment]]` 或 `[[Scope]]`）。
*   这个属性**保存了该函数被创建时所在的父级词法环境的引用**。
*   这就是“记忆”的物理载体。

#### 3. 内存管理：栈（Stack） vs 堆（Heap）—— **这是闭包实现的关键**
这是理解闭包“为什么变量不会被销毁”的核心：

*   **普通情况（无闭包）**：
    函数执行时，局部变量存储在**调用栈（Call Stack）**中。当函数执行完毕，栈帧（Stack Frame）弹出，局部变量随之被销毁（垃圾回收）。

*   **闭包情况**：
    当 JS 引擎（如 V8）在编译阶段发现一个内部函数引用了外部函数的变量时：
    1.  引擎不会把这些变量仅仅放在栈上。
    2.  引擎会在**堆内存（Heap）**中创建一个专门的**对象（Closure Object / Context）**。
    3.  在这个堆对象中存储被引用的变量。
    4.  内部函数持有一个指向这个堆对象的引用。
    5.  即使外部函数执行结束，栈帧弹出，但因为堆中的对象被内部函数引用着，所以**垃圾回收器（GC）不会回收它**。

---

### 三、 详细执行流程图解

让我们通过代码来看引擎内部发生了什么：

```javascript
function outer() {
    let a = 10;          // 局部变量
    let b = 20;          // 局部变量（未被内部引用）
    
    function inner() {   // 内部函数定义
        console.log(a);  // 引用了外部变量 a
    }
    
    return inner;
}

const fn = outer();      // 1. outer 执行
fn();                    // 2. inner 在外部被调用，输出 10
```

#### 引擎内部执行步骤：

1.  **预编译阶段**：
    *   V8 扫描 `outer` 函数，发现 `inner` 函数引用了 `a`。
    *   V8 将 `a` 标记为“被捕获变量”，在**堆内存**中为 `outer` 创建一个 `Closure(outer)` 对象（或者叫 Scope Context），将 `a` 存入其中。
    *   变量 `b` 没有被引用，依然留在**栈**上。

2.  **`outer()` 执行**：
    *   `outer` 的执行上下文入栈。
    *   `inner` 函数被创建。**关键点**：`inner` 函数对象上有一个隐藏属性 `[[Environment]]`，它指向堆内存中的 `Closure(outer)` 对象。
    *   `outer` 返回 `inner` 函数。
    *   `outer` 执行完毕，出栈。**注意**：此时栈上的 `b` 被销毁，但堆上的 `Closure(outer)` 因为被 `fn` (即 `inner`) 引用，所以**存活**。

3.  **`fn()` 执行**：
    *   `fn` (即 `inner`) 执行。
    *   代码请求变量 `a`。
    *   引擎先在 `inner` 自己的作用域找，没找到。
    *   引擎顺着 `[[Environment]]` 引用，去堆内存的 `Closure(outer)` 里找，找到了 `10`。

---

### 四、 闭包的具体表现形式

虽然最常见的是“函数返回函数”，但闭包的本质是**持有外部作用域的引用**。以下都是闭包的实现：

1.  **函数作为返回值**（经典模式）：
    ```javascript
    function createAdder(x) {
        return function(y) { return x + y; }
    }
    ```

2.  **函数作为参数传递**（回调函数）：
    ```javascript
    let name = "Node";
    setTimeout(function() {
        console.log(name); // 引用了外部变量，这是闭包
    }, 1000);
    ```

3.  **IIFE（立即执行函数表达式）**（早期的模块化实现）：
    ```javascript
    const Module = (function() {
        let privateVar = "secret"; // 私有变量
        return {
            get: () => privateVar
        };
    })();
    ```

---

### 五、 闭包的优缺点与性能考量

#### 优点
1.  **数据私有化（Encapsulation）**：模拟私有变量，防止全局污染（如 Redux 的 `createStore`，Vue 的 `data`）。
2.  **函数工厂 / 柯里化（Currying）**：生成特定配置的函数。

#### 缺点与风险
1.  **内存泄漏（Memory Leak）**：
    *   **原理**：因为闭包会引用外部作用域的变量，导致这些变量无法被 GC 回收。如果闭包使用不当（例如挂载在全局变量或 DOM 元素上且不清理），内存占用会持续增加。
    *   **解决**：使用完闭包后，将引用闭包的变量置为 `null`（如 `fn = null`），切断引用链，让 GC 回收堆内存。

2.  **性能开销**：
    *   查找变量需要沿着作用域链向上查找，比访问局部变量稍慢（但在现代 V8 优化下，这种差异通常可以忽略不计）。

### 六、 总结

**JS 闭包的实现原理**概括为：
基于**词法作用域**规则，函数在创建时通过内部属性 `[[Environment]]` 绑定了父级环境。当子函数引用了父级变量时，JS 引擎（V8）会将这些变量存储在**堆内存**的 Closure 对象中，而不是栈上，从而使得这些变量的生命周期**长于**父级函数的执行周期。


这是一个非常棒的对比问题。JavaScript 和 Python 都是解释型、支持函数式编程特性的动态语言，它们的**闭包（Closure）**在**核心概念上是高度一致的**，但在**语法表现、作用域规则和底层实现**上存在显著差异。

以下是详细的对比分析：

---

### 一、 核心联系（相同点）

它们在计算机科学层面的定义是一致的：
1.  **基于词法作用域（Lexical Scoping）**：内部函数可以访问外部函数定义的变量。这个访问权限取决于代码**写在哪里**，而不是在哪里执行。
2.  **生命周期延长**：被闭包引用的外部变量，其生命周期会超过外部函数本身的执行期（不会随着外部函数出栈而销毁）。
3.  **First-Class Functions**：函数都是“一等公民”，可以作为返回值、参数传递。

---

### 二、 核心差异（不同点）

#### 1. 变量修改与作用域查找（最大的坑）

这是 JS 和 Python 闭包最直观的区别：**如何在内部函数中“修改”外部变量。**

*   **JavaScript：**
    *   **查找规则**：沿着作用域链（Scope Chain）向上找。
    *   **修改**：直接修改即可。因为 JS 的变量查找是基于引用的，内部函数和外部函数看到的是同一个变量引用。

    ```javascript
    // JavaScript
    function createCounter() {
        let count = 0;
        function increment() {
            count++; // 直接修改，没问题
            console.log(count);
        }
        return increment;
    }
    ```

*   **Python：**
    *   **查找规则**：LEGB 规则（Local -> Enclosing -> Global -> Built-in）。
    *   **修改**：默认情况下，Python 认为**在函数内部赋值的变量是局部变量**。如果你尝试修改外部变量，Python 会在内部创建一个新的同名局部变量，而不是修改外部的。
    *   **解决方案**：必须显式使用 **`nonlocal`** 关键字（Python 3+）声明这是外部嵌套作用域的变量。

    ```python
    # Python
    def create_counter():
        count = 0
        def increment():
            # count += 1  # 报错！UnboundLocalError。Python 认为你在引用一个未初始化的局部变量
            nonlocal count # 必须加上这一行
            count += 1
            print(count)
        return increment
    ```

    > *注：在 Python 2 中没有 `nonlocal`，通常用可变对象（如列表 `count = [0]`）来绕过这个限制，因为修改列表内容不需要赋值操作符 `=`。*

#### 2. 循环中的闭包陷阱（作用域的差异）

两者都有经典的“循环闭包”面试题，但成因略有不同，解法也不同。

*   **JavaScript：**
    *   **问题**：在使用 `var` 时，变量是函数级作用域，循环结束时 `i` 变成了最终值。
    *   **解法**：现在直接用 **`let`**（块级作用域），每次循环都会创建一个新的词法环境，完美解决。

    ```javascript
    // JS: 使用 let 解决
    for (let i = 0; i < 3; i++) {
        setTimeout(() => console.log(i), 100); 
    }
    // 输出: 0, 1, 2
    ```

*   **Python：**
    *   **问题**：Python **没有块级作用域**（Block Scope），只有函数/类/模块作用域。`for` 循环中的变量 `i` 会泄漏到外部函数作用域中，且闭包捕获的是变量的**引用**（延迟绑定）。
    *   **解法**：通常使用**默认参数**（Default Argument）技巧，利用默认参数在函数定义时计算值的特性。

    ```python
    # Python
    fns = []
    for i in range(3):
        # fns.append(lambda: print(i)) # 错误写法，最后都会输出 2
        
        # 正确写法：利用默认参数立即绑定
        fns.append(lambda x=i: print(x)) 

    for f in fns: f()
    # 输出: 0, 1, 2
    ```

#### 3. 底层实现原理

*   **JavaScript (V8 引擎):**
    *   **堆内存 Context**：如前所述，V8 会分析引用，将捕获的变量放入堆内存的一个 Context 对象中。
    *   **Scope Chain**：函数对象内部维护一个指针指向这个 Context。
    *   **惰性**：JS 引擎优化极强，如果一个变量没被内部函数使用，它通常会被 GC 回收（除非 `eval` 这种无法静态分析的情况）。

*   **Python (CPython):**
    *   **`__closure__` 属性**：Python 的函数对象有一个特殊的只读属性 `__closure__`。
    *   **Cell Object**：
        *   当编译器检测到闭包时，会将外部变量存储在一个特殊的 **Cell 对象**中。
        *   外部函数的局部变量表（`locals`）里存的是这个 Cell。
        *   内部函数的 `__closure__` 属性是一个元组，里面也存着指向同一个 Cell 的引用。
        *   当变量被访问时，是通过解包这个 Cell 来获取值的。
    *   **查看方式**：你可以直接打印 `fn.__closure__` 看到这些 Cell 对象。

    ```python
    def outer():
        x = 10
        def inner():
            print(x)
        return inner

    fn = outer()
    print(fn.__closure__) 
    # 输出: (<cell at 0x...: int object at 0x...>,)
    print(fn.__closure__[0].cell_contents) 
    # 输出: 10
    ```

---

### 三、 总结对比表

| 特性 | JavaScript | Python |
| :--- | :--- | :--- |
| **定义方式** | 函数内定义函数 (Function/Arrow) | 函数内定义函数 (`def`/`lambda`) |
| **作用域规则** | 词法作用域 + 块级作用域 (`let/const`) | LEGB 规则 (无块级作用域，只有函数级) |
| **修改外部变量** | **直接修改** (Implicit) | **需要 `nonlocal`** (Explicit) (Python 3+) |
| **循环陷阱解法** | 使用 `let` (推荐) 或 IIFE | 使用默认参数 `lambda x=i: ...` 或 `functools.partial` |
| **底层实现** | 作用域链 + 堆内存 Context 对象 | `__closure__` 属性 + Cell 对象 |
| **内存管理** | 引用计数 + 标记清除 (Mark-Sweep) | 主要是引用计数 + 循环垃圾收集器 |

### 四、 什么时候用？

*   **JavaScript**: 几乎无处不在。模块化模式、回调函数、事件处理、React Hooks、Vue Composition API 全部依赖闭包。
*   **Python**: 相对少见一些。主要用于：
    *   **装饰器 (Decorators)**：这是 Python 闭包最主要的应用场景。
    *   **数据隐藏/工厂模式**：类似 JS，但 Python OOP（类）语法很强，很多时候直接用 Class 更符合 Pythonic 风格。
    *   **延迟计算**。

**一句话总结：**
JS 的闭包更加**自然和常用**，是语言的基石；Python 的闭包语法更**显式和严格**（需要 `nonlocal`），更多作为一种高级编程技巧（如装饰器）出现。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-closure)