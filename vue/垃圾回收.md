<div id="chap-recycle"></div>

[⬆️ 返回目录](#catalog)


## 垃圾回收

当 `<script>` 脚本执行完毕后，里面的对象**不一定会释放**。

这取决于这些对象是否还**“可达”（Reachable）**。

JavaScript 的内存管理依靠**垃圾回收机制（Garbage Collection, GC）**。现代浏览器主要采用**“标记-清除”（Mark-and-Sweep）**算法。简单来说，只要从**根对象（Root，在浏览器中通常是 `window`）**出发，能顺着引用链找到这个对象，它就不会被释放；反之，如果切断了联系，它才会被回收。

以下是详细的情况分析：

### 1. 肯定会被释放的情况
如果对象是在函数内部定义的局部变量，且没有被外部引用，函数执行完后，对象就会被释放。

```javascript
<script>
  (function() {
      // 这是一个局部变量
      let tempObj = { name: "我是临时对象" };
      console.log(tempObj.name);
  })(); 
  // 脚本执行完，IIFE 函数作用域销毁。
  // tempObj 没有任何人引用它了，GC 会在下次运行时将其回收。
</script>
```

### 2. 不会被释放的情况（内存常驻）

即使脚本跑完了，只要对象还在“被引用”，它就会一直占用内存。常见原因如下：

#### A. 全局变量 (Global Variables)
这是最常见的情况。只要挂载在 `window` 下，页面不关闭，对象就不释放。

```javascript
<script>
  // 这是一个全局变量
  var globalObj = { data: "我很重要" };
  
  // 或者直接挂载
  window.myData = new Array(10000);
</script>
// 脚本执行完了，但 globalObj 和 window.myData 依然挂在 window 上。
// 它们被认为是“根”的一部分，不会被回收。
```

#### B. 闭包 (Closures)
如果一个函数内部定义了对象，而这个函数被外部变量引用了（或者是事件回调），那么这个对象会被“闭包”锁住，无法释放。

```javascript
<script>
  function setup() {
      let largeData = { info: "大对象" }; // 本该销毁的局部变量
      
      // 点击事件引用了匿名函数，匿名函数引用了 largeData
      document.getElementById('btn').onclick = function() {
          console.log(largeData.info);
      };
  }
  
  setup(); 
  // setup 执行完了。
  // 但 largeData 不会释放！
  // 因为 btn 的 click 监听器还活着，它持有 largeData 的引用。
</script>
```

#### C. 定时器 (Timers)
如果有未清除的 `setInterval` 或 `setTimeout`，它们引用的对象也不会释放。

```javascript
<script>
  let cache = { ... };
  
  setInterval(function() {
      // 只要定时器还在跑，cache 就不会被回收
      console.log(cache);
  }, 1000);
</script>
```

#### D. DOM 引用
如果你在 JS 中保留了对某个 DOM 元素的引用，即使你从页面上移除了这个 DOM 节点，它依然在内存中。

```javascript
<script>
  let detachedNode = document.getElementById('ad-banner');
  document.body.removeChild(detachedNode); 
  
  // 脚本执行完，页面上也看不到这个元素了。
  // 但是！detachedNode 变量还在引用它。
  // 这个 DOM 节点（以及它包含的所有子节点）依然占用内存。
</script>
```

### 3. 如何判断何时释放？（核心原理）

想象一棵树：
1.  **树根**是 `window`。
2.  脚本执行完后，垃圾回收器会定期从 `window` 出发遍历所有属性。
3.  **活着的对象：** 所有能顺着线连到 `window` 的对象。
4.  **死亡的对象：** 那些孤零零的、已经断开连接的对象（比如刚才那个执行完的函数里的局部变量）。

### 总结

*   **脚本执行完** $\neq$ **内存释放**。
*   脚本只是建立了一堆引用关系。
*   如果对象被赋值给了**全局变量**、**闭包**、**DOM 事件**、**定时器**，它就会一直存在，直到页面关闭或你手动将其赋值为 `null`。
*   只有**纯粹的局部变量**（没有闭包引用），才会在脚本执行完后被自动回收。

你是对的！你的直觉非常敏锐。

**JavaScript (尤其是 V8 引擎) 和 Go (Golang) 的垃圾回收 (GC) 在底层核心理论上确实非常相似**，但在**具体策略**和**侧重点**上有显著不同。

它们最本质的共同点是：**都属于“追踪式垃圾回收”（Tracing GC）**，核心算法都是基于**“标记-清除”（Mark-and-Sweep）**及其变种（三色标记法）。

为了让你更透彻地理解，我们可以把这两者做一个深度的对比：

---

### 1. 核心相似点：三色标记法 (Tricolor Marking)

为了不让程序卡顿（Stop The World, STW），现代的 JS（V8）和 Go 都使用了**并发标记（Concurrent Marking）**。为了实现并发，它们都使用了**三色标记模型**：

*   **白色 (White)**：潜在的垃圾（还未被扫描或确认不可达）。
*   **灰色 (Grey)**：活跃对象，但它的子对象还没扫描完（正在处理中）。
*   **黑色 (Black)**：活跃对象，且它的所有子对象也都扫描完了（安全）。

**流程：** 
GC 开始时所有对象都是白色的 -> 从根节点开始把对象染灰 -> 扫描灰色对象的子节点，把自己染黑，子节点染灰 -> 循环直到没有灰色 -> 清除白色。

**相似之处：** 
两者都使用了**写屏障（Write Barrier）**技术。当 GC 在后台标记时，如果用户代码修改了对象的引用（比如把一个白色对象挂到了黑色对象下），写屏障会拦截这个操作，保证标记的正确性。

---

### 2. 核心不同点：分代假说 (Generational Hypothesis)

这是 JS (V8) 和 Go 最根本的分歧点。

#### JavaScript (V8): **极度依赖分代**
*   **背景**：浏览器环境。用户操作频繁，大量临时对象（比如 UI 渲染产生的中间变量、字符串拼接）**朝生夕死**。
*   **策略**：V8 将堆内存严格分为**新生代 (New Space)** 和 **老生代 (Old Space)**。
    *   **新生代**：使用 **Scavenge 算法 (复制算法)**。内存分为 From 和 To 两块。对象在 From 区，活下来的复制到 To 区，剩下的直接清空。速度极快，但浪费一半空间。
    *   **老生代**：经历过两次 Scavenge 还活着的，晋升到老生代，使用**标记-清除-整理**。

#### Go (Golang): **不分代 (Non-generational)**
*   **背景**：服务器后端。Go 的设计目标是低延迟（Low Latency），且 Go 的编译器有极其强大的**逃逸分析 (Escape Analysis)**。
*   **策略**：Go 的 GC 是**非分代**的并发标记清除。
*   **为什么？** Go 认为在多核 CPU 的服务器上，与其花时间去移动对象（分代通常涉及对象复制和移动），不如利用多核优势并发地进行标记和清除。Go 依靠极其精细的**TCMalloc 内存分配器**来解决内存碎片问题，而不是靠整理内存。

---

### 3. 核心不同点：对象移动 (Compaction/Moving)

#### JavaScript (V8): **移动对象**
*   JS 的对象在内存里的地址是**会变**的。
*   当新生代 GC 或者老生代进行内存整理（Compaction）时，V8 会把活着的对象搬到新的内存位置，并更新所有指向它的指针。
*   **代价**：移动对象时通常需要短暂的 STW（暂停），或者极其复杂的读写屏障。

#### Go: **不移动对象 (Non-moving)**
*   Go 的对象一旦分配，地址在 GC 期间通常**不会变**。
*   **优势**：因为对象不移动，Go 可以非常方便地和 C 语言交互（CGO），也可以方便地使用 `unsafe.Pointer`。
*   **劣势**：可能会产生内存碎片（Go 通过类似 TCMalloc 的多级内存管理缓解了这个问题）。

---

### 4. 触发时机与控制

*   **JavaScript**:
    *   由于运行在单线程（主线程）上，GC 必须非常小心，不能阻塞 UI 渲染。
    *   V8 会利用**空闲时间 (Idle Time)** 进行增量标记。
    *   如果内存压力大，会强制触发。

*   **Go**:
    *   Go 运行在多线程（Goroutines）环境。
    *   主要通过 `GOGC` 环境变量控制（默认 100）。即当堆内存增长到上次 GC 后的 100%（翻倍）时，触发下一次 GC。
    *   Go 还有一个后台监控（Pacer），定期强制 GC（默认 2 分钟）。

---

### 总结对比表

| 特性 | JavaScript (V8) | Go (Golang 1.5+) |
| :--- | :--- | :--- |
| **基础算法** | 追踪式 / 标记-清除 | 追踪式 / 标记-清除 |
| **分代 (Generational)** | **是 (核心策略)**。新生代用复制，老生代用整理。 | **否**。无分代（有一些优化假设，但没有物理分代）。 |
| **对象移动** | **会移动**。为了减少碎片和快速分配。 | **不移动**。地址固定，依赖分配器管理碎片。 |
| **逃逸分析** | 有，但因为 JS 动态特性，很多对象必须上堆。 | **极强**。很多在 JS 里必须上堆的对象，在 Go 里可以直接分配在栈上（栈内存随函数自动销毁，不需要 GC）。 |
| **并发性** | 增量/并发标记，但在主线程清理时仍可能有微小停顿。 | 高度并发，极短的 STW（亚毫秒级）。 |
| **主要目标** | 优化 UI 响应，快速回收临时变量。 | 优化服务端的低延迟（Low Latency）。 |

### 一句话概括
你觉得像，是因为它们都在**“画图找人”**（从根节点遍历引用图，三色标记）；
但这两人清理房间的方式不同：**JS 喜欢把活人搬到新房间，旧房间一把火烧了（复制/分代）；Go 喜欢就在原房间里，悄悄把垃圾捡走（不移动/不分代）。**

这是一个非常棒的问题。如果把 **JavaScript (V8)** 比作灵巧的**短跑运动员**（注重 UI 响应），**Go** 比作极低延迟的**实时系统**（注重极短的停顿），那么 **Java** 就是一个**重装甲多面手**（历史悠久，策略多变，注重高吞吐量）。

Java 是垃圾回收领域的“集大成者”，它的 GC 演进史几乎就是 GC 技术的发展史。

我们将从**共性（联系）**和**个性（区别）**两个维度，把这三者放在一起对比。

---

### 一、 三者的联系 (Common Ground)

无论语言怎么变，这三者在 GC 的底层理论上是**同宗同源**的：

1.  **宏观算法一致：**
    *   都是**追踪式 GC (Tracing GC)**。
    *   都依赖**可达性分析 (Reachability Analysis)**：从 GC Roots（全局变量、栈变量、寄存器等）出发，顺藤摸瓜找活对象。
    *   都无法解决“逻辑泄露”（即对象不再需要但引用还在）。

2.  **微观技术共享：**
    *   **三色标记法**：为了支持并发（不暂停程序），三者在标记阶段都使用了三色标记模型（黑/灰/白）。
    *   **写屏障 (Write Barrier)**：为了保证并发标记的准确性，三者都使用了某种形式的写屏障技术。

---

### 二、 三者的核心区别 (Differences)

我们将从**分代假说**、**内存整理**、**设计目标**三个维度进行“三国杀”。

#### 1. 分代假说 (Generational Hypothesis)

> *理论：绝大多数对象都是“朝生夕死”的。*

*   **Java:** **分代的绝对拥护者**。
    *   Java 堆被严格划分为 **Young Gen (Eden + Survivor)** 和 **Old Gen**。
    *   **策略**：年轻代用“复制算法”（和 V8 的 Scavenge 几乎一样），老年代用“标记-整理”或“标记-清除”。
    *   **原因**：Java 企业级应用会产生海量临时对象，分代能极大地提升效率。
*   **JavaScript (V8):** **分代的拥护者**。
    *   和 Java 非常像，分为 **New Space** (Scavenge) 和 **Old Space**。
    *   **原因**：浏览器里全是临时的小对象，分代是必须的。
*   **Go:** **反其道而行之（不分代）**。
    *   Go 的 GC 是**不分代**的（虽然编译器会有一些静态分析优化）。
    *   **原因**：Go 依赖强大的**逃逸分析**，很多临时对象直接在栈上分配，函数结束就销毁了，根本不需要 GC 插手。剩下的堆对象通常生命周期较长，分代的收益在 Go 里不如在 Java 里那么大。

#### 2. 内存整理 (Compaction / Moving Objects)

> *问题：回收后要不要把剩下的对象排排队，挤在一起？*

*   **Java:** **必须整理（搬家）**。
    *   Java 的对象在内存中会移动（除了最新的 ZGC 某些阶段）。
    *   **优点**：解决了内存碎片问题，分配新对象极快（指针碰撞，Bump Pointer）。
    *   **代价**：移动对象需要 STW（暂停）或者极复杂的屏障。
*   **JavaScript (V8):** **混合策略**。
    *   新生代（New Space）总是移动（复制算法）。
    *   老生代（Old Space）主要用清除，内存碎片多了才会触发整理（Mark-Sweep-Compact）。
*   **Go:** **不整理（不搬家）**。
    *   Go 的对象地址固定。
    *   **优点**：并发性能好，且方便与 C 语言交互（CGO）。
    *   **缺点**：会有内存碎片。
    *   **解决**：Go 使用了类似 TCMalloc 的分配器（多级缓存、按大小分类），极力减少碎片的负面影响。

#### 3. 可插拔性与演进 (Evolution)

这是 Java 与其他两者最大的不同。

*   **JavaScript (V8):** 没得选，浏览器给你啥就是啥（虽然一直在进化）。
*   **Go:** 没得选，官方给你调优好了单一的 GC 算法（目标就是低延迟）。
*   **Java:** **超市自选模式**。Java 提供了多种 GC 收集器，你可以根据业务场景切换：
    *   *Serial GC:* 单线程，适合小内存。
    *   *Parallel GC:* **吞吐量优先**（后台计算任务）。
    *   *CMS:* **响应时间优先**（Web 服务器，已过时）。
    *   *G1 (Garbage-First):* **平衡型**（JDK 9+ 默认），把堆切成很多小块（Region），不再物理分代，而是逻辑分代。
    *   *ZGC / Shenandoah:* **极低延迟**（JDK 15+），号称暂停时间不超过 10ms，甚至 1ms。**注意：ZGC 的设计理念开始变得像 Go（并发标记、并发整理），但也保留了分代（最新版 ZGC）**。

---

### 三、 总结对比表

| 维度 | **Java** | **JavaScript (V8)** | **Go** |
| :--- | :--- | :--- | :--- |
| **核心策略** | **高度分代** (Young/Old) | **分代** (New/Old) | **不分代** (Flat Heap) |
| **对象移动** | **会移动** (整理内存，消除碎片) | **会移动** (新生代复制，老生代按需整理) | **不移动** (地址固定) |
| **碎片处理** | 靠整理 (Compaction) | 靠复制/整理 | 靠精细的内存分配器 (TCMalloc) |
| **逃逸分析** | 有 (HotSpot)，但不如 Go 激进 | 较弱 (动态语言限制) | **极强** (大量对象栈上分配) |
| **并发能力** | 极强 (多线程并发 GC) | 较弱 (受限于单线程主循环，利用空闲时间) | 极强 (与 Goroutine 并发运行) |
| **主要目标** | **吞吐量** (旧) -> **低延迟** (新 ZGC) | **UI 流畅度** (避免掉帧) | **极低延迟** (服务不卡顿) |
| **可配置性** | **极高** (G1, ZGC, Parallel 等多种可选) | 低 (引擎内部写死) | 低 (仅 GOGC 一个参数) |

### 四、 形象比喻

如果把**内存管理**比作**打扫房间**：

1.  **JavaScript (V8)** 像是一个**住家保姆**。
    *   因为房间里（主线程）一直有人在工作，保姆不敢大张旗鼓地打扫。
    *   她趁着主人发呆（Idle Time）的时候，赶紧扫两下。
    *   她把房间分为“杂物区”（新生代）和“储藏室”（老生代），杂物区的东西扔得特别快。

2.  **Go** 像是一个**隐形清洁队**。
    *   不管主人在干嘛，清洁队都在旁边悄悄干活（并发）。
    *   为了不打扰主人，他们**绝对不移动家具**（不移动对象）。
    *   虽然家具摆放可能有点乱（碎片），但他们很会利用空隙塞东西。
    *   他们能一眼看出哪些垃圾不需要带出门，直接就地销毁（强大的栈分配/逃逸分析）。

3.  **Java** 像是一个**专业的家政公司**。
    *   它提供多种套餐：
    *   **套餐A (Parallel):** “主人请出去一下，我喊一堆人把房间彻底翻新，马上就好。”（高吞吐，有 STW）。
    *   **套餐B (G1):** “我不全屋打扫，我把房间划成小格子，哪里最脏我先扫哪里。”
    *   **套餐C (ZGC):** 也是隐形清洁队，但它技术更牛，它一边打扫甚至一边帮你**移动家具**（并发整理），而且你几乎感觉不到。
    *   
<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-recycle)