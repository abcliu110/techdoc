<div id="chap-deconstruction"></div>

[⬆️ 返回目录](#catalog)


## ES6协议-解构

ES6 的解构赋值（Destructuring Assignment）本质上是一种**“模式匹配”**的**语法糖**。

虽然写起来很简洁，但浏览器或 Node.js 在底层执行时，其实是把它拆解成了**普通的变量定义**和**属性/方法访问**操作。

要理解它的原理，我们需要分**数组解构**和**对象解构**两种情况来看，因为它们的底层机制完全不同。

---

### 一、 数组解构的原理：迭代器 (Iterator)

**核心原理：** 数组解构**不是**通过下标（Index）简单访问的，而是基于 **迭代器协议 (Iterator Protocol)**。

这就是为什么不仅数组可以解构，`Set`、`Map` 甚至 `String` 都可以使用数组解构语法的原因——只要这个对象部署了 `[Symbol.iterator]` 接口。

#### 1. 表面语法
```javascript
const [a, b] = [10, 20];
```

#### 2. 底层还原 (ES5 伪代码)
引擎实际上做的事情类似于下面这样：

```javascript
// 1. 获取右边对象的迭代器
const rawData = [10, 20];
const iterator = rawData[Symbol.iterator](); // 获取迭代器对象

// 2. 手动调用 next() 遍历
const step1 = iterator.next(); // { value: 10, done: false }
const step2 = iterator.next(); // { value: 20, done: false }

// 3. 赋值
var a = step1.value;
var b = step2.value;
```

#### 3. 证明
如果你尝试解构一个没有 Iterator 接口的对象，就会报错：
```javascript
const [x] = {}; 
// TypeError: {} is not iterable
// 因为普通对象没有 Symbol.iterator
```

---

### 二、 对象解构的原理：属性查找

**核心原理：** 对象解构比较直接，它基于 **Hash 映射查找（Key Matching）**。它不关心顺序，只关心属性名。

#### 1. 表面语法
```javascript
const { name, age } = { name: 'Vue', age: 3, job: 'Dev' };
```

#### 2. 底层还原 (ES5 伪代码)
Babel 把这段代码编译成 ES5 时，逻辑非常简单粗暴：

```javascript
var _temp = { name: 'Vue', age: 3, job: 'Dev' };

// 1. 验证右侧不是 null 或 undefined (否则报错)
if (_temp === null || _temp === undefined) {
  throw new TypeError("Cannot destructure 'undefined' or 'null'.");
}

// 2. 通过 key 访问属性并赋值
var name = _temp.name;
var age = _temp.age;
```

#### 3. 别名与嵌套
如果是更复杂的写法：
```javascript
const { name: myName } = user;
```
原理就是：
```javascript
var myName = user.name;
```

---

### 三、 默认值的原理

解构赋值允许设置默认值，它的判定标准非常严格：**全等于 `undefined`**。

#### 1. 表面语法
```javascript
const { x = 100 } = { x: null };
```

#### 2. 底层原理
引擎在赋值前会做一个判断：

```javascript
var _temp = { x: null };
var _value = _temp.x;

// 只有当值严格等于 undefined 时，才使用默认值
// 这里的 _value 是 null，不等于 undefined，所以 x 最终是 null
var x = _value === undefined ? 100 : _value; 
```

这就是为什么 `{ x: null }` 解构出来 `x` 是 `null` 而不是 `100` 的原因。

---

### 四、 剩余运算符 (...rest) 的原理

我们经常这样用：`const { a, ...others } = obj;`

这在底层其实是最消耗性能的操作之一。

**原理：**
1.  先提取出明确指定的属性（如 `a`）。
2.  创建一个新对象 `others`。
3.  遍历原对象 `obj` 的所有**可枚举属性**。
4.  如果该属性**不在**已提取的列表中（排除 `a`），则把它**浅拷贝**到 `others` 中。

这也是为什么 `...rest` 只能放在最后的原因，因为引擎需要先知道你“拿走了什么”，才能计算“剩下了什么”。

---

### 总结

1.  **数组解构**：本质是调用 **`iterator.next()`**，依次取出值进行赋值。
2.  **对象解构**：本质是 **`variable = object.key`** 的简写。
3.  **默认值**：本质是 **`value === undefined ? default : value`** 的三元运算。
4.  **Babel 编译**：如果你想看最真实的原理，可以在 Babel 官网试一下转码，你会发现解构赋值最终都变成了一堆中间临时变量的赋值语句。



<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-deconstruction)