<div id="chap-protocol"></div>

[⬆️ 返回目录](#catalog)


## 协议

在 JavaScript 中，“协议”（Protocol）这个词并不像在 Java 或 Swift 中那样指代一个严格的 `interface` 关键字。

在 JS 中，协议更像是一种 **“君子协定” (Duck Typing / 鸭子类型)**。
**定义：** “只要你的对象拥有特定的方法或属性（签名），引擎就会按照特定的规则去处理你。”

除了之前提到的 **迭代器协议 (Iterator Protocol)**，JS 中还有几个非常底层且重要的协议。理解它们能让你看懂很多“黑魔法”。

---

### 1. Thenable 协议 (Promise 互操作协议)

这是处理异步编程的核心协议。你是否好奇过，为什么 `await` 可以等待一个并非由 `new Promise` 创建的对象？或者为什么 `axios` 的返回值可以直接被 `await`？

**原理：**
JS 引擎在处理 `await` 或 `Promise.resolve()` 时，并不检查对象是不是 `Promise` 类的实例。它只检查：**这个对象有没有一个叫 `then` 的方法？**

如果有，它就被称为 **Thenable 对象**。

**底层逻辑：**
1.  引擎拿到对象 `obj`。
2.  检查 `typeof obj.then === 'function'`。
3.  如果是，引擎就会像处理标准 Promise 一样，调用 `obj.then(resolve, reject)`，并暂停执行，直到 `resolve` 被调用。

**代码演示：**
```javascript
// 这只是一个普通对象，不是 Promise 实例
const plainObject = {
  then(resolve, reject) {
    console.log("引擎发现我有 then 方法，就把我当 Promise 处理了");
    setTimeout(() => {
      resolve("成功！");
    }, 2000);
  }
};

// 验证
(async () => {
  console.log("开始等待...");
  const result = await plainObject; // 竟然可以 await 一个普通对象！
  console.log(result); // 输出: "成功！"
})();
```

**应用场景：**
*   Vue 的 `nextTick` 返回的就是一个 Thenable。
*   为了兼容早期的异步库（如 jQuery 的 Deferred 或 Bluebird）。

---

### 2. 对象原始值转换协议 (ToPrimitive Protocol)

这是导致 JS 面试题中各种奇葩“隐式类型转换”的罪魁祸首。
比如：`[] + []`，`{} + 1`，`obj == 1`。

**原理：**
当一个对象参与数学运算或字符串拼接时，引擎需要把它转成基本类型（Primitive）。引擎会按照特定顺序查找对象上的方法：

1.  **`Symbol.toPrimitive(hint)`** (ES6 新增，优先级最高)
2.  **`valueOf()`**
3.  **`toString()`**

**底层逻辑：**
引擎会根据场景传入一个 `hint`（提示）：
*   `number` (例如数学运算 `obj * 2`)
*   `string` (例如 `alert(obj)`)
*   `default` (例如 `obj + 1`，可能是连接也可能是加法)

**代码演示（自定义转换逻辑）：**

```javascript
const money = {
  value: 100,
  
  // 拦截类型转换
  [Symbol.toPrimitive](hint) {
    console.log(`当前场景 hint 是: ${hint}`);
    
    if (hint === 'string') {
      return `${this.value}元`;
    }
    if (hint === 'number') {
      return this.value;
    }
    return this.value; // default
  }
};

console.log(String(money)); // hint: string -> 输出 "100元"
console.log(money * 2);     // hint: number -> 输出 200
console.log(money + 10);    // hint: default -> 输出 110
```

---

### 3. 属性描述符协议 (Property Descriptor Protocol)

这是 `Object.defineProperty` 的基础，也是 **Vue 2 响应式原理** 的核心。

**原理：**
在 JS 引擎眼中，对象的属性不仅仅是 `key: value`。每个属性其实是一个“记录（Record）”，包含一组 **Attributes（特性）**。

协议规定属性分为两种描述符：
1.  **数据描述符 (Data Descriptor)**: 有 `value`, `writable`。
2.  **存取描述符 (Accessor Descriptor)**: 有 `get`, `set`。

**底层逻辑：**
当你写 `obj.a = 1` 时，引擎会：
1.  检查属性 `a` 的描述符。
2.  如果是**数据描述符**且 `writable: false`，则忽略赋值（严格模式报错）。
3.  如果是**存取描述符**，则不直接存储值，而是调用 `set` 函数。

**代码演示：**

```javascript
const obj = {};

Object.defineProperty(obj, 'secret', {
  // 使得属性不可枚举（for...in 读不到）
  enumerable: false, 
  // 使得属性不可修改
  writable: false,
  value: 123
});

obj.secret = 456; // 失败，不会报错但改不掉
console.log(obj.secret); // 123
console.log(Object.keys(obj)); // [] (因为 enumerable: false)
```

---

### 4. 键相等协议 (Keyed Collections Equality)

这是 `Map`, `Set` 和普通对象（Object）在键名判断上的区别。

**原理：**
*   **普通 Object**：键名自动转字符串。`obj[1]` 和 `obj["1"]` 是同一个属性。
*   **Map / Set**：使用 **SameValueZero** 算法。

**SameValueZero 算法特点：**
它是 `===` 的改良版。
1.  `NaN` 等于 `NaN` (虽然在 JS 里 `NaN === NaN` 是 false，但在 Map 里它们是同一个键)。
2.  `+0` 等于 `-0`。
3.  对象必须引用地址相同才算相等。

**代码演示：**

```javascript
const map = new Map();
const key1 = NaN;
const key2 = NaN;

map.set(key1, "我是第一个NaN");
map.set(key2, "我是第二个NaN"); // 覆盖前者，因为 Map 协议认为 NaN 等于 NaN

console.log(map.size); // 1
console.log(map.get(NaN)); // "我是第二个NaN"

// 对比普通对象
const obj = {};
obj[key1] = "Obj NaN"; // 实际上键名变成了字符串 "NaN"
```

---

### 5. 代理内部方法协议 (Proxy Internal Methods)

这是 JS 中最底层的“元编程”协议。它是 **Vue 3 响应式原理** 的基础。

**原理：**
JS 里的每一个对象操作（读、写、删除、遍历、函数调用等），在底层都对应一个 **“内部方法 (Internal Method)”**。
ES6 的 `Proxy` 允许你拦截这些内部方法。

协议规定了 13 种可以被拦截的行为（Traps）：

*   `[[Get]]` -> `get`
*   `[[Set]]` -> `set`
*   `[[Apply]]` -> `apply` (函数调用)
*   `[[Construct]]` -> `construct` (new 操作)
*   ...等等

**重要性：**
这也是一种协议，规定了：“如果你通过 Proxy 拦截了 `get` 操作，那么当用户访问属性时，我（引擎）就不去读内存了，而是直接运行你的 `get` 函数”。

---

### 总结

JavaScript 的世界里充满了这些“隐形契约”。理解它们，你就能理解为什么库和框架能做到那些看起来很神奇的事情：

1.  **Iterator 协议**：让 `for...of` 和 `...` 能工作。
2.  **Thenable 协议**：让各种异步库能互相 `await`。
3.  **ToPrimitive 协议**：控制对象如何变成数字或字符串。
4.  **Descriptor 协议**：控制属性是否只读、是否可枚举（Vue 2 基础）。
5.  **Proxy 协议**：拦截对象的底层基本操作（Vue 3 基础）。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-protocol)