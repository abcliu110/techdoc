<div id="chap-prototype"></div>

[⬆️ 返回目录](#catalog)


## 原型
这是一个非常经典的 JavaScript 语言设计问题。

要理解“为什么函数可以被 new”，我们需要回到 1995 年 JavaScript 诞生的那一刻。这背后的设计理念是：**“市场营销的妥协”** 与 **“函数式编程的内核”** 的奇怪结合。

### 核心答案

JavaScript 之所以允许 `new` 一个函数，是因为在 JS 的设计理念中，**没有真正的“类”（Class）**（至少在 ES6 之前）。

JS 采用的是 **基于原型（Prototypal）** 的面向对象系统，而不是 **基于类（Class-based）** 的系统。为了让熟悉 Java 的程序员能看懂这门语言，设计者（Brendan Eich）强行把函数的调用方式包装成了像 Java 类一样的构造过程。

---

### 一、 历史背景：为了像 Java (The Java Trap)

1995 年，Netscape 公司开发 JavaScript 时，接到的命令是：**“这门语言必须看起来像 Java，因为 Java 现在很火。”**

*   **Java 的方式**：先定义 `class`，然后 `new ClassName()`。
*   **JS 的内核**：参考了 Scheme（函数式语言）和 Self（原型语言）。在这些语言里，根本没有“类”的概念，只有对象和函数。

**矛盾出现了**：内核里没有类，但语法必须像类。
**解决方案**：**让函数（Function）身兼多职。**

于是，JS 里的函数变成了“变色龙”：
1.  **普通调用** `fn()`：它就是一个过程。
2.  **构造调用** `new fn()`：它就摇身一变，假装自己是一个“类构造器”。

---

### 二、 技术原理：`new` 到底对函数做了什么？

当你对一个函数使用 `new` 关键字时，JavaScript 引擎并没有把这个函数当成函数跑，而是把它当成一个**“生产车间”**。

`new User('Vue')` 这一行代码，在底层发生了 **4 步魔法操作**：

1.  **创建空对象**：在内存中创建一个全新的空对象 `{}`。
2.  **链接原型**：把这个新对象的 `[[Prototype]]`（即 `__proto__`）指向函数的 `prototype` 属性。
    *   *这步实现了继承：新对象能访问函数原型上的方法。*
3.  **绑定 this**：将函数内部的 `this` 强行指向这个新创建的对象。
    *   *所以 `this.name = 'Vue'` 才会生效，把属性挂在新对象上。*
4.  **返回对象**：如果函数没有手动返回对象，引擎自动返回这个新创建的对象。

**代码演示：**

```javascript
function Dog(name) {
  this.name = name;
}

// 当你写 const d = new Dog('旺财') 时
// 浏览器底层其实在做类似这样的事情：

function myNew(Constructor, ...args) {
  // 1. 创建新对象
  const obj = {};
  
  // 2. 链接原型 (让 obj 能找到 Dog.prototype 里的东西)
  Object.setPrototypeOf(obj, Constructor.prototype);
  
  // 3. 绑定 this 并执行函数 (把属性挂载到 obj 上)
  const result = Constructor.apply(obj, args);
  
  // 4. 返回结果
  // (如果构造函数自己返回了对象，就用它的；否则用我们刚创建的 obj)
  return result instanceof Object ? result : obj;
}
```

---

### 三、 设计理念：函数的一等公民地位

JS 的设计哲学是 **“函数是一等公民” (First-class Function)**。这意味着函数不仅仅是代码块，它是一个对象，它可以拥有属性，可以作为参数，也可以作为构造器。

#### 1. 复用性（经济原则）
在 C++ 或 Java 中，`class` 是模具，`method` 是行为，分得很清。
在 JS 中，设计者认为：**没必要引入一个新的复杂概念（类）。函数已经足够强大了。**
*   只要给函数加上 `new`，它就能生产对象。
*   只要不加 `new`，它就是普通逻辑。
*   **一物两用**，节省了语言设计的复杂度（虽然增加了学习者的认知负担）。

#### 2. 原型继承的自然表达
JS 的世界观里，对象是生出来的，不是模具刻出来的。
*   **Java**：上帝画图纸（Class），然后批量造人。
*   **JavaScript**：先有一个亚当（Function.prototype），然后克隆出夏娃（Instance），夏娃基于亚当修改基因。

函数在这里充当了 **“初始化逻辑的容器”**。因为没有类，我们需要一个地方来写“当对象创建时通过什么逻辑初始化属性”，函数体就是最好的地方。

---

### 四、 为什么 ES6 又出了 `class`？

既然 `function` 这么好用，为什么 ES6 还要加 `class` 关键字？

因为 **“函数即构造器”** 的设计有两个大坑：

1.  **语义模糊**：光看代码 `function User() {}`，你不知道它是一个用来 `new` 的类，还是一个用来执行的普通函数。通常只能靠**首字母大写**这种“君子协定”来区分。
2.  **`this` 的混乱**：如果原本该 `new` 的函数，你忘了写 `new` 直接调用了（`User()`），`this` 就会指向全局 `window`，导致污染全局变量。

**ES6 的 `class` 本质上还是语法糖：**
ES6 的 `class User {}` 底层依然是转化为一个构造函数。但它加了**安全限制**：如果你不加 `new` 直接调用 `class`，JS 引擎会直接报错，从而修复了旧设计的缺陷。

### 总结

JS 允许 `new` 一个函数，是因为：

1.  **历史包袱**：为了迎合 Java 程序员的习惯，把函数伪装成类。
2.  **底层机制**：JS 没有类，只有对象。函数被借用作为“对象工厂”和“初始化脚本”。
3.  **核心哲学**：利用**原型链**和**this 绑定**，强行赋予了函数“生孩子”的能力。

你可以把这个设计理解为：**一把瑞士军刀。**
普通函数是用来切菜的（执行逻辑），但如果你按住某个特殊的按钮（`new`），它就变成了一把螺丝刀（构造对象）。虽然看起来有点怪，但它在当年用最少的代码量实现了面向对象编程。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-prototype)