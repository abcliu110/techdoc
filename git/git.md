<div id="chap-template"></div>

[⬆️ 返回目录](#catalog)


## git

这是一个涉及 Git 核心数据结构设计的精彩问题。

为什么 Git 分支只有 41 字节？这背后的技术原理在于：**Git 将“数据存储”和“引用管理”彻底解耦了。**

以下是深层技术原理的详细剖析：

### 1. 字节层面的解构：为什么恰好是 41 字节？

首先，我们通过物理层面来验证这 41 个字节是由什么组成的：

*   **40 字节：SHA-1 哈希值**
    Git 使用 SHA-1 算法来标识提交（Commit）。SHA-1 产生一个 160 位（bits）的散列值。
    在计算机中，我们通常用 **16 进制（Hexadecimal）** 来表示它。
    $160 \div 4 = 40$ 个字符。
    例如：`aa1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t`

*   **1 字节：换行符（LF）**
    为了让文件在文本编辑器中显示正常，或者被 `cat` 读取时格式规范，Git 在末尾加了一个换行符 `\n`。

**结论：** 分支文件里没有任何代码、没有文件差异、没有作者信息。它只有一行字符串。

### 2. 核心数据结构：有向无环图（DAG）

要理解为什么“只存一个哈希值”就够了，必须理解 Git 的 **Commit 对象** 结构。

当你拥有一个 Commit 的哈希值时，你就拥有了整个历史。因为 Git 的提交是像链条一样锁在一起的：

1.  **当前 Commit** 包含了：
    *   当前项目所有文件的快照（Snapshot，通过 Tree 对象引用）。
    *   **父提交（Parent Commit）** 的哈希值。

2.  **链式反应：**
    *   因为提交 C 指向 提交 B（父）。
    *   提交 B 指向 提交 A（父）。
    *   如果你知道 C 的哈希值，Git 就能顺藤摸瓜找到 B，再找到 A，一直追溯到初始提交。

**原理总结：**
**分支（Branch）不需要存储历史，它只需要存储“历史的最末端（Tip）”。** 剩下的工作，Git 通过遍历哈希链表（DAG）就能自动完成。

### 3. 对比：为什么说它“轻量”？（VS SVN）

为了凸显 Git 的设计哲学，我们对比一下传统的版本控制系统（如 SVN）：

*   **SVN 的分支（目录拷贝）：**
    在 SVN 中，创建一个分支通常意味着在服务器上把所有文件 **物理复制**（或通过 Lazy Copy 机制逻辑复制）到另一个目录（例如 `/branches/feature-a`）。这需要修改数据库结构，甚至涉及大量文件 IO。

*   **Git 的分支（贴便签）：**
    在 Git 中，创建一个分支 `dev`，无论你的项目有 10MB 还是 100GB，Git 做的操作完全一样：
    1.  拿到当前提交的哈希值（40字节）。
    2.  创建一个名为 `dev` 的文本文件。
    3.  把哈希值写进去。

    **时间复杂度是 O(1)，空间占用几乎为 0。**

### 4. 动态演示：分支移动的本质

当你我们在分支上提交代码，或者切换分支时，发生了什么？

*   **git commit：**
    1.  生成一个新的 Commit 对象（比如哈希 `new_hash`）。
    2.  Git 打开当前分支的文件（比如 `.git/refs/heads/master`）。
    3.  将里面的旧哈希替换为 `new_hash`。
    *这就是为什么说分支是“浮动”的，它只是随着提交不断更新文件里的那行字符串而已。*

*   **git checkout -b new-feature：**
    1.  读取当前所在的 Commit 哈希。
    2.  在 `.git/refs/heads/` 下新建一个文件 `new-feature`。
    3.  写入该哈希。

### 5. 进阶知识：packed-refs（例外情况）

虽然原理上分支是独立文件，但如果你项目里的分支成千上万，会有很多小文件，影响文件系统性能。

Git 有一个垃圾回收机制（`git gc`），它会将这些分散的 41 字节小文件打包压缩到一个单独的文件中：`.git/packed-refs`。

如果你去查看这个文件，会发现它就是一个巨大的列表，每一行都是：
`[哈希值] [分支名]`

这进一步证明了：**分支本质上就是一个“名称”到“哈希值”的键值对（Key-Value）映射。**

### 总结

Git 分支之所以极其轻量（41 字节），是因为：

1.  **全息性：** Git 的 Commit 对象本身包含了所有父级历史和文件快照，不需要分支来承载数据。
2.  **指针设计：** 分支仅仅是一个**动态指针**（Reference/Ref）。
3.  **哈希引用：** 它唯一的作用就是告诉 Git：“这个分支的历史进展到了哪里（指向哪个 Commit ID）”。

就好比你读一本书，书的内容（Commit 数据）很重，但书签（Branch）很轻，你只需要把书签插在第 42 页，就能随时找回之前的阅读进度。

这是一个非常敏锐的观察。简单来说：**在 Git 中，分支（Branch）的本质是指向某个提交（Commit）的指针。如果你没有提交（Commit），就没有锚点，也就无法在这个锚点上创建指针。**

以下是详细的技术原理说明，我们将深入 `.git` 目录的内部结构来解释这一现象。

### 1. 核心原理：分支只是一个“包含哈希值的文本文件”

在 Git 的技术实现中，一个分支并不是一个神奇的容器，它只是 `.git/refs/heads/` 目录下的一个普通文本文件。

*   **正常状态：** 如果你有一个叫 `master` 的分支，那么文件 `.git/refs/heads/master` 存在，且内容是最新提交的 40 位 SHA-1 哈希值（例如 `a1b2c3d...`）。
*   **Init 状态：** 当你刚运行 `git init` 时，没有任何提交生成。既然没有提交对象，就没有那个哈希值。因为没有哈希值，Git 就无法创建这个文本文件。

**结论：没有物理对象（Commit），就无法创建指向它的物理引用（Branch）。**

### 2. HEAD 的作用：未诞生的分支（Unborn Branch）

既然分支不存在，为什么运行 `git status` 会显示 `On branch master`（位于 master 分支）呢？

这是由 **HEAD** 文件决定的。请查看刚初始化的仓库中的 `.git/HEAD` 文件内容：

```bash
$ cat .git/HEAD
ref: refs/heads/master
```

这里的原理如下：

1.  **符号引用（Symbolic Ref）：** `HEAD` 是一个指针，它告诉 Git “我现在正处于哪个分支上”。
2.  **虚空指向：** 此时 `HEAD` 指向了 `refs/heads/master`。但是，你去文件系统中找，会发现 `.git/refs/heads/` 目录是空的，`master` 文件根本不存在。
3.  **未诞生状态：** Git 将这种“HEAD 指向了一个不存在的引用”的状态称为 **Unborn Branch**（未诞生的分支）。

Git 在逻辑上知道“如果未来产生了提交，我应该把它归在 `master` 名下”，但在物理上，`master` 分支还未真正建立。

### 3. 第一条提交（Root Commit）时发生了什么？

当你执行 `git add .` 然后 `git commit -m "first commit"` 时，Git 内部发生了一系列动作，这也是分支真正诞生的时刻：

1.  **创建对象：** Git 根据文件内容创建 Blob 对象和 Tree 对象。
2.  **创建提交：** Git 创建一个 Commit 对象（假设哈希为 `e9f01a...`）。
3.  **解析 HEAD：** Git 读取 `HEAD` 文件，发现它指向 `refs/heads/master`。
4.  **写入分支引用：** Git **第一次** 在文件系统中创建 `.git/refs/heads/master` 文件，并将 `e9f01a...` 写入其中。

此时，分支才算真正“创建”完成。

### 4. 总结与比喻

为了方便理解，可以打个比方：

*   **Commit（提交）：** 是一块砖头。
*   **Branch（分支）：** 是一张贴纸（标签），必须贴在砖头上。
*   **git init：** 你手里拿着一张写着 "master" 的贴纸，但是地上没有砖头。
*   **结果：** 你只能先把贴纸拿在手里（存储在 HEAD 的意图中），无法把它贴出去（无法在文件系统中创建分支文件）。

### 关键技术点复盘

*   **Git 分支极其轻量：** 只是一个 41 字节的文件（40字节哈希 + 换行符）。
*   **先有鸡（Commit），后有蛋（Branch）：** 引用必须指向存在的对象。
*   **HEAD 是特殊的：** HEAD 可以指向一个不存在的分支名，这为“第一次提交”预留了位置。

这是一个非常经典的问题，很多初学者都会对 **Pull Request (PR)** 这个名字感到困惑，因为从提交者的视角看，感觉像是把自己写的代码“推（Push）”给别人。

要理解这个名字，必须回到 **Git 的分布式协作机制** 以及 **仓库维护者（Maintainer）的视角**。

### 1. 为什么叫 Pull Request？

**核心逻辑：这是一个“请求（Request）”，请求仓库管理员去执行“拉取（Pull）”动作。**

让我们模拟一下在这个术语诞生时的场景（以 GitHub 为例）：

1.  **背景**：你（开发者）想给一个开源项目（比如 Linux 或 React）贡献代码。
2.  **限制**：你没有权限直接修改别人的仓库，所以你不能直接 `Push` 代码进去。
3.  **操作**：
    *   你把对方的仓库 **Fork**（复制）一份到你自己的名下。
    *   你在自己的仓库里修改代码，然后提交。
    *   这时候，代码只存在于 **你** 的仓库里。
4.  **发起请求**：你需要通知原仓库的管理员。你的潜台词是：
    > “嘿，管理员，我在我的仓库里做了一些修改，请你从我这里把代码 **拉（Pull）** 到你的仓库里去吧。”

**因此，你在发出的这个请求，就是 Requesting a Pull —— 即 Pull Request。**

在底层 Git 命令中，管理员接受你代码的操作实际上就是 `git pull <你的仓库地址> <你的分支>`。

---

### 2. 有对应的“反向名称”吗？

如果我们谈论的是“把代码合并”这个流程的名称，主要有两个流派：

#### A. 另一派的叫法：Merge Request (MR)
**这是 GitLab 和 Gitee 等平台使用的术语。**

*   **含义**：它关注的是**结果**。
*   **逻辑**：提交者是在说：“嘿，管理员，我改好了，请把这些代码 **合并（Merge）** 进主分支吧。”
*   **区别**：
    *   **GitHub** 叫 **PR**（强调动作：你来**拉**一下）。
    *   **GitLab** 叫 **MR**（强调结果：把它**合**进去）。
    *   **本质**：两者指代的是完全一样的东西，只是命名哲学不同。

#### B. 真正的“反向动作”：Push (推)
如果非要找“Pull Request”的反义词，那并不是一个“请求”，而是一个直接的**动作**。

*   **Direct Push (直接推送)**：
    如果你是仓库的拥有者，或者你是团队核心成员，拥有“写权限（Write Access）”，你不需要请求别人，你可以直接把代码 `git push` 上去。

    *   **Pull Request** = 我没有权限/我想让你审查，所以我**请求**你**拉**过去。
    *   **Direct Push** = 我有权限，我直接**推**进去。

### 总结

*   **Pull Request (PR)**：GitHub 术语。从**接收者**的角度命名（请求你去 Pull）。
*   **Merge Request (MR)**：GitLab 术语。从**结果**的角度命名（请求你去 Merge）。
*   没有“Push Request”这种说法，因为如果你能 Push，你就不需要 Request 了。


在 Git 中，查看“当前分支”和查看“默认分支”通常涉及不同的命令。以下是具体的方法：

### 1. 如何查看当前分支 (Current Branch)

这里有几种常用方法，取决于你想要的信息详细程度：

**方法一：列出所有分支并高亮当前分支（最常用）**
```bash
git branch
```
*   **结果**：它会列出本地所有分支。
*   **如何识别**：当前所在的分支前面会有一个星号 `*`，且通常显示为**绿色**。
    > 例如：
    >   master
    > * **dev**  <-- *这是当前分支*

**方法二：仅显示当前分支名称（最简洁）**
如果你只想要当前分支的名字（例如用于脚本中），可以使用：
```bash
git branch --show-current
```
*   **结果**：仅输出当前分支的名称（例如 `main` 或 `dev`）。
    *注意：此命令需要 Git 版本 2.22 或更高。*

**方法三：查看状态信息**
```bash
git status
```
*   **结果**：第一行通常会显示 `On branch [分支名]`。

---

### 2. 如何查看默认分支 (Default Branch)

“默认分支”通常指的是远程仓库（Remote）的主分支（通常是 `main` 或 `master`）。

**方法一：查看远程仓库详情（最准确）**
这是查看远程服务器（如 GitHub/GitLab）上定义的默认分支的最可靠方法。
```bash
git remote show origin
```
*   **结果**：在输出的信息中，找到 **`HEAD branch`** 这一行。
    > 输出示例：
    > * remote origin
    >   Fetch URL: https://github.com/user/repo.git
    >   ...
    >   **HEAD branch: main**  <-- *这是默认分支*

**方法二：查看本地引用的远程 HEAD**
如果你克隆仓库时下载了远程的 HEAD 引用，可以用这个命令：
```bash
git symbolic-ref refs/remotes/origin/HEAD
```
*   **结果**：通常输出 `refs/remotes/origin/main`，最后的 `main` 就是默认分支。
    *注意：如果你手动修改过本地的 remote 配置，这个可能不准，方法一更稳妥。*

**补充：查看 Git 全局新建仓库的默认分支设置**
如果你是想看“我在本机新建一个仓库时，Git 会默认叫它 master 还是 main”，可以查看全局配置：
```bash
git config --global init.defaultBranch
```
*   如果输出为空，Git 旧版本默认为 `master`。
*   现在通常建议设置为 `main`。

### 总结
*   **看当前在哪**：`git branch` (找带 `*` 的)
*   **看远程默认是谁**：`git remote show origin` (找 `HEAD branch`)

这两个命令在语法上非常相似，唯一的区别在于**目标分支**不同（一个是 `master`，一个是 `develop`）。

通常在 **初始化项目** 或者 **首次将本地的 Git Flow 结构推送到远程仓库** 时，你会连续运行这两个命令。

下面我将从**语法拆解**、**`-u` 的核心作用**以及**它们在 Git Flow 中的地位**三个维度进行深入解析。

---

### 1. 逐词语法拆解

以 `git push -u origin develop` 为例：

*   **`git push`**:
    *   **动作**：将本地的代码提交（commit）上传到远程仓库。
    *   **默认行为**：如果没有后面的参数，它可能会报错，或者根据配置猜测你要推送到哪里。

*   **`-u`** (全称 `--set-upstream`):
    *   **关键点**：这是这条命令的**灵魂**。
    *   **含义**：它建立了一个**“上游（Upstream）跟踪关系”**。它告诉 Git：“以后我如果不指定参数，默认就是指这个远程分支。”

*   **`origin`**:
    *   **含义**：远程仓库的别名。
    *   通常当你 `git clone` 或者 `git remote add` 时，默认的远程仓库名字就叫 `origin`。它代表了代码托管平台（如 GitHub、GitLab）上的那个服务器地址。

*   **`master` / `develop`**:
    *   **含义**：你要推送的**本地分支名称**。
    *   Git 会尝试在远程仓库（origin）也创建一个同名的分支（如果远程不存在的话），并将代码推上去。

---

### 2. 核心解析：为什么要加 `-u`？

如果你只运行 `git push origin master`（不加 `-u`），代码也能推上去，但**连接没有建立**。

**加上 `-u` 之后发生了什么？**

1.  **绑定关系**：
    Git 会在本地配置文件（`.git/config`）里写下一行记录：
    > "本地的 `master` 分支，以后对应的就是 `origin` 上的 `master` 分支。"

2.  **后续操作简化**：
    建立关系后，以后你在该分支下只需要输入简短的命令：
    *   `git pull` —— 自动知道去 `origin master` 拉取。
    *   `git push` —— 自动知道推送到 `origin master`。

    *如果不加 `-u`，你以后每次 `pull` 或 `push` 可能都需要完整地敲出 `git push origin master`，或者 Git 会提示你当前分支没有跟踪信息。*

---

### 3. 为什么需要分别推送这两个分支？（Git Flow 语境）

在 Git Flow 工作流中，这两个分支是**长期存在**且**不可或缺**的基石，它们的职能完全不同，所以必须分别初始化并推送到远程，以便团队协作。

#### `git push -u origin master`
*   **分支身份**：**生产主线**。
*   **内容**：这里存放的是**随时可以发布到生产环境**的稳定代码。通常对应线上的 `v1.0`, `v1.1` 等版本。
*   **目的**：确保远程仓库有一个稳定的底座，所有人都知道这是“正版”代码。

#### `git push -u origin develop`
*   **分支身份**：**开发主线**。
*   **内容**：这里存放的是**最新的开发进度**。包含了所有已经完成但尚未发布的特性（Feature）。
*   **目的**：团队成员主要是在这个分支上进行协作。当你 `git flow feature start` 时，你的新分支就是基于这个远程同步下来的 `develop` 创建的。

---

### 总结

当你执行这两条命令时，你实际上是在对远程仓库说：

1.  **“我在本地准备好了两个核心分支（生产用的 `master` 和开发用的 `develop`），现在把它们都上传到服务器。”**
2.  **“并且，请记住它们之间的对应关系（绑定 `-u`），以后我要是敲简单的 `git pull`，你就自动帮我同步对应的分支，别再问我要去哪拉代码了。”**


这是一个非常棒的追问。既然分支只是“指针”，而提交是“链条”，那么合并（Merge）究竟是在干什么？

合并主要分为两种情况，理解了这两种情况，你就彻底打通了 Git 的任督二脉。

我们继续用**“指针”**和**“登山绳”**的模型来解释。

---

### 第一种情况：Fast-forward（快进模式）——“直接瞬移”

这是最简单的情况。也就是我们刚才说的“分支就是移动贴纸”。

**场景：**
1.  你处于 `master` 分支（指向提交 A）。
2.  你创建了 `dev` 分支，并提交了两次（A -> B -> C）。此时 `dev` 指向 C。
3.  **注意：** 在你开发 `dev` 的时候，`master` **原地没动**，还在 A。

**操作：**
你切换回 `master`，执行 `git merge dev`。

**发生了什么？**
Git 此时会想：“既然 `master` 指向的 A 是 `dev` 指向的 C 的祖先，而且 `master` 并没有产生分叉，那我根本不需要合并任何代码。”

Git 只需要做一件事：**把 `master` 这个指针（贴纸），直接从 A 撕下来，贴到 C 上。**

*   **文件操作：** 仅仅是把 `.git/refs/heads/master` 文件里的哈希值，从 A 改成了 C。
*   **结果：** 瞬间完成，没有产生新的“合并提交”。

---

### 第二种情况：3-Way Merge（三方合并）——“打结”

这是真正的“合并”。

**场景：**
1.  共同祖先是 A。
2.  `master` 分支前进了，指向了 **B**（A -> B）。
3.  `dev` 分支也前进了，指向了 **C**（A -> C）。
4.  此时，两条绳子分叉了，变成了 Y 字形。

**操作：**
在 `master` 上执行 `git merge dev`。

**发生了什么？**
既然指针不能直接“瞬移”（因为 B 不是 C 的祖先，如果直接移到 C，B 的修改就丢了），Git 必须创建一个**新的提交**来把这两条分叉的绳子系在一起。

这个过程涉及三个关键角色（所以叫 3-Way Merge）：
1.  **我的当前位置（Mine）：** B
2.  **你的位置（Theirs）：** C
3.  **共同祖先（Base）：** A（Git 会自动往回找，找到他们最后一次在一起的地方）。

#### 技术步骤：

1.  **计算差异：**
    *   Git 看 A 到 B 改了什么（比如修改了第一行）。
    *   Git 看 A 到 C 改了什么（比如修改了第十行）。

2.  **合体（Patching）：**
    *   Git 将这两组修改合在一起，生成一套新的文件快照。
    *   *（如果有冲突，比如都改了第一行，Git 就在这里停下让你手动解决，解决完后继续）。*

3.  **创建“合并提交”（Merge Commit）：**
    *   这是最关键的一步！Git 创建了一个新的提交对象 **D**。
    *   **特殊之处：** 普通提交只有一个父节点（Parent），但**合并提交 D 有两个父节点！**
        *   Parent 1: **B** (`master` 之前的样子)
        *   Parent 2: **C** (`dev` 的样子)

4.  **移动指针：**
    *   Git 把 `master` 指针移动到新的 **D** 上。

#### 此时的数据结构图解：

```text
      /--> B --\
A --<           D (master)
      \--> C --/
           ^
         (dev)
```

*   **A** 是分叉点。
*   **D** 是汇合点（Merge Commit）。
*   **D 内部的数据：** `parent: [hash_B, hash_C]`。这就把两条历史线重新归并到了一起。

---

### 总结：合并的本质

1.  **如果是 Fast-forward：**
    *   **本质：** 仅仅是更新 `.git/refs/heads/master` 文件里的哈希值。
    *   **比喻：** 追赶。你站在原地，队友跑远了，你直接跑过去和他并排站。

2.  **如果是 True Merge：**
    *   **本质：** 创建了一个拥有**两个父亲**的新提交对象，形成了一个菱形（DAG 闭环）。
    *   **比喻：** 汇合。你走左边路，队友走右边路，最后你们在终点相遇，并把两条路上的战利品放在一起，立了一块碑（Merge Commit），这块碑上写着：“不管是左边来的还是右边来的，都能通向这里。”
    *   
这又是一个直击 Git 核心设计的问题。

你可能认为 Git 把这个“链表”存在了某个数据库文件里（比如 SQLite 或 XML），或者一个巨大的文本文件里。

但实际上，Git 的存储方式更加**原始且硬核**。

**核心结论：**
Git 没有一个中心化的“链表文件”。所谓的链表，是**物理分散存储在文件系统中的一个个独立文件**，通过**哈希值（SHA-1）**相互引用串联起来的。

Git 本质上是一个 **键值对文件系统（Key-Value File System）**。

---

### 1. 物理位置：在哪里？

请打开你的项目目录，进入隐藏文件夹：
`your_project/.git/objects/`

你会看到这样的结构：

```text
.git/objects/
├── 0a/
│   └── 7b3d9... (一长串字符的文件)
├── 4f/
│   └── e2a1c...
├── pack/
└── info/
```

这就是 Git 的数据库。
*   **Key（键）：** 文件的路径（由 SHA-1 哈希值决定）。
*   **Value（值）：** 文件里面的内容（经过 zlib 压缩）。

### 2. 存储原理：哈希即路径

假设一个 Commit 的哈希值是 `e9f01a...`。

Git **不会** 把所有对象都堆在 `objects` 根目录下（因为文件系统在一个目录下存几十万个文件会变慢）。它做了一个简单的**分片（Sharding）**：

1.  取哈希值的前 **2** 位作为**目录名**：`e9`
2.  取剩下的 **38** 位作为**文件名**：`f01a...`

所以，当你提交代码生成 `e9f01a...` 时，Git 就在文件系统中创建了文件：
`.git/objects/e9/f01a...`

### 3. 技术原理：链表是如何“物理连接”的？

既然文件是分散的，它们怎么知道谁是爸爸？

答案在**文件内容**里。

虽然这些文件在磁盘上是二进制乱码（因为经过了 zlib 压缩），但我们可以用 Git 的底层命令 `git cat-file -p` 来解压并查看其原始内容。

假设我们有两个提交：A（旧） <- B（新）。

#### 查看提交 B（子节点）的原始内容：

执行 `git cat-file -p <Commit-B-Hash>`，你会看到：

```text
tree 3b18e512...      <-- 这一刻的项目文件快照
parent 8a27c109...    <-- 【关键！】这就是链表的“指针”
author zhangsan ...
committer zhangsan ...

Fixed the login bug   <-- 提交信息
```

**技术解密：**
*   在这个纯文本内容中，`parent 8a27c109...` 这一行就是物理链接。
*   Git 看到这行，就知道：“哦，我要去找 `.git/objects/8a/27c109...` 这个文件读取上一级历史。”

#### 查看提交 A（父节点）的原始内容：

执行 `git cat-file -p <Commit-A-Hash>`：

```text
tree 9c4a123...
author zhangsan ...
committer zhangsan ...

First commit
```

**技术解密：**
*   这里**没有 parent 字段**。
*   Git 读到这里，发现没有 parent，就知道：“到头了，这是 Root Commit（根提交）。”

### 4. 进阶：Packfiles（打包文件）

你可能会问：*“如果我有 10 万次提交，难道就有 10 万个小文件吗？这也太浪费空间了吧？”*

你说得对。Git 有一个优化机制叫 **GC (Garbage Collection)**。

当松散对象（Loose Objects）太多时，Git 会自动（或者你手动运行 `git gc`）把这些小文件打包。

*   **位置：** `.git/objects/pack/`
*   **原理：**
    1.  Git 把那些分散的小文件读取出来。
    2.  通过**差分编码（Delta Encoding）**技术，只存储文件修改的部分（比如 B 只是在 A 的基础上改了一行，那 B 只存那一行）。
    3.  把它们压缩塞进一个巨大的 `.pack` 文件中。
    4.  同时生成一个 `.idx` (索引) 文件，记录每个哈希值在 `.pack` 文件里的偏移量。

所以，在大型项目中，历史链表通常是存储在**高度压缩的二进制 Pack 文件**中的，通过 Offset（偏移量）来定位。

### 总结：链表是“虚拟”的

1.  **没有物理链表：** 磁盘上没有一个文件叫 `history.list` 存着 `A->B->C`。
2.  **只有分散的对象：** 磁盘上全是独立的文件（Object）。
3.  **内容即链接：** 每个 Commit 对象在自己的肚子里，写着它父亲的名字（Parent Hash）。
4.  **运行时构建：** 当你运行 `git log` 时，Git 是通过不断读取文件、解析 Parent 字段、再读取下一个文件，**在内存中动态复原**出这条链表的。

**一句话总结：Git 的历史链表，是由无数个静态的快照文件，通过内嵌的哈希指针，像寻宝游戏一样串联起来的。**

这是一个非常深刻的问题，触及了 Git 能够秒级处理巨型项目的核心机密。

既然 Git 存储的是**完整的快照（Snapshot）**，而不是补丁（Patch），当你运行 `git show` 或 `git log -p` 时，Git 是如何瞬间告诉你“只有 `main.py` 修改了一行代码”，而不是把整个项目的几万个文件都丢给你呢？

**答案是：Git 并不“知道”哪些文件被修改了，它是通过“动态比对”算出来的。**

但是，这种比对拥有一个**极速作弊码**——**哈希短路（Hash Short-circuiting）**。

---

### 1. 核心逻辑：找爸爸（Parent）

要算出“修改了什么”，必须有两个参照物。
对于一个 Commit（比如 `Commit-B`），Git 会这样做：

1.  读取 `Commit-B` 的数据，找到它的 **根 Tree 哈希**（我们叫它 `Tree-B`）。
2.  读取 `Commit-B` 的 `parent` 字段，找到它的父提交 `Commit-A`。
3.  读取 `Commit-A` 的数据，找到它的 **根 Tree 哈希**（我们叫它 `Tree-A`）。

**任务变成了：找出 `Tree-A` 和 `Tree-B` 的区别。**

---

### 2. 算法原理：树的差异分析 (Tree Diffing)

Git 使用一种递归算法来对比两棵树。因为 Merkle Tree 的特性（内容变哈希必变），Git 可以极其高效地跳过那些没变的部分。

假设你的项目很大，有 `src/`、`lib/`、`docs/` 三个大目录。你只修改了 `src/utils/math.py`。

#### 第一轮比对：根目录 (Root Tree)
Git 把 `Tree-A`（旧）和 `Tree-B`（新）放在一起对比列表：

*   **docs/**:
    *   旧 Tree 里的哈希是 `a1b2...`
    *   新 Tree 里的哈希是 `a1b2...`
    *   **判定：** 哈希一样 -> **完全跳过！**（不管 `docs` 下面有一万个文件，Git 看都不看，直接判定没变化）。
*   **lib/**:
    *   旧哈希 `c3d4...` vs 新哈希 `c3d4...`
    *   **判定：** 哈希一样 -> **完全跳过！**
*   **src/**:
    *   旧哈希 `e5f6...`
    *   新哈希 `9988...`（不一样！）
    *   **判定：** 哈希不同 -> **必须进去看看**。

#### 第二轮比对：src 目录
Git 进入 `src` 目录的 Tree 对象，对比里面的条目：

*   **components/**: 哈希相同 -> 跳过。
*   **views/**: 哈希相同 -> 跳过。
*   **utils/**:
    *   旧哈希 `old_hash` vs 新哈希 `new_hash`。
    *   **判定：** 哈希不同 -> **继续深入**。

#### 第三轮比对：utils 目录
Git 进入 `utils` 目录：

*   **string.py**: 哈希相同 -> 跳过。
*   **math.py**:
    *   旧 Blob 哈希 `blob_1`
    *   新 Blob 哈希 `blob_2`
    *   **判定：** 这是一个文件（Blob），且哈希不同 -> **标记为“已修改 (Modified)”**。

---

### 3. 最终结果：Diff 的生成

经过上面的“消消乐”过程，Git 最终只锁定了 `math.py` 这一个文件。

接下来，Git 会拿出 `blob_1`（旧内容）和 `blob_2`（新内容），进行**文本差异比较（Text Diff）**，也就是我们熟悉的按行比较（Line-by-line comparison），计算出：
```diff
- return a + b
+ return a * b
```

### 4. 总结：为什么这么快？

通常认为“对比两个项目的全量文件”是非常慢的（时间复杂度 $O(N)$，N是文件总数）。

但因为 Git 的 Merkle Tree 结构，**Git 只需要对比“修改过的路径”上的节点**。

*   如果你的项目有 100 万个文件，但你只改了 1 个文件。
*   Git 不需要遍历 100 万个文件。
*   Git 只需要遍历：根目录 -> 子目录 -> ... -> 目标文件。
*   时间复杂度变成了 $O(D)$，D 是目录深度（通常只有几层）。

**结论：**
Git 知道哪些被修改，不是因为它“记下来了”，而是因为它通过**哈希比对**瞬间算出来的。
**相同的哈希值 = 内容没变 = 不需要读取磁盘 = 极速。**

这是一个非常合乎逻辑的推测。如果 Git 真的像傻瓜照相机一样，每次提交都把所有文件完整复制一份，那么只要项目稍微大一点，`.git` 文件夹就会迅速撑爆你的硬盘。

但事实是：**Git 仓库通常比 SVN 等基于增量存储的仓库还要小。**

这听起来很矛盾（既是快照，又很小），原因是 Git 使用了 **“逻辑上是快照，物理上是增量”** 的双重策略。

以下是 Git 节省空间的“三板斧”：

---

### 第一板斧：智能复用（去重）—— 不改动，不存储

**只有被修改的文件，才会产生新的数据占用。**

假设你的项目有 **10,000 个文件**，总大小 500MB。
你修改了其中 **1 个文件**（大小 1KB），然后提交。

*   **逻辑上（用户看到的）：** 新提交包含完整的 10,000 个文件。
*   **物理上（硬盘里存的）：**
    *   Git 创建 **1 个** 新的 Blob（1KB）。
    *   Git 创建一个新的 Tree，其中 9,999 个条目指向**旧的 Blob 哈希**，只有 1 个条目指向新的 Blob 哈希。
    *   **实际增加空间：** 仅 1KB 多一点（Blob + Tree 开销）。

**结论：** 对于没改动的文件，Git 只是存了一个 40 字节的指针，而不是复制文件。

---

### 第二板斧：Zlib 压缩 —— 存的时候先压扁

Git 中的每一个对象（Blob, Tree, Commit），在写入磁盘之前，都会经过 **zlib** 压缩。

*   **源代码的特性：** 代码通常是纯文本，而且重复率极高（关键字、空格、结构）。
*   **压缩率：** 文本文件的压缩率通常在 60% - 80% 之间。
*   **效果：** 一个 100KB 的代码文件，存成 Blob 可能只有 20KB-30KB。

---

### 第三板斧：Packfiles（打包文件）—— 真正的“黑科技”

这是最关键的一点，也是 Git 解决“大文件微小修改”导致空间爆炸的终极武器。

**场景：**
假设你有一个 **100MB** 的 SQL 数据库导出文件。你只在这个文件末尾加了一行字，然后提交。
按照“第一板斧”，Git 确实会存两个 100MB 的 Blob（共 200MB）。这显然不可接受。

**Git 的解决方案：`git gc` (垃圾回收) 与 Packfile**

当 Git 发现松散对象（Loose Objects）太多，或者你主动推送到远程时，它会触发打包过程：

1.  **寻找相似对象：** Git 会扫描所有的 Blob，寻找内容相似的文件（不局限于同一个文件名的不同版本，Git 甚至能发现你复制粘贴后的另一个文件）。
2.  **差分编码（Delta Encoding）：**
    *   Git 会存储一个 **Base Object（基底对象）**（通常是最新版本，因为读取最频繁）。
    *   对于旧版本，Git 只存储 **Delta（差异/补丁）**。
3.  **写入 Packfile：** 这些数据会被压缩塞进 `.git/objects/pack/` 下的一个二进制文件中。

**回到 100MB 文件的例子：**
在打包后：
*   **Blob A (新版):** 完整存储 (100MB，压缩后可能 30MB)。
*   **Blob B (旧版):** 仅存储差异 (可能只有几字节) + 指向 A 的指针。

**结果：** 两个版本的总占用空间几乎等于一个版本。

> **注意：** 这与 SVN 的差异存储不同。SVN 是按文件名和时间顺序硬性存储差异。Git 是**基于内容**动态寻找最佳的压缩差异方案。即使你把文件改名了，Git 也能找出来它们是相似的，并进行差分压缩。

---

### 4. 为什么这么设计？（快照 vs 增量）

你可能会问：*“既然物理上还是存增量，为什么不直接说 Git 是增量存储系统呢？”*

这就是 **API 设计** 与 **底层实现** 的区别：

*   **对于开发者/逻辑层：** Git 假装自己是**全量快照**。
    *   好处：当你检出（Checkout）任何一个版本时，Git 不需要从第一天开始一行行打补丁算出来，它只要根据 Tree 直接读取（或从 Packfile 还原）即可。**这让 Git 的“检出”和“分支切换”速度极快。**

*   **对于磁盘/物理层：** Git 偷偷使用了**增量压缩**。
    *   好处：极致节省硬盘空间。

### 总结

Git 之所以数据量不大，是因为：

1.  **没改动的文件**，只存指针（0 空间占用）。
2.  **所有文件**，都经过 Zlib 压缩（高压缩率）。
3.  **相似的大文件**，通过 Packfiles 进行二进制差分存储（消除冗余）。

所以，放心提交吧，Git 甚至比你直接压缩备份代码还要节省空间。

这是一个非常严谨的“解剖学”过程。我们将像外科医生一样，切开 `.git` 目录，一步步观察在 `git init`、`add` 和 `commit` 过程中，文件系统到底发生了什么物理变化。

假设我们的项目目录叫 `demo_project`，里面只有一个文件 `hello.txt`，内容是 `v1`。

---

### 第一阶段：创世 —— `git init`

当你输入 `git init` 时，Git 在文件系统中创建了一个骨架，但此时是“死”的，没有血肉。

#### 1. 文件系统变化
在 `demo_project` 下生成了 `.git` 隐藏目录：

```text
.git/
├── HEAD         <-- [核心] 这是一个文本文件
├── config       <-- 配置文件
├── objects/     <-- [数据库] 只有空的 info 和 pack 目录
├── refs/        <-- [指针] 只有空的 heads 和 tags 目录
└── hooks/       <-- 脚本钩子
```

#### 2. 关键文件解密

*   **`.git/HEAD`**
    此时它的内容是：
    ```text
    ref: refs/heads/master
    ```
    **技术解读：** Git 告诉自己“我当前处于 `master` 分支”。但是，请注意，`.git/refs/heads/master` 这个文件**根本不存在**。这就是所谓的“未诞生的分支”（Unborn Branch）。

---

### 第二阶段：暂存 —— `git add hello.txt`

当你创建 `hello.txt` (内容 "v1") 并执行 `git add .` 时，Git 开始向数据库写入第一批数据。

#### 1. 计算哈希与压缩
Git 读取 `hello.txt`，计算 "v1" 的 SHA-1 哈希（假设是 `a1b2c3...`），并用 zlib 压缩内容。

#### 2. 文件系统变化

*   **变化一：对象库 (`.git/objects`) 增加了 1 个文件**
    Git 创建了 **Blob 对象**。
    路径：`.git/objects/a1/b2c3...` (前2位做目录，后38位做文件名)。
    *内容：* 它是 "v1" 的压缩二进制副本。

*   **变化二：索引文件 (`.git/index`) 被创建/更新**
    这是一个二进制文件。它记录了“暂存区”的状态。
    *逻辑内容：* `hello.txt` --> 指向 Blob `a1b2c3...`。

> **注意：** 此时 `master` 分支依然不存在。

---

### 第三阶段：诞生 —— `git commit -m "first"`

这是最关键的一步。当你按下回车，Git 会在一瞬间创建 3 个新对象，并终于创建了 `master` 文件。

#### 1. 生成 Tree 对象 (对应根目录)
Git 根据 `.git/index`（暂存区）的内容，计算出项目目录结构的快照。
*   生成哈希：假设是 `tree_hash_1`。
*   **写入文件：** `.git/objects/tr/ee_hash_1...`。
*   *内容含义：* 包含列表 "100644 blob a1b2c3... hello.txt"。

#### 2. 生成 Commit 对象
Git 创建一个提交对象，包裹住上面的 Tree。
*   生成哈希：假设是 `commit_hash_1`。
*   **写入文件：** `.git/objects/co/mmit_hash_1...`。
*   *内容含义：*
    ```text
    tree tree_hash_1
    parent (空，因为是第一次提交)
    author/committer (你的名字和时间)
    message "first"
    ```

#### 3. 创建 Master 分支 (物理文件出现！)
Git 终于在文件系统中创建了分支引用。
*   **创建文件：** `.git/refs/heads/master`
*   **文件内容：**
    ```text
    commit_hash_1
    ```
    (就是一个纯文本，里面只有那 40 个字符的哈希值)。

#### 4. 更新日志 (Reflogs)
Git 会更新 `.git/logs/HEAD` 和 `.git/logs/refs/heads/master`，记录这次操作的历史轨迹。

---

### 第四阶段：演化 —— 修改并第二次提交

现在我们将 `hello.txt` 的内容改为 "v2"，并提交。

#### 1. `git add .`
*   **Blob：** 计算 "v2" 的哈希（`blob_hash_2`）。在 `.git/objects` 下创建新文件。
*   **Index：** 更新 `.git/index`，现在 `hello.txt` 指向 `blob_hash_2`。

#### 2. `git commit -m "second"`
*   **Tree：** 生成新的根 Tree 对象（`tree_hash_2`），指向新的 Blob。
    *   **写入文件：** `.git/objects/tr/ee_hash_2...`
*   **Commit：** 生成新的 Commit 对象（`commit_hash_2`）。
    *   **写入文件：** `.git/objects/co/mmit_hash_2...`
    *   *内容含义：*
        ```text
        tree tree_hash_2
        parent commit_hash_1  <-- [关键] 链表形成！
        ...
        ```
*   **Update Ref：**
    Git 覆写 `.git/refs/heads/master` 文件。
    *   *旧内容：* `commit_hash_1`
    *   *新内容：* `commit_hash_2`

---

### 总结：完整的文件系统视图

经过两次提交后，你的 `.git` 目录底层结构如下（省略部分目录）：

```text
.git/
├── HEAD                   (内容: ref: refs/heads/master)
├── index                  (二进制: 记录 hello.txt -> blob_hash_2)
├── refs/
│   └── heads/
│       └── master         (内容: commit_hash_2)
└── objects/
    ├── a1/b2c3...         (Blob v1 - 第一次提交的数据)
    ├── d4/e5f6...         (Blob v2 - 第二次提交的数据)
    ├── tr/ee_hash_1...    (Tree 1 - 指向 Blob v1)
    ├── tr/ee_hash_2...    (Tree 2 - 指向 Blob v2)
    ├── co/mmit_hash_1...  (Commit 1 - 指向 Tree 1, 无 Parent)
    └── co/mmit_hash_2...  (Commit 2 - 指向 Tree 2, Parent 是 Commit 1)
```

**核心逻辑流：**
1.  **HEAD** 告诉 Git 去读 `.git/refs/heads/master`。
2.  **Master文件** 告诉 Git 最新的提交是 `commit_hash_2`。
3.  **Commit 2对象** 告诉 Git 项目快照是 `tree_hash_2`，前世是 `commit_hash_1`。
4.  **Tree 2对象** 告诉 Git 文件 `hello.txt` 的内容在 `blob_hash_2`。
5.  **Blob 2对象** 解压后就是代码 "v2"。

这就是 Git 在文件系统层面存储和管理版本的全部秘密：**一堆不可变的压缩对象文件，加上几个可变的文本指针文件。**

这是整个 Git 机制中最“省钱”、最“取巧”的一步。

接上文，假设我们现在位于 `master` 分支，最新的提交哈希是 `commit_hash_2`。

当你执行命令：
`git branch dev`
（或者 `git checkout -b dev`）

在文件系统底层，发生了以下极简的物理变化：

---

### 1. 核心动作：复制哈希值 (Copy & Paste)

Git 并不复制任何代码，也不创建新的 Tree 或 Blob 对象。它只是做了一个“抄写”动作。

#### 步骤解剖：
1.  **查：** Git 读取 `.git/HEAD`，发现你现在在 `master`。
2.  **读：** Git 读取 `.git/refs/heads/master`，拿到里面的内容：`commit_hash_2`。
3.  **写：** Git 在 `.git/refs/heads/` 目录下**新建一个文件**，名字叫 `dev`。
4.  **填：** Git 把 `commit_hash_2` 写入这个新文件。

**耗时：** 0.001秒（也就是写 41 个字节的时间）。
**磁盘占用：** 41 字节。

---

### 2. 文件系统视图的变化

**执行前 (`.git/refs/heads/`):**
```text
refs/
└── heads/
    └── master   (内容: commit_hash_2)
```

**执行后 (`.git/refs/heads/`):**
```text
refs/
└── heads/
    ├── master   (内容: commit_hash_2)
    └── dev      (内容: commit_hash_2)  <-- 新增了这一个文件
```

**Objects 目录的变化：**
**完全没有任何变化！** `objects` 目录里的 Blob、Tree、Commit 依然静静躺在那里。两个分支文件指向了**同一个 Commit 对象**。

---

### 3. 关键区别：只是创建 vs 创建并切换

这里有一个关于 `HEAD` 文件的细节变化。

#### 情况 A：只创建 (`git branch dev`)
*   `.git/refs/heads/dev` 被创建了。
*   **.git/HEAD 内容不变：** 依然是 `ref: refs/heads/master`。
*   **物理含义：** 你的身体（工作区）还站在 `master` 上，只是在旁边插了一个叫 `dev` 的旗子。

#### 情况 B：创建并切换 (`git checkout -b dev`)
*   `.git/refs/heads/dev` 被创建了。
*   **.git/HEAD 内容变了！** 变成了 `ref: refs/heads/dev`。
*   **物理含义：** Git 把用来标记“当前位置”的 HEAD 指针，修该指向了新的 `dev` 文件。

---

### 4. 此时如果提交代码，会发生什么？

假设你切换到了 `dev` 分支 (`HEAD` -> `refs/heads/dev`)，修改了文件并进行了**第三次提交** (`commit_hash_3`)。

文件系统会发生极其微妙的“分道扬镳”：

1.  **生成新对象：** `objects/` 里增加了 Commit 3、Tree 3、Blob 3。
2.  **更新指针：**
    *   Git 读取 `HEAD`，发现指向 `refs/heads/dev`。
    *   Git **只修改** `.git/refs/heads/dev` 文件，将其内容改为 `commit_hash_3`。
3.  **原地不动：**
    *   `.git/refs/heads/master` 文件内容**保持不变**，依然是 `commit_hash_2`。

**结果视图：**

```text
refs/
└── heads/
    ├── master   (指向 commit_2)
    └── dev      (指向 commit_3)
```

### 总结

创建分支的技术原理，用一句话描述就是：
**`cp .git/refs/heads/current_branch .git/refs/heads/new_branch`**

这就是为什么 Git 创建分支是瞬时的，无论你的项目有几个 G 大小，因为它只涉及创建一个 41 字节的文本文件。

我们继续在这个“手术台”上操作。

目前的状况是：
*   **Master 分支** (`.git/refs/heads/master`) 指向 `commit_2`。
*   **Dev 分支** (`.git/refs/heads/dev`) 指向 `commit_3` (它是 `commit_2` 的儿子)。
*   **Objects 目录** 里有 `commit_3` 的所有数据。

现在我们执行两个操作：同步（合并）和删除。

---

### 第一阶段：切换回 Master 并合并 (`git checkout master` & `git merge dev`)

在合并之前，必须先切换回 master。

#### 1. 切换 (`git checkout master`)
*   **文件系统变化：**
    1.  **修改 HEAD：** `.git/HEAD` 的内容从 `ref: refs/heads/dev` 变回 `ref: refs/heads/master`。
    2.  **更新工作区/暂存区：** Git 读取 `commit_2` 指向的 Tree，把你工作目录里的文件恢复成老版本（"v2"），并重写 `.git/index`。

#### 2. 合并 (`git merge dev`)
这里发生的是 **Fast-forward (快进模式)**，因为 `master` 是 `dev` 的直接祖先，没有分叉。

**文件系统底层发生了什么？**

*   **读取：** Git 去读 `.git/refs/heads/dev`，拿到哈希值 `commit_3`。
*   **覆写：** Git 直接打开 `.git/refs/heads/master` 文件，把里面的 `commit_2` 擦掉，写上 `commit_3`。
*   **Objects 目录：** **完全静默。**
    *   Git **不需要**创建新的 Commit 对象。
    *   Git **不需要**创建新的 Tree 或 Blob。
    *   因为 `commit_3` 已经包含了所有的历史和文件快照。
*   **工作区更新：** Git 将工作目录的文件更新为 `commit_3` 对应的样子（"v3"）。

**此时的状态：**
`master` 和 `dev` 两个文件（指针）现在内容完全一样，都存着 `commit_3` 的哈希值。

---

### 第二阶段：删除分支 (`git branch -d dev`)

现在代码已经同步到了 master，`dev` 分支完成了使命。

执行命令：`git branch -d dev`

**文件系统底层发生了什么？**

#### 1. 安全检查（逻辑层）
Git 会先计算一下：`dev` 指向的 `commit_3` 是否已经被 `HEAD`（也就是 `master`）包含？
*   答案是 YES（因为刚才已经把 master 移到了 commit_3）。
*   检查通过，允许删除。

#### 2. 物理删除（文件层）
Git 执行了一个简单的文件删除操作：
`rm .git/refs/heads/dev`

就这么简单。

---

### 结果：最终的文件系统视图

操作完成后，你的 `.git` 目录变成了这样：

```text
.git/
├── HEAD                   (内容: ref: refs/heads/master)
├── refs/
│   └── heads/
│       └── master         (内容: commit_3)  <-- 指向了最新的提交
│       (dev 文件已消失)
└── objects/
    ├── ...
    ├── co/mmit_3...       (Commit 3 对象)
    └── ...
```

### 关键疑问解答

**Q: `dev` 分支被删了，那 `commit_3` 的数据（Objects）会被删吗？**
**A: 不会。**
虽然 `refs/heads/dev` 文件没了，但是 `refs/heads/master` 文件现在持有 `commit_3` 的哈希值。
只要有一个“引用（Ref）”指向这个 Commit，它就是**“活的”**。Objects 目录里的数据依然安然无恙。

**Q: 如果是 `git merge --no-ff dev` (强制非快进) 呢？**
如果是强制非快进合并，Git 就不只是改写 `master` 文件的哈希值了，它会：
1.  在 `objects/` 里创建一个**全新的 Merge Commit 对象** (`commit_4`)。
2.  `commit_4` 会有两个父节点：`commit_2` (原master) 和 `commit_3` (dev)。
3.  然后把 `.git/refs/heads/master` 的内容改为 `commit_4`。

### 总结

*   **合并 (Fast-forward)：** 本质是 **"update file"**。把 `master` 文件的内容更新为 `dev` 文件的内容。
*   **删除分支：** 本质是 **"rm file"**。删除了 `.git/refs/heads/dev` 这个只有 41 字节的文件。
*   **数据安全性：** 只要提交链被合并到了主干，删除分支指针**完全不影响**底层的数据对象（Blob/Tree/Commit）。它们只是换了一个“主人”而已。

<!-- 跳转链接 -->
[⬆️ 返回目录](#catalog)  |  [文章开头 ➡️](#chap-template)